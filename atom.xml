<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyyyuna 的小花园</title>
  
  <subtitle>动静中之动</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lyyyuna.com/"/>
  <updated>2018-03-17T04:11:14.526Z</updated>
  <id>http://www.lyyyuna.com/</id>
  
  <author>
    <name>lyyyuna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现基于 HTTPS 代理的中间人攻击</title>
    <link href="http://www.lyyyuna.com/2018/03/16/http-proxy-https/"/>
    <id>http://www.lyyyuna.com/2018/03/16/http-proxy-https/</id>
    <published>2018-03-16T11:44:50.000Z</published>
    <updated>2018-03-17T04:11:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在给产品做 Web 安全测试时，经常会使用代理工具来收集 URL 及相关请求参数。</p><p>在我之前的文章介绍了 <a href="http://www.lyyyuna.com/2016/01/16/http-proxy-get1/">使用 Python 实现一个简单的 HTTP 代理</a>。但这留下一个问题，如何处理 HTTPS 流量？</p><h2 id="HTTP-隧道代理原理"><a href="#HTTP-隧道代理原理" class="headerlink" title="HTTP 隧道代理原理"></a>HTTP 隧道代理原理</h2><p>RFC 为这类代理给出了规范，<a href="https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01" target="_blank" rel="noopener">Tunneling TCP based protocols through Web proxy servers</a>。简单来讲就是通过 Web 代理服务器用隧道方式传输基于 TCP 的协议。HTTP 协议正文部分为客户端发送的原始 TCP 流量，代理发送给远端服务器后，将接收到的 TCP 流量原封不动返回给浏览器。</p><p>下面这张图片来自于《HTTP 权威指南》，展示了 HTTP 隧道代理的原理。<br><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/connect.png" alt="HTTP 隧道"></p><p>浏览器首先发起 CONNECT 请求：</p><pre><code>CONNECT example.com:443 HTTP/1.1</code></pre><p>代理收到这样的请求后，依据 host 地址与服务器建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：</p><pre><code>HTTP/1.1 200 Connection Established</code></pre><p>该报文不需要正文。浏览器一旦收到这个响应报文，就可认为与服务器的 TCP 连接已打通，后续可直接透传。</p><h2 id="HTTPS-流量中间人攻击"><a href="#HTTPS-流量中间人攻击" class="headerlink" title="HTTPS 流量中间人攻击"></a>HTTPS 流量中间人攻击</h2><p>我们很容易想到，HTTPS 代理本质上就是隧道透传，代理服务器只是透传 TCP 流量，与 GET/POST 代理有本质区别。隧道透传是安全的，代理没有私钥来解密 TLS 流量。</p><p>这带来一个问题，现在 HTTPS 越来越普遍，测试时不会特意关掉 TLS，做安全测试也就拿不到 URL 及请求参数。那怎么做呢？</p><p>首先是来看正常的隧道代理示意图：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/tls1.png" alt="TLS 示意图 1"></p><p>在如图红色的透传流量中，插入我们的<strong>中间人</strong>：</p><ol><li>用一个 TLS 服务器伪装成远端的真正的服务器，接下浏览器的 TLS 流量，解析成明文。</li><li>用明文作为原始数据，模拟 TLS 客户端向远端服务器转发。</li></ol><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/tls2.png" alt="TLS 示意图 2"></p><p>由于中间人拿到了明文，也就能够继续收集 URL 及相关请求参数。</p><h3 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h3><p>大家知道，HTTP 是需要证书的。浏览器会验证服务器发来的证书是否合法。证书若是由合法的 CA 签发，则称为合法的证书。现代浏览器在安装时都会附带全世界所有合法的 CA 证书。由 CA 证书可验证远端服务器的证书是否是合法 CA 签发的。</p><p>在 TLS 示意图 2 中，浏览器会验证假 TLS 服务器的证书：</p><ol><li>第一验证是否是合法 CA 签发。</li><li>第二验证该证书 CN 属性是否是所请求的域名。即若浏览器打开 <code>www.example.com</code>，则返回的证书 CN 属性必须是 <code>www.example.com</code>。</li></ol><p>对于第一点，合法 CA 是不可能为我们签证书的，否则就是重大安全事件了。我们只能自制 CA，并将自制 CA 导入浏览器信任链。</p><p>对于第二点，需要自制 CA 实时为域名 <code>www.example.com</code> 签一个假的证书。</p><h2 id="Go-实现"><a href="#Go-实现" class="headerlink" title="Go 实现"></a>Go 实现</h2><p>不同于之前 <a href="http://www.lyyyuna.com/2016/01/16/http-proxy-get1/">Python 实现的 HTTP 代理</a>，这次的 HTTPS 中间人代理用 Go 实现。源码见 <a href="https://github.com/lyyyuna/mitm" target="_blank" rel="noopener">https://github.com/lyyyuna/mitm</a></p><p>首先是启动一个 http server。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mitmproxy.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gomitmproxy</span><span class="params">(conf *config.Cfg, ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">tlsConfig := config.NewTLSConfig(<span class="string">"gomitmproxy-ca-pk.pem"</span>, <span class="string">"gomitmproxy-ca-cert.pem"</span>, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">handler := InitConfig(conf, tlsConfig)</span><br><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">Addr:         <span class="string">":"</span> + *conf.Port,</span><br><span class="line">ReadTimeout:  <span class="number">1</span> * time.Hour,</span><br><span class="line">WriteTimeout: <span class="number">1</span> * time.Hour,</span><br><span class="line">Handler:      handler,</span><br><span class="line">    &#125;</span><br><span class="line">............</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handler</code> 是一个实现了 <code>ServeHTTP</code> 接口的 <code>Handler</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *HandlerWrapper)</span> <span class="title">ServeHTTP</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> req.Method == <span class="string">"CONNECT"</span> &#123;</span><br><span class="line">handler.https = <span class="literal">true</span></span><br><span class="line">handler.InterceptHTTPS(resp, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler.https = <span class="literal">false</span></span><br><span class="line">handler.DumpHTTPAndHTTPS(resp, req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据请求不同分为两大类。普通 GET/POST 请求，由于是明文，可直接进行抓包。而 CONNECT 请求，则走 <code>InterceptHTTPS</code>。我们默认走 CONNECT 隧道的都是 HTTPS 流量，其他 TCP 应用层协议则不予考虑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *HandlerWrapper)</span> <span class="title">InterceptHTTPS</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">addr := req.Host</span><br><span class="line">host := strings.Split(addr, <span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 1, 为每个域名签发证书</span></span><br><span class="line">cert, err := handler.FakeCertForName(host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatalln(<span class="string">"Could not get mitm cert for name: %s\nerror: %s"</span>, host, err)</span><br><span class="line">respBadGateway(resp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 2，拿到原始 TCP 连接</span></span><br><span class="line">connIn, _, err := resp.(http.Hijacker).Hijack()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatalln(<span class="string">"Unable to access underlying connection from client: %s"</span>, err)</span><br><span class="line">respBadGateway(resp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tlsConfig := copyTlsConfig(handler.tlsConfig.ServerTLSConfig)</span><br><span class="line">    tlsConfig.Certificates = []tls.Certificate&#123;*cert&#125;</span><br><span class="line">    <span class="comment">// step 3，将 TCP 连接转化为 TLS 连接</span></span><br><span class="line">tlsConnIn := tls.Server(connIn, tlsConfig)</span><br><span class="line">listener := &amp;mitmListener&#123;tlsConnIn&#125;</span><br><span class="line">httpshandler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(resp2 http.ResponseWriter, req2 *http.Request)</span></span> &#123;</span><br><span class="line">req2.URL.Scheme = <span class="string">"https"</span></span><br><span class="line">req2.URL.Host = req2.Host</span><br><span class="line">handler.DumpHTTPAndHTTPS(resp2, req2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// step 4，启动一个伪装的 TLS 服务器</span></span><br><span class="line">err = http.Serve(listener, httpshandler)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">logger.Printf(<span class="string">"Error serving mitm'ed connection: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">connIn.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP/1.1 200 Connection Established\r\n\r\n"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一步通过 <code>FakeCertForName</code> 为浏览器请求的域名签发证书。签发所使用的 CA 为 <code>gomitmproxy-ca-pk.pem</code>, <code>gomitmproxy-ca-cert.pem</code>。</li><li>第二步通过 <code>http.Hijacker</code> 拿到原始的 TCP 连接。</li><li>第三步通过 <code>tlsConnIn := tls.Server(connIn, tlsConfig)</code>，将 TCP 连接转换为 TLS 连接。该 TLS 连接已配置有 CA 签发的证书。所谓的 TLS 连接，即 Go 应用程序可直接在该连接上拿到原始明文。</li><li>第四步通过 <code>http.Serve(listener, httpshandler)</code> 响应这个 TLS 连接。响应的回调函数所看到的都是明文，即可进行 HTTP 抓包。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上述过程即为 Burp Suite, ZAP 和 fiddler 等进行 HTTPS 抓包的原理。</p><p>我自制 HTTPS 中间人代理，主要是想结合 Sqlmap 做一个自动化 SQL 注入系统。由于目前所在 QA 团队并不具备 SQL 注入测试的经验，最大化的自动化所有过程就成了我的目标。目前还有 csrf token 未解决，主要是 csrf 实现千差万别，没有通用解决方法。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在给产品做 Web 安全测试时，经常会使用代理工具来收集 URL 及相关请求参数。&lt;/p&gt;
&lt;p&gt;在我之前的文章介绍了 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="网络" scheme="http://www.lyyyuna.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http proxy" scheme="http://www.lyyyuna.com/tags/http-proxy/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 简单对象创建的字节码分析</title>
    <link href="http://www.lyyyuna.com/2018/01/13/python-internal6-simple-object-create/"/>
    <id>http://www.lyyyuna.com/2018/01/13/python-internal6-simple-object-create/</id>
    <published>2018-01-13T08:20:02.000Z</published>
    <updated>2018-01-13T14:19:05.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 源码编译后，有常量表，符号表。一个作用域运行时会对应一个运行时栈。</p><p>大部分字节码就是基于常量表、符号表和运行时栈，运算后得到所需结果。</p><p>本篇就来分析简单对象创建的字节码。以下面这段代码为分析样本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">s = <span class="string">'python'</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line">l = []</span><br></pre></td></tr></table></figure><p>对生成的 pyc 文件解析，可得如下的结构，其中包括字节码反编译的结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">magic 03f30d0a</span><br><span class="line">moddate 836a595a (Sat Jan 13 10:10:11 2018)</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">argcount</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">argcount</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">nlocals</span>&gt;</span> 0<span class="tag">&lt;/<span class="name">nlocals</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">stacksize</span>&gt;</span> 1<span class="tag">&lt;/<span class="name">stacksize</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">flags</span>&gt;</span> 0040<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">codeobject</span>&gt;</span> 6400005a00006401005a01006900005a02006700005a030064020053<span class="tag">&lt;/<span class="name">codeobject</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dis</span>&gt;</span></span><br><span class="line">  1           0 LOAD_CONST               0 (1)</span><br><span class="line">              3 STORE_NAME               0 (i)</span><br><span class="line"></span><br><span class="line">  2           6 LOAD_CONST               1 ('python')</span><br><span class="line">              9 STORE_NAME               1 (s)</span><br><span class="line"></span><br><span class="line">  3          12 BUILD_MAP                0</span><br><span class="line">             15 STORE_NAME               2 (d)</span><br><span class="line"></span><br><span class="line">  4          18 BUILD_LIST               0</span><br><span class="line">             21 STORE_NAME               3 (l)</span><br><span class="line">             24 LOAD_CONST               2 (None)</span><br><span class="line">             27 RETURN_VALUE</span><br><span class="line">   <span class="tag">&lt;/<span class="name">dis</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">names</span>&gt;</span> ('i', 's', 'd', 'l')<span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">varnames</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">varnames</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">freevars</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">freevars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cellvars</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">cellvars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filename</span>&gt;</span> '.\\test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span> '<span class="tag">&lt;<span class="name">module</span>&gt;</span>'<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">firstlineno</span>&gt;</span> 1<span class="tag">&lt;/<span class="name">firstlineno</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">      1</span><br><span class="line">      'python'</span><br><span class="line">      None</span><br><span class="line">   <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">lnotab</span>&gt;</span> 060106010601<span class="tag">&lt;/<span class="name">lnotab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们清楚的看到 <code>consts</code> 常量表，<code>names</code> 符号表，这些表中的元素都是有明确顺序的。</p><h2 id="整数赋值"><a href="#整数赋值" class="headerlink" title="整数赋值"></a>整数赋值</h2><p>第一条语句 <code>i = 1</code>。对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 LOAD_CONST               0 (1)</span><br><span class="line">3 STORE_NAME               0 (i)</span><br></pre></td></tr></table></figure><p><code>LOAD_CONST</code> 对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET(LOAD_CONST)</span><br><span class="line">&#123;</span><br><span class="line">    x = GETITEM(consts, oparg); <span class="comment">// 从常量表 oparg 位置处取出对象</span></span><br><span class="line">    Py_INCREF(x);</span><br><span class="line">    PUSH(x); <span class="comment">// 压入堆栈</span></span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，这里参数为 0。表示从常量表第 0 个位置取出整数，并将该数压入运行时栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+----------+</span><br><span class="line">| stack | f_locals |</span><br><span class="line">+-------+----------+</span><br><span class="line">| 1     |          |</span><br><span class="line">|       |          |</span><br><span class="line">|       |          |</span><br><span class="line">+-------+----------+</span><br></pre></td></tr></table></figure><p>左侧为运行时栈，右侧为当前作用域内的局部变量。</p><p><code>STORE_NAME</code> 所对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TARGET(STORE_NAME)</span><br><span class="line">&#123;</span><br><span class="line">    w = GETITEM(names, oparg); <span class="comment">// 从符号表 oparg 位置处取出符号名</span></span><br><span class="line">    v = POP(); <span class="comment">// 弹出运行时栈的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> ((x = f-&gt;f_locals) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_CheckExact(x))</span><br><span class="line">            err = PyDict_SetItem(x, w, v); <span class="comment">// 将符号名作为键，栈顶元素作为值，放入字典中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = PyObject_SetItem(x, w, v);</span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>) DISPATCH();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = PyObject_Repr(w);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    PyErr_Format(PyExc_SystemError,</span><br><span class="line">                    <span class="string">"no locals found when storing %s"</span>,</span><br><span class="line">                    PyString_AS_STRING(t));</span><br><span class="line">    Py_DECREF(t);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，参数为 0。表示从符号表第 0 个位置处取出符号名，即 <code>i</code>。然后弹出运行时栈的栈顶元素，并将符号名作为键，栈顶元素作为值，放入字典中 <code>f_locals</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+------------+</span><br><span class="line">| stack | f_locals   |</span><br><span class="line">+-------+------------+</span><br><span class="line">|       | i, &lt;int 1&gt; |</span><br><span class="line">|       |            |</span><br><span class="line">|       |            |</span><br><span class="line">+-------+------------+</span><br></pre></td></tr></table></figure><h2 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h2><p>语句 <code>s = &#39;python&#39;</code> 所对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 LOAD_CONST               1 (&apos;python&apos;)</span><br><span class="line">9 STORE_NAME               1 (s)</span><br></pre></td></tr></table></figure><p>和整数赋值的字节码完全相同，只是参数不同。这里不再做重复分析，赋值后，运行时栈变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       |                   |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="字典赋值"><a href="#字典赋值" class="headerlink" title="字典赋值"></a>字典赋值</h2><p>语句 <code>d = {}</code> 对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 BUILD_MAP                0</span><br><span class="line">15 STORE_NAME               2 (d)</span><br></pre></td></tr></table></figure><p><code>BUILD_MAP</code> 所对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line">TARGET(BUILD_MAP)</span><br><span class="line">&#123;</span><br><span class="line">    x = _PyDict_NewPresized((Py_ssize_t)oparg);</span><br><span class="line">    PUSH(x);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) DISPATCH();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dictobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyDict_NewPresized(Py_ssize_t minused)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *op = PyDict_New();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minused&gt;<span class="number">5</span> &amp;&amp; op != <span class="literal">NULL</span> &amp;&amp; dictresize((PyDictObject *)op, minused) == <span class="number">-1</span>) &#123;</span><br><span class="line">        Py_DECREF(op);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，参数为 0。而深入 <code>_PyDict_NewPresized</code> 可以看到，若参数小于 5，实际上创建的是默认大小的字典。创建完毕后，会将该字典对象压入运行时栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------+</span><br><span class="line">| stack  | f_locals          |</span><br><span class="line">+--------+-------------------+</span><br><span class="line">| &lt;dict&gt; | i, &lt;int 1&gt;        |</span><br><span class="line">|        | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|        |                   |</span><br><span class="line">+--------+-------------------+</span><br></pre></td></tr></table></figure><p>最后 <code>STORE_NAME</code> 将该对象与符号 <code>d</code> 绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       | d, &lt;dict&gt;         |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="列表赋值"><a href="#列表赋值" class="headerlink" title="列表赋值"></a>列表赋值</h2><p>语句 <code>l = []</code> 对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18 BUILD_LIST               0</span><br><span class="line">21 STORE_NAME               3 (l)</span><br></pre></td></tr></table></figure><p><code>BUILD_LIST</code> 对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_LIST)</span><br><span class="line">&#123;</span><br><span class="line">    x =  PyList_New(oparg); <span class="comment">// 创建空列表</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; --oparg &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            w = POP(); <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">            PyList_SET_ITEM(x, oparg, w); <span class="comment">// 将弹出的元素放入列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        PUSH(x); <span class="comment">// 将列表对象放入栈中</span></span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码首先创建一个列表，列表依据参数值预先分配空间。这里不对列表做深入分析，只指出，这里的空间大小不是存放元素所占用的空间，而是 <code>PyObject *</code> 指针。</p><p>列表建完后，便会不停从运行时栈中弹出元素，然后将元素放入列表中。这里是空列表，所以 <code>BUILD_LIST</code> 运行时，栈为空，该字节码的参数也为 0。</p><p>我们换一个非空列表来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1           0 LOAD_CONST               0 (1)</span><br><span class="line">            3 LOAD_CONST               1 (2)</span><br><span class="line">            6 LOAD_CONST               2 (3)</span><br><span class="line">            9 BUILD_LIST               3</span><br><span class="line">           12 STORE_NAME               0 (l)</span><br><span class="line">           15 LOAD_CONST               3 (None)</span><br><span class="line">           18 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>BUILD_LIST</code> 之前会将三个对象压入运行时栈中。</p><p>回到本文最初的 Python 程序，4 条语句运行完后， <code>f_locals</code> 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       | d, &lt;dict&gt;         |</span><br><span class="line">|       | l, &lt;list&gt;         |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>在最后，我们还看到两行字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24 LOAD_CONST               2 (None)</span><br><span class="line">27 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>它们好像与我们的四条赋值语句没有任何关系。原来，Python 在执行了一段 CodeBlock 后，一定要返回一些值，既然如此，那就随便返回一个 <code>None</code> 好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Python 源码编译后，有常量表，符号表。一个作用域运行时会对应一个运行时栈。&lt;/p&gt;
&lt;p&gt;大部分字节码就是基于常量表、符号表和运行时栈
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - pyc 的结构</title>
    <link href="http://www.lyyyuna.com/2018/01/06/python-internal5-pyc/"/>
    <id>http://www.lyyyuna.com/2018/01/06/python-internal5-pyc/</id>
    <published>2018-01-06T08:20:02.000Z</published>
    <updated>2018-01-06T13:10:46.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 是一门解释性语言，源码执行需要经过：编译-字节码-虚拟机的步骤。本文就介绍一下 <code>.py</code> 文件编译后的 <code>.pyc</code> 文件结构。直接运行的代码不会生成 <code>.pyc</code>，而 Python 的 import 机制会触发 <code>.pyc</code> 文件的生成。</p><h2 id="magic-number-和修改时间"><a href="#magic-number-和修改时间" class="headerlink" title="magic number 和修改时间"></a>magic number 和修改时间</h2><p>我们在导入模块的源码中，能找到 <code>.pyc</code> 文件的蛛丝马迹：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Python/import.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">write_compiled_module(PyCodeObject *co, <span class="keyword">char</span> *cpathname, struct stat *srcstat, <span class="keyword">time_t</span> mtime)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    <span class="comment">/* First write a 0 for mtime */</span></span><br><span class="line">    PyMarshal_WriteLongToFile(<span class="number">0L</span>, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>.pyc</code> 文件包含三个主要内容：magic number，修改时间，和一个 <code>PyCodeObject</code> 对象。</p><p>magic number 和 Python 版本有关，magic number 不同能够防止低版本误执行高版本编译后的字节码。修改时间能让编译器决定是否重新编译源文件。</p><p>我们来读取 <code>.pyc</code> 的前八字节来验证一下我们的分析，<code>func0.py</code> 是测试脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## func0.py</span></span><br><span class="line">    f = open(fname, <span class="string">'rb'</span>)</span><br><span class="line">    magic = f.read(<span class="number">4</span>)</span><br><span class="line">    moddate = f.read(<span class="number">4</span>)</span><br><span class="line">    modtime = time.asctime(time.localtime(struct.unpack(<span class="string">'I'</span>, moddate)[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'magic number: %s'</span> % (magic.encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'moddate %s (%s)'</span> % (moddate.encode(<span class="string">'hex'</span>), modtime)</span><br></pre></td></tr></table></figure><p>被测试源文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a)</span>:</span></span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><p>使用以下强制编译成 <code>.pyc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m py_compile test.py</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python func0.py test.pyc</span><br><span class="line">magic number: 03f30d0a</span><br><span class="line">moddate 5e9a4b5a (Tue Jan  2 22:42:38 2018)</span><br></pre></td></tr></table></figure><h2 id="PyCodeObject-对象"><a href="#PyCodeObject-对象" class="headerlink" title="PyCodeObject 对象"></a>PyCodeObject 对象</h2><p><code>PyCodeObject</code> 是一段代码块编译的直接结果。换句话说，一个作用域，对应一个代码，最终对应一个编译后的 <code>PyCodeObject</code>。<br>首先看一下 <code>PyCodeObject</code> 的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">int</span> co_argcount;<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="keyword">int</span> co_nlocals;<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="keyword">int</span> co_stacksize;<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="keyword">int</span> co_flags;<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    PyObject *co_code;<span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;<span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars;<span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">    <span class="comment">/* The rest doesn't count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;<span class="comment">/* string (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;<span class="comment">/* string (name, for reference) */</span></span><br><span class="line">    <span class="keyword">int</span> co_firstlineno;<span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_lnotab;<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span></span><br><span class="line"><span class="comment">   Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure><p>一段程序不可能只有一个作用域，嵌套的子作用域存在于 <code>co_consts</code> 之中。</p><p>我们写个简单的脚本，展现这种嵌套的结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># func0.py</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_code</span><span class="params">(code, indent=<span class="string">''</span>)</span>:</span></span><br><span class="line">    old_indent = indent  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;code&gt;"</span> % indent  </span><br><span class="line">    indent += <span class="string">'   '</span>  </span><br><span class="line">    show_hex(<span class="string">"bytecode"</span>, code.co_code, indent=indent)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;filename&gt; %r&lt;/filename&gt;"</span> % (indent, code.co_filename)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;consts&gt;"</span> % indent  </span><br><span class="line">    <span class="keyword">for</span> const <span class="keyword">in</span> code.co_consts:  </span><br><span class="line">        <span class="keyword">if</span> type(const) == types.CodeType:  </span><br><span class="line">            show_code(const, indent+<span class="string">'   '</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">"   %s%r"</span> % (indent, const)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;/consts&gt;"</span> % indent  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;/code&gt;"</span> % old_indent</span><br></pre></td></tr></table></figure><p>被测试的源文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a)</span>:</span></span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure></p><p>测试步骤：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exs $ python func0.py test.pyc</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bytecode</span>&gt;</span> 6400008400005a000064010053<span class="tag">&lt;/<span class="name">bytecode</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filename</span>&gt;</span> 'test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bytecode</span>&gt;</span> 6401007d00007c0000474864000053<span class="tag">&lt;/<span class="name">bytecode</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">filename</span>&gt;</span> 'test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">            None</span><br><span class="line">         <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line">      None</span><br><span class="line">   <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，函数 <code>add</code> 作为全局作用域的中一个子作用域，在编译结果中，是以常量形式存在于全局作用域的 <code>PyCodeObject</code> 中。</p><h2 id="查看字节码"><a href="#查看字节码" class="headerlink" title="查看字节码"></a>查看字节码</h2><p>Python 提供了 <code>dis</code> 模块，其中的 <code>disassemble()</code> 函数可以反编译 <code>PyCodeObject</code> 对象，以可读的形式展现出来。<br>我们修改 <code>func0.py</code>，将字节码对应的指令打印出来，增加下述代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">show_hex(<span class="string">"bytecode"</span>, code.co_code, indent=indent)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s&lt;dis&gt;"</span> % indent  </span><br><span class="line">dis.disassemble(code)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s&lt;/dis&gt;"</span> % indent  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ python func0.py test.pyc</span><br><span class="line">&lt;code&gt;</span><br><span class="line">   &lt;bytecode&gt; 6400008400005a000064010053&lt;/bytecode&gt;</span><br><span class="line">   &lt;dis&gt;</span><br><span class="line">  3           0 LOAD_CONST               0 (&lt;code object add at 0x109aa1c30, file &quot;test.py&quot;, line 3&gt;)</span><br><span class="line">              3 MAKE_FUNCTION            0</span><br><span class="line">              6 STORE_NAME               0 (add)</span><br><span class="line">              9 LOAD_CONST               1 (None)</span><br><span class="line">             12 RETURN_VALUE</span><br><span class="line">   &lt;/dis&gt;</span><br><span class="line">   &lt;filename&gt; &apos;test.py&apos;&lt;/filename&gt;</span><br><span class="line">   &lt;consts&gt;</span><br><span class="line">      &lt;code&gt;</span><br><span class="line">         &lt;bytecode&gt; 6401007d00007c0000474864000053&lt;/bytecode&gt;</span><br><span class="line">         &lt;dis&gt;</span><br><span class="line">  4           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 STORE_FAST               0 (a)</span><br><span class="line"></span><br><span class="line">  5           6 LOAD_FAST                0 (a)</span><br><span class="line">              9 PRINT_ITEM</span><br><span class="line">             10 PRINT_NEWLINE</span><br><span class="line">             11 LOAD_CONST               0 (None)</span><br><span class="line">             14 RETURN_VALUE</span><br><span class="line">         &lt;/dis&gt;</span><br><span class="line">         &lt;filename&gt; &apos;test.py&apos;&lt;/filename&gt;</span><br><span class="line">         &lt;consts&gt;</span><br><span class="line">            None</span><br><span class="line">            1</span><br><span class="line">         &lt;/consts&gt;</span><br><span class="line">      &lt;/code&gt;</span><br><span class="line">      None</span><br><span class="line">   &lt;/consts&gt;</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Python 是一门解释性语言，源码执行需要经过：编译-字节码-虚拟机的步骤。本文就介绍一下 &lt;code&gt;.py&lt;/code&gt; 文件编译后的
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.x 源码 - 编译调试之旅</title>
    <link href="http://www.lyyyuna.com/2018/01/01/python-internal4-lldb/"/>
    <id>http://www.lyyyuna.com/2018/01/01/python-internal4-lldb/</id>
    <published>2018-01-01T08:20:02.000Z</published>
    <updated>2018-01-01T08:03:23.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h2><ol><li>从 GitHub 上下载源码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/python/cpython</span><br><span class="line">$ cd cpython</span><br></pre></td></tr></table></figure><ol><li>编译之前打开 <code>--with-pydebug</code> 选项</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --with-pydebug</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>编译完成之后，会在当前目录看到一个二进制文件 <code>python</code>。如果你使用的是 macOS，文件名为 <code>python.exe</code>，此文后续在命令行中请用 <code>python.exe</code> 代替 <code>python</code>。</p><h2 id="用-GDB-调试"><a href="#用-GDB-调试" class="headerlink" title="用 GDB 调试"></a>用 GDB 调试</h2><p>我们将使用 <code>gdb</code> 来追踪 <code>python</code> 的行为。</p><p>本小结也是一个 <code>gdb</code> 入门教程。</p><h3 id="GDB-快捷键"><a href="#GDB-快捷键" class="headerlink" title="GDB 快捷键"></a>GDB 快捷键</h3><ul><li>r (run)，运行程序</li><li>b (break)，设置断点</li><li>s (step)，单步运行</li><li>c (continue)，继续运行程序，在断点处会停止运行</li><li>l (list)，列出当前程序的源代码</li><li>ctrl+x，打开 tui 模式</li><li>ctrl+p，往上</li><li>ctrl+n，往下</li></ul><h3 id="GDB-介绍"><a href="#GDB-介绍" class="headerlink" title="GDB 介绍"></a>GDB 介绍</h3><p>在编译目录敲入命令 <code>gdb python</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">GNU gdb (GDB) 7.12</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-pc-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from python...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>在最后一行我们看到 <code>Reading symbols from python...done.</code>，说明现在我们可以通过 <code>gdb</code> 来调试 python 了。</p><p>现在程序还没有运行，调试器在程序最前端停止下来。</p><p>每一个 C 程序都从 <code>main()</code> 函数开始运行，所以我们在 <code>main()</code> 上打一个断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p><code>gdb</code> 会在 <code>Programs/python.c, line 20</code> 处打上断点。从这条信息可以看出，<code>Python</code> 的入口点为 <code>Programs/python.c:20</code>。另外，如果你事先已知晓源码，可以直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b Programs/python.c:20</span><br><span class="line">Breakpoint 3 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>运行 <code>python</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>我们停在了之前设置的断点处，使用 <code>list</code> 列出源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">15&#125;</span><br><span class="line">16#else</span><br><span class="line">17</span><br><span class="line">18int</span><br><span class="line">19main(int argc, char **argv)</span><br><span class="line">20&#123;</span><br><span class="line">21    wchar_t **argv_copy;</span><br><span class="line">22    /* We need a second copy, as Python might modify the first one. */</span><br><span class="line">23    wchar_t **argv_copy2;</span><br><span class="line">24    int i, res;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>或者使用 <code>ctrl+x</code> 调出 <code>tui</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   ┌──./Programs/python.c─────────────────────────────────────────────────────────┐</span><br><span class="line">   │15      &#125;                                                                     │</span><br><span class="line">   │16      #else                                                                 │</span><br><span class="line">   │17                                                                            │</span><br><span class="line">   │18      int                                                                   │</span><br><span class="line">   │19      main(int argc, char **argv)                                           │</span><br><span class="line">B+&gt;│20      &#123;                                                                     │</span><br><span class="line">   │21          wchar_t **argv_copy;                                              │</span><br><span class="line">   │22          /* We need a second copy, as Python might modify the first one. */│</span><br><span class="line">   │23          wchar_t **argv_copy2;                                             │</span><br><span class="line">   │24          int i, res;                                                       │</span><br><span class="line">   │25          char *oldloc;                                                     │</span><br><span class="line">   │26                                                                            │</span><br><span class="line">   └──────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">multi-thre Thread 0x7ffff7f9de In: main                         L20   PC: 0x41d1d6 </span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>在 <code>tui</code> 模式，也可以看到我们停在了源代码的第 20 行。</p><p>继续运行 <code>continue</code>，将进入 <code>python</code> 的交互式解释器环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">   │29                                                                                                                                                                                                                                      │</span><br><span class="line">   │30          argv_copy = (wchar_t **)PyMem_RawMalloc(sizeof(wchar_t*) * (argc+1));                                                                                                                                                       │</span><br><span class="line">   │31          argv_copy2 = (wchar_t **)PyMem_RawMalloc(sizeof(wchar_t*) * (argc+1));                                                                                                                                                      │</span><br><span class="line">   │32          if (!argv_copy || !argv_copy2) &#123;                                                                                                                                                                                            │</span><br><span class="line">   └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">multi-thre Thread 0x7ffff7f9de In: main                                                                                                                                                                                   L20   PC: 0x41d1d6 </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Python 3.7.0a0 (default, Feb 22 2017, 22:10:22) </span><br><span class="line">[GCC 6.3.1 20170109] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="调试语法分析器"><a href="#调试语法分析器" class="headerlink" title="调试语法分析器"></a>调试语法分析器</h2><h3 id="调试语法分析器-1"><a href="#调试语法分析器-1" class="headerlink" title="调试语法分析器"></a>调试语法分析器</h3><p>创建一个简单的 python 脚本 <code>test.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>打开 gdb，设置参数，运行 python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) set args test.py</span><br><span class="line">// 或者</span><br><span class="line">$ gdb --args python test.py</span><br></pre></td></tr></table></figure><p>并在 <code>main</code> 函数上打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h4 id="Program-python-c"><a href="#Program-python-c" class="headerlink" title="Program/python.c"></a>Program/python.c</h4><p>如果你仔细查看 <code>Program/python.c</code> 的源码，会发现 <code>main()</code> 做了很多事情，核心是调用 <code>Py_Main(argc, argv_copy)</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">argv_copy2[argc] = argv_copy[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">setlocale(LC_ALL, oldloc);</span><br><span class="line">PyMem_RawFree(oldloc);</span><br><span class="line"></span><br><span class="line">res = Py_Main(argc, argv_copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Force again malloc() allocator to release memory blocks allocated</span></span><br><span class="line"><span class="comment">   before Py_Main() */</span></span><br><span class="line">(<span class="keyword">void</span>)_PyMem_SetupAllocators(<span class="string">"malloc"</span>);</span><br></pre></td></tr></table></figure><h4 id="Modules-main-c"><a href="#Modules-main-c" class="headerlink" title="Modules/main.c"></a>Modules/main.c</h4><p>简单来说，<code>Py_Main</code> 会做如下：</p><ol><li>初始化哈希随机：391</li><li>重置 Warning 选项：394，395</li><li>通过 <code>_PyOS_GetOpt()</code> 解析命令行选项：397</li><li>通过 <code>Py_Initialize()</code> 初始化 python：693</li><li>导入 <code>readline</code> 模块：723</li><li>依次执行：<ol><li><code>run_command()</code></li><li><code>RunModule()</code></li><li><code>RunInteractiveHook()</code></li><li><code>RunMainFromImporter()</code></li><li><code>run_file()</code></li><li><code>PyRun_AnyFileFlags()</code></li></ol></li></ol><p>将断点打在 <code>run_file</code>，第 793 行，可以用 <code>p filename</code> 查看当前文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b Modules/main.c:793</span><br><span class="line">(gdb) c</span><br><span class="line">(gdb) p filename</span><br><span class="line">$1 = 0x931050 L&quot;test.py</span><br><span class="line">(gdb) s</span><br></pre></td></tr></table></figure><p><code>run_file</code> 只是一个装饰器，该装饰器会调用 <code>Python/pythonrun.c</code> 中的 <code>PyRun_InteractiveLoopFlags()</code> 或 <code>PyRun_PyRun_SimpleFileExFlags</code>。从名字上就可以看出一个会进入交互式环境，另一个就是带参数的 python 调用。这里，我们带上了参数 <code>test.py</code>，所以会运行 <code>PyRun_PyRun_SimpleFileExFlags</code>。</p><h4 id="Python-pythonrun-c"><a href="#Python-pythonrun-c" class="headerlink" title="Python/pythonrun.c"></a>Python/pythonrun.c</h4><p><code>PyRun_SimpleFileExFlags()</code> 首先会用 <code>maybe_pyc_file()</code> 检查所传文件是否是 <code>.pyc</code> 格式。</p><p>在我们的例子中，由于是 <code>.py</code> 文件，所以接着会调用 <code>PyRun_FileExFlags()</code>。最后调用 <code>PyParser_ASTFromFileObject()</code> 来建立抽象语法树（AST）。</p><p>抽象语法树需调用 <code>Parser/parsetok.c</code> 中的 <code>PyParser_ParseFileObject()</code> 创建节点，再用 <code>PyAST_FromNodeObject()</code> 函数从节点构建 AST 树。</p><h4 id="Parser-parsetok-c"><a href="#Parser-parsetok-c" class="headerlink" title="Parser/parsetok.c"></a>Parser/parsetok.c</h4><p><code>PyParser_ParseFileObject()</code> 会从 <code>PyTokenizer_FromFile()</code> 中获取所有的 toekn，将这些 token 传入 <code>parsetok()</code> 创建节点。</p><p>最有趣的部分是其中包含一个无限循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = PyTokenizer_Get(tok, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure><p>该函数是 <code>tok_get()</code> 的装饰器，它会返回预定义于 <code>token.h</code> 中的 token 类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/token.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDMARKER0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDENT5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEDENT6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPAR7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RPAR8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSQB9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RARROW          51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELLIPSIS        52</span></span><br><span class="line"><span class="comment">/* Don't forget to update the table _PyParser_TokenNames in tokenizer.c! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AWAIT54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASYNC55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERRORTOKEN56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TOKENS57</span></span><br></pre></td></tr></table></figure><p>在 for 循环的第一轮，我们在 gdb 中打印上述代码中的 <code>type</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p type</span><br><span class="line">$1 = 1</span><br></pre></td></tr></table></figure><p>根据头文件中的宏，值 1 对应 <code>NAME</code>，说明该 token 为一个变量名。</p><p>在第 236 行，<code>str[lbbben] = &#39;\0&#39;</code> 会储存 token 所对应的字符串，即 <code>a</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p str</span><br><span class="line">$2 = 0x7ffff6eb5a18 &quot;a&quot;</span><br></pre></td></tr></table></figure><p>看起来很有道理，因为我们的源码为 <code>a = 100</code>，第一个 token 字符串应对应于 <code>a</code>，类型为 <code>NAME</code>。</p><p>解析器接下来会调用 <code>PyParser_AddToken()</code>，这会将 token 加入语法树中。</p><h3 id="语法生成"><a href="#语法生成" class="headerlink" title="语法生成"></a>语法生成</h3><p>语法的文本表示在 <code>Grammar/Grammar</code> 中，这是用 <code>yacc</code> 写的，我建议直接忽略。而语法的数字表示在 <code>Python/graminit.c</code> 中，其中包含了 DFA 数组。</p><p>修改 <code>test.py</code> 的内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>打开 gdb，在 <code>PyParser_AddToken()</code> 上打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) b PyParser_AddToken</span><br><span class="line">(gdb) r test.py</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, PyParser_AddToken (ps=ps@entry=0x9cf4f0, type=type@entry=1, str=str@entry=0x7ffff6eb5a18 &quot;class&quot;, lineno=1, col_offset=0, expected_ret=expected_ret@entry=0x7fffffffdc34) at Parser/parser.c:229</span><br><span class="line">229&#123;</span><br></pre></td></tr></table></figure><p>为了看到 DFA 的状态变化，在 <code>dfa *d = ps-&gt;p_stack.s_top-&gt;s_dfa</code> 下一行打上断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 244</span><br><span class="line">Breakpoint 2 at 0x5b5933: file Parser/parser.c, line 244.</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 2, PyParser_AddToken (ps=ps@entry=0x9cf4f0, type=type@entry=1, str=str@entry=0x7ffff6eb5a18 &quot;class&quot;, lineno=1, col_offset=0, expected_ret=expected_ret@entry=0x7fffffffdc34) at Parser/parser.c:244</span><br><span class="line">244        state *s = &amp;d-&gt;d_state[ps-&gt;p_stack.s_top-&gt;s_state];</span><br></pre></td></tr></table></figure><p>然后打印出 <code>d</code> 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *d</span><br><span class="line">$6 = &#123;d_type = 269, d_name = 0x606340 &quot;stmt&quot;, d_initial = 0, d_nstates = 2, d_state = 0x8a6a40 &lt;states_13&gt;, d_first = 0x60658c &quot;&quot;&#125;</span><br><span class="line">(gdb) set print pretty</span><br><span class="line">(gdb) p *d</span><br><span class="line">$8 = &#123;</span><br><span class="line">  d_type = 269,</span><br><span class="line">  d_name = 0x606340 &quot;stmt&quot;,</span><br><span class="line">  d_initial = 0,</span><br><span class="line">  d_nstates = 2,</span><br><span class="line">  d_state = 0x8a6a40 &lt;states_13&gt;,</span><br><span class="line">  d_first = 0x60658c &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">(gdb) p d-&gt;d_name</span><br><span class="line">&apos;file_input&apos;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>对比 <code>d_name</code> 的值，发现它出现在 <code>Grammar/Grammar</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Grammar for Python</span><br><span class="line"></span><br><span class="line">single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE</span><br><span class="line">file_input: (NEWLINE | stmt)* ENDMARKER</span><br><span class="line">eval_input: testlist NEWLINE* ENDMARKER</span><br></pre></td></tr></table></figure><p>运行多次，我们会发现 <code>d_name</code> 按如下的顺序变化：<code>file_input</code>, <code>stmt</code>, <code>compound_stmt</code>, <code>classdef</code>, <code>classdef</code>, <code>classdef</code>, <code>classdef</code>, <code>suite</code>, <code>suite</code>, <code>suite</code>, <code>stmt</code>, <code>simple_stmt</code>, <code>small_stmt</code>, <code>pass_stmt</code>, <code>simple_stmt</code>, <code>suite</code>, <code>file_input</code>, <code>file_input</code>。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>查看一下到目前为止的调用栈：</p><ul><li><code>main()</code></li><li><code>Py_Main()</code></li><li><code>run_file()</code></li><li><code>PyRun_AnyFileExFlags()</code></li><li><code>PyRun_SimpleFileExFlags()</code></li><li><code>PyRun_FileExFlags()</code></li><li><code>PyParser_ASTFromFileObject()</code><ul><li><code>PyParser_ParseFileObject()</code><ul><li><code>parsetok()</code></li><li><code>PyParser_AddToken()</code></li></ul></li><li><code>PyAST_FromNodeObject()</code></li></ul></li></ul><h2 id="调试抽象语法树（AST）生成器"><a href="#调试抽象语法树（AST）生成器" class="headerlink" title="调试抽象语法树（AST）生成器"></a>调试抽象语法树（AST）生成器</h2><p>我们从 <code>PyParser_ParseFileObject()</code> 构建了语法树，下一步是生成 AST。</p><p>在此之前，需要介绍一些宏。这些宏定义于 <code>Include/node.h</code> 中，用于从节点结构中查询数据：</p><ul><li><code>CHILD(node *, int)</code>，返回第 n 个节点（从 0 开始）</li><li><code>RCHILD(node *, int)</code>，从右往左返回第 n 个节点，使用负数</li><li><code>NCH(node *)</code>，返回节点总数</li><li><code>STR(node *)</code>，返回节点的字符串表示，比如冒号 token，会返回 <code>:</code></li><li><code>TYPE(node *)</code>，返回节点的类型，类型定义于 <code>Include/graminit.h</code></li><li><code>REQ(node *, TYPE)</code>，判断节点类型是否是 <code>TYPE</code></li><li><code>LINENO(node *)</code>，获取解析规则源码所在的行数，规则定义在 <code>Python/ast.c</code></li></ul><p>在 <code>Python/ast.c</code> 中的 <code>PyAST_FromNodeObject()</code> 将语法树转换为 AST。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCH(n) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ch = CHILD(n, i);</span><br><span class="line">    <span class="keyword">if</span> (TYPE(ch) == NEWLINE)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    REQ(ch, stmt);</span><br><span class="line">    num = num_stmts(ch);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        s = ast_for_stmt(&amp;c, ch);</span><br><span class="line">        <span class="keyword">if</span> (!s)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        asdl_seq_SET(stmts, k++, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ch = CHILD(ch, <span class="number">0</span>);</span><br><span class="line">        REQ(ch, simple_stmt);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">            s = ast_for_stmt(&amp;c, CHILD(ch, j * <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (!s)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            asdl_seq_SET(stmts, k++, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res = Module(stmts, arena);</span><br></pre></td></tr></table></figure><p><code>ast_for_stmt()</code> 是 <code>ast_for_xx</code> 的装饰器，其中 <code>xx</code> 是对应函数处理的语法规则。</p><h2 id="调试符号表生成器"><a href="#调试符号表生成器" class="headerlink" title="调试符号表生成器"></a>调试符号表生成器</h2><p>回到 <code>Python/pythonrun.c</code> 中的 <code>PyRun_FileExFlags()</code>。它会接着将结果 <code>mod</code> 传入 <code>run_mod()</code> 函数中。它完成了重要的两步：第一，生成代码对象（<code>PyAST_CompileObject()</code>），第二，进入解析循环（<code>PyEval_EvalCode()</code>）。</p><p><code>PyAST_CompileObject()</code> 位于 <code>Python/compile.c</code>。它有两个重要的函数：</p><ol><li><code>PySumtable_BuildObject()</code></li><li><code>compiler_mod()</code></li></ol><p><code>Python/symtable.c</code> 中的 <code>PySumtable_BuildObject()</code> 用于生成符号表。</p><p>符号表的结构定义在 <code>Include/symtble.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtable</span> &#123;</span></span><br><span class="line">    PyObject *st_filename;          <span class="comment">/* name of file being compiled,</span></span><br><span class="line"><span class="comment">                                       decoded from the filesystem encoding */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> *<span class="title">st_cur</span>;</span> <span class="comment">/* current symbol table entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> *<span class="title">st_top</span>;</span> <span class="comment">/* symbol table entry for module */</span></span><br><span class="line">    PyObject *st_blocks;            <span class="comment">/* dict: map AST node addresses</span></span><br><span class="line"><span class="comment">                                     *       to symbol table entries */</span></span><br><span class="line">    PyObject *st_stack;             <span class="comment">/* list: stack of namespace info */</span></span><br><span class="line">    PyObject *st_global;            <span class="comment">/* borrowed ref to st_top-&gt;ste_symbols */</span></span><br><span class="line">    <span class="keyword">int</span> st_nblocks;                 <span class="comment">/* number of blocks used. kept for</span></span><br><span class="line"><span class="comment">                                       consistency with the corresponding</span></span><br><span class="line"><span class="comment">                                       compiler structure */</span></span><br><span class="line">    PyObject *st_private;           <span class="comment">/* name of current class or NULL */</span></span><br><span class="line">    PyFutureFeatures *st_future;    <span class="comment">/* module's future features that affect</span></span><br><span class="line"><span class="comment">                                       the symbol table */</span></span><br><span class="line">    <span class="keyword">int</span> recursion_depth;            <span class="comment">/* current recursion depth */</span></span><br><span class="line">    <span class="keyword">int</span> recursion_limit;            <span class="comment">/* recursion limit */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *ste_id;        <span class="comment">/* int: key in ste_table-&gt;st_blocks */</span></span><br><span class="line">    PyObject *ste_symbols;   <span class="comment">/* dict: variable names to flags */</span></span><br><span class="line">    PyObject *ste_name;      <span class="comment">/* string: name of current block */</span></span><br><span class="line">    PyObject *ste_varnames;  <span class="comment">/* list of function parameters */</span></span><br><span class="line">    PyObject *ste_children;  <span class="comment">/* list of child blocks */</span></span><br><span class="line">    PyObject *ste_directives;<span class="comment">/* locations of global and nonlocal statements */</span></span><br><span class="line">    _Py_block_ty ste_type;   <span class="comment">/* module, class, or function */</span></span><br><span class="line">    <span class="keyword">int</span> ste_nested;      <span class="comment">/* true if block is nested */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_free : <span class="number">1</span>;        <span class="comment">/* true if block has free variables */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_child_free : <span class="number">1</span>;  <span class="comment">/* true if a child block has free vars,</span></span><br><span class="line"><span class="comment">                                     including free refs to globals */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_generator : <span class="number">1</span>;   <span class="comment">/* true if namespace is a generator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_coroutine : <span class="number">1</span>;   <span class="comment">/* true if namespace is a coroutine */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_varargs : <span class="number">1</span>;     <span class="comment">/* true if block has varargs */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_varkeywords : <span class="number">1</span>; <span class="comment">/* true if block has varkeywords */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_returns_value : <span class="number">1</span>;  <span class="comment">/* true if namespace uses return with</span></span><br><span class="line"><span class="comment">                                        an argument */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_needs_class_closure : <span class="number">1</span>; <span class="comment">/* for class scopes, true if a</span></span><br><span class="line"><span class="comment">                                            closure over __class__</span></span><br><span class="line"><span class="comment">                                             should be created */</span></span><br><span class="line">    <span class="keyword">int</span> ste_lineno;          <span class="comment">/* first line of block */</span></span><br><span class="line">    <span class="keyword">int</span> ste_col_offset;      <span class="comment">/* offset of first line of block */</span></span><br><span class="line">    <span class="keyword">int</span> ste_opt_lineno;      <span class="comment">/* lineno of last exec or import * */</span></span><br><span class="line">    <span class="keyword">int</span> ste_opt_col_offset;  <span class="comment">/* offset of last exec or import * */</span></span><br><span class="line">    <span class="keyword">int</span> ste_tmpname;         <span class="comment">/* counter for listcomp temp vars */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">symtable</span> *<span class="title">ste_table</span>;</span></span><br><span class="line">&#125; PySTEntryObject;</span><br></pre></td></tr></table></figure><p>可以看出，符号表其实是一个字典结构，每一项是一个符号对应关系。</p><p>在第 281 行的 for 循环打上断点（<code>for (i = 0; i &lt; asdl_seq_LEN(seq); i++)</code>），会来到 <code>symtable_visit_stmt()</code> 函数，该函数生成符号表的每一项。接着打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b symtable_visit_stmt</span><br></pre></td></tr></table></figure><p>就能观察到类似 <code>xx_kind</code> 的表达式，例如 <code>Name_kind</code> 会调用 <code>symtable_add_def()</code> 将一个符号定义加入到符号表中。</p><h2 id="调试编译器和字节码生成器"><a href="#调试编译器和字节码生成器" class="headerlink" title="调试编译器和字节码生成器"></a>调试编译器和字节码生成器</h2><p>回到函数 <code>PyAST_CompileObject()</code> 中，下一步是 <code>compiler_mod()</code>，将抽象语法树转换为上下文无关语法。</p><p>在此处打断点（<code>b compiler_mod</code>）。swtich 分支会把我们带进 <code>Module_kind</code>，里面会调用 <code>compiler_body()</code> 函数，接着单步调试，就会发现一个 for 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &lt; asdl_seq_LEN(stmts); i++)</span><br><span class="line">    VISIT(c, stmt, (stmt)ty)asdl_seq_GET(stmts, i));</span><br></pre></td></tr></table></figure><p>这里，我们在抽象语义描述语言（ASDL）中遍历，调用宏 <code>VISIT</code>，接着调用 <code>compiler_visit_expr(c, nodeZ)</code>。</p><p>以下宏会产生字节码：</p><ul><li><code>ADDOP()</code>，增加一个指定的字节码</li><li><code>ADDOP_I()</code>，增加的字节码是带参数的</li><li><code>ADDOP_O(struct compiler *c, int op, PyObject * type, PyObject *obj)</code>，根据指定 <code>PyObject</code> 在序列中的位置，增加一个字节码，但是不考虑 name mangling。常用于全局、常量或参数的变量名寻找，因为这种变量名的作用域是未知的。</li><li><code>ADDOP_NAME()</code>，和 <code>ADDOP_O</code> 类似，但是会考虑 name mangling。用于属性加载和导入。</li><li><code>ADDOP_JABS()</code>，创建一个绝对跳转</li><li><code>ADDOP_JREL()</code>，创建一个相对跳转</li></ul><p>为了验证是否生成了正确的字节码，可以在 <code>test.py</code> 上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python -m dis test.py</span><br><span class="line">  1           0 LOAD_CONST               0 (100)</span><br><span class="line">              2 STORE_NAME               0 (a)</span><br><span class="line">              4 LOAD_CONST               1 (None)</span><br><span class="line">              6 RETURN_VALUE</span><br></pre></td></tr></table></figure><h2 id="调试解析器循环"><a href="#调试解析器循环" class="headerlink" title="调试解析器循环"></a>调试解析器循环</h2><p>一旦字节码生成，下一步是由解析器运行程序。回到 <code>Python/pythonrun.c</code> 文件中，我们接着会调用函数 <code>PyEval_EvalCode()</code>，这是对 <code>PyEval_EvalCodeEx()/_PyEval_EvalCodeWithName()</code> 的装饰器函数。</p><blockquote><p>和 Python2.7 不一样，<code>PyEval_EvalCodeEx</code> 不会建立函数栈，这一步被移入 <code>_PyEval_EvalCodeWithName</code>。</p></blockquote><p>栈对象的结构定义于 <code>Include/frameobject.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* previous frame, or NULL */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* code segment */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* points after the last local */</span></span><br><span class="line">    <span class="comment">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span></span><br><span class="line"><span class="comment">       Frame evaluation usually NULLs it, but a frame that yields sets it</span></span><br><span class="line"><span class="comment">       to the current stack top. */</span></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* Trace function */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In a generator, we need to be able to swap between the exception</span></span><br><span class="line"><span class="comment">       state inside the generator and the exception state of the calling</span></span><br><span class="line"><span class="comment">       frame (which shouldn't be impacted when the generator "yields"</span></span><br><span class="line"><span class="comment">       from an except handler).</span></span><br><span class="line"><span class="comment">       These three fields exist exactly for that, and are unused for</span></span><br><span class="line"><span class="comment">       non-generator frames. See the save_exc_state and swap_exc_state</span></span><br><span class="line"><span class="comment">       functions in ceval.c for details of their use. */</span></span><br><span class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</span><br><span class="line">    <span class="comment">/* Borrowed reference to a generator, or NULL */</span></span><br><span class="line">    PyObject *f_gen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f_lasti;                <span class="comment">/* Last instruction if called */</span></span><br><span class="line">    <span class="comment">/* Call PyFrame_GetLineNumber() instead of reading this field</span></span><br><span class="line"><span class="comment">       directly.  As of 2.3 f_lineno is only valid when tracing is</span></span><br><span class="line"><span class="comment">       active (i.e. when f_trace is set).  At other times we use</span></span><br><span class="line"><span class="comment">       PyCode_Addr2Line to calculate the line from the current</span></span><br><span class="line"><span class="comment">       bytecode index. */</span></span><br><span class="line">    <span class="keyword">int</span> f_lineno;               <span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="keyword">int</span> f_iblock;               <span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    <span class="keyword">char</span> f_executing;           <span class="comment">/* whether the frame is still executing */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* locals+stack, dynamically sized */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure><p>在 <code>_PyEval_EvalCodeWithName()</code> 中，会用 <code>_PyFrame_New_NoTrack()</code> 创建一个栈对象，这个栈是对 C 程序函数栈的模拟，在最后，会调用 <code>PyEval_EvalFrameEx()</code>。</p><p><code>PyEval_EvalFrameEx()</code> 然后会在 <code>PyThreadState</code> 上调用 <code>eval_frame()/_PyEval_EvalFrameDefault()</code> 函数。这个函数也会被 Python 虚拟机调用。</p><p>跟踪进入 <code>_PyEval_EvalFrameDefault()</code>，我们可以观察到第 1054 行有一个无限循环，在不断产生字节码。</p><h2 id="调试-Python-对象"><a href="#调试-Python-对象" class="headerlink" title="调试 Python 对象"></a>调试 Python 对象</h2><p><code>PyObject</code> 是通用 Python 对象，定义于 <code>Include/object.h</code> 中。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每一种 <code>PyObject</code> 都有着相似的跟踪步骤：</p><ul><li>用 gdb 打开 python</li><li>在对象创建函数上打断点</li><li>用交互式命令环境，创建我们想要的对象</li><li>在断点处，开始一步步跟踪代码</li></ul><p>例如，我们想单步调试 <code>PyBoolObject</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) b bool_newbb</span><br><span class="line">Breakpoint 1 at 0x44812f: file Objects/boolobject.c, line 44.</span><br><span class="line">(gdb) r</span><br><span class="line">[GCC 6.3.1 20170109] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; a = bool(1)</span><br><span class="line"></span><br><span class="line">Breakpoint 1, bool_new (type=0x87a700 &lt;PyBool_Type&gt;, args=(1,), kwds=0x0) at Objects/boolobject.c:44</span><br><span class="line">44&#123;</span><br></pre></td></tr></table></figure><h3 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h3><p>通用 Python 对象定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObjecdt;</span><br></pre></td></tr></table></figure><p>在预处理器展开宏 <code>_PyObject_HEAD_EXTRA</code> 后，它会变成一个双向列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObjecdt;</span><br></pre></td></tr></table></figure><p>该对象包含两个重要元素：引用计数和类型对象。</p><h3 id="PyVarObject"><a href="#PyVarObject" class="headerlink" title="PyVarObject"></a>PyVarObject</h3><p>Python 也有变长对象，定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>几乎和 <code>PyObject</code> 一样，但多了一项用于表示对象的长度信息。</p><h3 id="PyTypeObject"><a href="#PyTypeObject" class="headerlink" title="PyTypeObject"></a>PyTypeObject</h3><p><code>PyTypeObject</code> 是 Python 对象的类型表示。在 Python 中可以如下表达式获取任何对象的类型信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = type(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(t)</span><br><span class="line">[<span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__bool__'</span>, <span class="string">'__ceil__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__divmod__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__float__'</span>, <span class="string">'__floor__'</span>, <span class="string">'__floordiv__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__index__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__int__'</span>, <span class="string">'__invert__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lshift__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__neg__'</span>, <span class="string">'__new__'</span>, <span class="string">'__or__'</span>, <span class="string">'__pos__'</span>, <span class="string">'__pow__'</span>, <span class="string">'__radd__'</span>, <span class="string">'__rand__'</span>, <span class="string">'__rdivmod__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rfloordiv__'</span>, <span class="string">'__rlshift__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__ror__'</span>, <span class="string">'__round__'</span>, <span class="string">'__rpow__'</span>, <span class="string">'__rrshift__'</span>, <span class="string">'__rshift__'</span>, <span class="string">'__rsub__'</span>, <span class="string">'__rtruediv__'</span>, <span class="string">'__rxor__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__sub__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__truediv__'</span>, <span class="string">'__trunc__'</span>, <span class="string">'__xor__'</span>, <span class="string">'bit_length'</span>, <span class="string">'conjugate'</span>, <span class="string">'denominator'</span>, <span class="string">'from_bytes'</span>, <span class="string">'imag'</span>, <span class="string">'numerator'</span>, <span class="string">'real'</span>, <span class="string">'to_bytes'</span>]</span><br></pre></td></tr></table></figure><p>这些方法都定义在 <code>PyTypeObject</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_LIMITED_API</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> <span class="title">PyTypeObject</span>;</span> <span class="comment">/* opaque */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.0 */</span></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.1 */</span></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="comment">/* these must be last and never explicitly initialized */</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>所有的整数对象现在都在 <code>Objects/longobject.c</code> 中实现，定义为 <code>PyLong_Type</code> 类型。<code>PyLong_Type</code> 就是一个 <code>PyTypeObject</code> 对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="PyLongObject"><a href="#PyLongObject" class="headerlink" title="PyLongObject"></a>PyLongObject</h3><p>定义于 <code>Include/longobject.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br></pre></td></tr></table></figure><h3 id="PyBoolObject"><a href="#PyBoolObject" class="headerlink" title="PyBoolObject"></a>PyBoolObject</h3><p><code>PyBoolObject</code> 在 Python 中存储布尔类型，定义于 <code>Include/boolobject.h</code> 中。</p><h3 id="PyFloatObject"><a href="#PyFloatObject" class="headerlink" title="PyFloatObject"></a>PyFloatObject</h3><p>在 <code>Include/floatobject.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure><h3 id="PyListObject"><a href="#PyListObject" class="headerlink" title="PyListObject"></a>PyListObject</h3><p>在 <code>Include/listobject.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item contains space for 'allocated' elements.  The number</span></span><br><span class="line"><span class="comment">     * currently in use is ob_size.</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *     0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *     len(list) == ob_size</span></span><br><span class="line"><span class="comment">     *     ob_item == NULL implies ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Items must normally not be NULL, except during construction when</span></span><br><span class="line"><span class="comment">     * the list is not yet visible outside the function that builds it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;建立环境&quot;&gt;&lt;a href=&quot;#建立环境&quot; class=&quot;headerlink&quot; title=&quot;建立环境&quot;&gt;&lt;/a&gt;建立环境&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从 GitHub 上下载源码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python3.x源码" scheme="http://www.lyyyuna.com/tags/Python3-x%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 字符串对象</title>
    <link href="http://www.lyyyuna.com/2017/12/28/python-internal3-string-object/"/>
    <id>http://www.lyyyuna.com/2017/12/28/python-internal3-string-object/</id>
    <published>2017-12-28T08:20:02.000Z</published>
    <updated>2017-12-29T01:34:37.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-的字符串类型和对象"><a href="#Python-的字符串类型和对象" class="headerlink" title="Python 的字符串类型和对象"></a>Python 的字符串类型和对象</h2><p>有了之前<a href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/">整数对象</a>的铺垫，研究字符串类型及其对象，当然是先看其对应的类型结构体和对象结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyTypeObject PyString_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"str"</span>,</span><br><span class="line">    PyStringObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">char</span>),</span><br><span class="line">    string_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    (printfunc)string_print,                    <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &amp;PyBaseString_Type,                         <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    string_new,                                 <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_shash;</span><br><span class="line">    <span class="keyword">int</span> ob_sstate;</span><br><span class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure><p><code>ob_shash</code> 是该字符串的哈希值，由于 Python 的字典实现大量使用了哈希值，且字典的健多为 <code>PyStringObject</code>，预先计算哈希值并保存下来，可以加速字典的运算。</p><p><code>ob_sstate</code> 和字符串对象的 intern 机制有关。</p><p><code>ob_sval</code> 为什么是长度为 1 的数组？这种定义方法其实符合 C99 标准。<a href="https://en.wikipedia.org/wiki/Flexible_array_member" target="_blank" rel="noopener">Flexible array member</a>规定，若要支持柔性数组，可在结构体末尾放置一个不指定长度的数组。而大多数编译器都支持长度为 1 的定义方法，所以就写成 1 了。如果你单独定义 <code>char buf[]</code>，那必然是会报错的。</p><h2 id="创建一个-PyStringObject"><a href="#创建一个-PyStringObject" class="headerlink" title="创建一个 PyStringObject"></a>创建一个 PyStringObject</h2><p>最底层的生成字符串的函数为 <code>PyString_FromString</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size = <span class="built_in">strlen</span>(str);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">    op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    (<span class="keyword">void</span>)PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">    op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</span><br><span class="line">    Py_MEMCPY(op-&gt;ob_sval, str, size+<span class="number">1</span>);  <span class="comment">// 将原始C字串的值搬运过来</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是根据原始的 C 语言字符串生成对应的 <code>PyStringObject</code>。原始字符串被复制到 <code>ob_sval</code> 中。</p><h2 id="intern-机制"><a href="#intern-机制" class="headerlink" title="intern 机制"></a>intern 机制</h2><p>和整数对象一样，<code>PyStringObject</code> 需要优化才堪实用，于是 Python 的设计者便开发了 intern 机制。</p><p>所谓 intern，即如果两个字符串对象的原始字符串相同，那么其 <code>ob_sval</code> 共享同一份内存。若程序中出现了 100 次 <code>hello, world</code>，那么在内存中只会保存一份。</p><p>intern 机制的核心在于字典 <code>interned</code>。该字典为 Python 的内建数据结构，可以简单等价于 C++ 的 <code>map&lt;T,R&gt;</code>。该字典的健值都为字符串本身 <code>pystring:pystring</code>，所有需 intern 的字符串会缓存到该 <code>interned</code> 字典中，当在程序中再遇到相同的字符串 <code>pystring</code>，便可通过字典在 <code>O(1)</code> 时间内检索出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* share short strings */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *t = (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op = (PyStringObject *)t;</span><br><span class="line">        nullstring = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        PyObject *t = (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op = (PyStringObject *)t;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>PyString_FromString</code> 函数最后，会强制将长度为 0 和 1 的字符串 intern，而这一操作的核心为 <code>PyString_InterInPlace</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PyString_InternInPlace(PyObject **p)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interned = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Clear(); <span class="comment">/* Don't leave an exception */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t = PyDict_GetItem(interned, (PyObject *)s);</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        Py_INCREF(t);</span><br><span class="line">        Py_SETREF(*p, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_REFCNT(s) -= <span class="number">2</span>;</span><br><span class="line">    PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_SETREF(op, op2)                      \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                        \</span><br><span class="line">        PyObject *_py_tmp = (PyObject *)(op);   \</span><br><span class="line">        (op) = (op2);                           \</span><br><span class="line">        Py_DECREF(_py_tmp);                     \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>函数的开始会尝试新建 <code>interned</code> 字典。然后是尝试在 <code>interned</code> 字典中找该字符串 <code>PyDict_GetItem</code>。</p><ul><li>若找到，就需要增加该健值对上的引用计数，并减去 <code>PyStringObject</code> 对象的引用计数。<code>PyStringObject</code> 对象减为 0 后会被回收内存。为啥原对象要被回收？因为后续程序只会通过 <code>interned</code> 字典引用字符串，原对象留着没啥用处了。</li><li>若没找到，会尝试在字典中新建健值对 <code>PyDict_SetItem</code>。新建的健值对需要减去 2 个引用计数。我们的 <code>interned</code> 字典健值都是原字符串，该 <code>PyStringObject</code> 无论如何都至少会有两个引用。健值仅仅是作为 Python 虚拟机内部使用，不应影响所运行程序的内存回收，故需减 2。</li></ul><h2 id="单字符字符串的进一步优化"><a href="#单字符字符串的进一步优化" class="headerlink" title="单字符字符串的进一步优化"></a>单字符字符串的进一步优化</h2><p>在 <code>PyString_FromString</code> 函数中，还看到了 <code>characters</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">    PyObject *t = (PyObject *)op;</span><br><span class="line">    PyString_InternInPlace(&amp;t);</span><br><span class="line">    op = (PyStringObject *)t;</span><br><span class="line">    characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单字节的字符串被缓存到了 <code>characters</code> 数组中。在创建字符串函数时，直接从数组中取出单字节字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        one_strings++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>数组比哈希字典效率更高。</p><h2 id="字符串拼接所做的优化"><a href="#字符串拼接所做的优化" class="headerlink" title="字符串拼接所做的优化"></a>字符串拼接所做的优化</h2><p>字符串虽然是变长对象，但并不是可变对象，创建之后，<code>ob_sval</code> 数组的长度无法再改变。在拼接两个字符串 s1, s2 时，必须重新生成一个 <code>PyStringObject</code> 对象来放置 <code>s1-&gt;ob_sval + s2-&gt;sval</code>。如果要连接 N 个 <code>PyStringObject</code> 对象，那么就必须进行 N-1 次的内存申请及内存搬运的工作。毫无疑问，这将严重影响 Python 的执行效率。</p><p>所以官方推荐的做法是使用 <code>join</code> 函数，该函数一次性分配好所有内存，然后统一搬运。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"-"</span></span><br><span class="line">seq = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">print</span> s.join( seq )</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>何种字符串会 intern？不同的 Python 版本似乎采取了不同的策略，以我 Mac 上 Python 2.7.10 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'foo'</span> <span class="keyword">is</span> <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'foo!'</span> <span class="keyword">is</span> <span class="string">'foo!'</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>*<span class="number">20</span> <span class="keyword">is</span> <span class="string">'a'</span>*<span class="number">20</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>*<span class="number">21</span> <span class="keyword">is</span> <span class="string">'a'</span>*<span class="number">21</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-的字符串类型和对象&quot;&gt;&lt;a href=&quot;#Python-的字符串类型和对象&quot; class=&quot;headerlink&quot; title=&quot;Python 的字符串类型和对象&quot;&gt;&lt;/a&gt;Python 的字符串类型和对象&lt;/h2&gt;&lt;p&gt;有了之前&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 整数对象</title>
    <link href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/"/>
    <id>http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/</id>
    <published>2017-12-24T08:20:02.000Z</published>
    <updated>2017-12-24T13:23:21.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-的面向对象"><a href="#Python-的面向对象" class="headerlink" title="Python 的面向对象"></a>Python 的面向对象</h2><p>面向对象编程中，对象是数据以及基于这些数据的操作的集合，实际上在计算机中这只是一堆内存逻辑上的集合，无论这段内存是连续的还是分开的。</p><p>Python 是由 C 语言写成，描述一段逻辑上结合的内存，直接用结构体 <code>struct</code> 就可以了。但是 <code>struct</code> 并不是面向对象中类型的概念，对象还需要成员函数。所以还需要另外一个结构体 <code>struct</code> 来描述成员函数的集合。</p><p>上述特点就导致了在 Python 中，实际的类型也是一个对象，这个类型对象的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    cmpfunc tp_compare;</span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="keyword">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.0 */</span></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.1 */</span></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Added in release 2.2 */</span></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="comment">/* these must be last and never explicitly initialized */</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><p>所以在源码中，Python 最基础的对象表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>每一个对象都有一个指针指向自己所属的类型对象，而类型对象则有关于这个对象支持的所有操作的信息。</p><p>仔细看 <code>PyTypeObject</code> 的头部，<code>PyObject_VAR_HEAD</code> 即含有 <code>ob_type</code>，难道还有类型的类型这个概念？是的，这个终极的类型就是元类，即 <code>metaclass</code>。做个简单的实验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br></pre></td></tr></table></figure><p>在 Python 中类型是对象，所以类型对象也有类型，而元类的类型就是自己。</p><h2 id="Python-的整数类型"><a href="#Python-的整数类型" class="headerlink" title="Python 的整数类型"></a>Python 的整数类型</h2><p>整数类型没啥可说的，按照 <code>PyTypeObject</code> 结构去填充信息即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyInt_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyIntObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)int_dealloc,                    <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    (printfunc)int_print,                       <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    (cmpfunc)int_compare,                       <span class="comment">/* tp_compare */</span></span><br><span class="line">    (reprfunc)int_to_decimal_string,            <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;int_as_number,                             <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)int_hash,                         <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)int_to_decimal_string,            <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          <span class="comment">/* tp_flags */</span></span><br><span class="line">    int_doc,                                    <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    int_methods,                                <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    int_getset,                                 <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    int_new,                                    <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="整数对象的内存"><a href="#整数对象的内存" class="headerlink" title="整数对象的内存"></a>整数对象的内存</h2><p>再看一眼 PyObject 对象，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>我们看到了 <code>ob_refcnt</code> 引用计数对象，可以很容易地联想到 Python 虚拟机是以引用计数为基础构建垃圾回收机制。既然如此，那还有没有必要专门讨论整数对象的内存使用,而直接抽象成引用计数归零后释放内存？</p><p>事实上，为了提高虚拟机的性能，整数对象使用了多种技术。</p><h3 id="大整数创建"><a href="#大整数创建" class="headerlink" title="大整数创建"></a>大整数创建</h3><p>在 intobject.c 中定义有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span></span><br><span class="line">    PyIntObject objects[N_INTOBJECTS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><code>block_list</code> 是由一个个 <code>PyIntBlock</code> 串起来的链表，每一个 <code>PyIntBlock</code> 是一个整数数组。<code>free_list</code> 是由空闲的 <code>PyIntObject</code> 组成的链表，空闲是指这块内存虽然被划分为一个 <code>PyIntObject</code>，但并没有被用于表示一个真正的整数，即其所存储的信息是无用的。</p><p>整数创建时，<code>PyObject * PyInt_FromLong(long ival)</code> 会被调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyInt_FromLong(<span class="keyword">long</span> ival)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> PyIntObject *v;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (free_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((free_list = fill_free_list()) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Inline PyObject_New */</span></span><br><span class="line">    v = free_list;</span><br><span class="line">    free_list = (PyIntObject *)Py_TYPE(v);</span><br><span class="line">    (<span class="keyword">void</span>)PyObject_INIT(v, &amp;PyInt_Type);</span><br><span class="line">    v-&gt;ob_ival = ival;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntObject *</span><br><span class="line">fill_free_list(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyIntObject *p, *q;</span><br><span class="line">    <span class="comment">/* Python's object allocator isn't appropriate for large blocks. */</span></span><br><span class="line">    p = (PyIntObject *) PyMem_MALLOC(<span class="keyword">sizeof</span>(PyIntBlock));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyIntObject *) PyErr_NoMemory();</span><br><span class="line">    ((PyIntBlock *)p)-&gt;next = block_list;</span><br><span class="line">    block_list = (PyIntBlock *)p;</span><br><span class="line">    <span class="comment">/* Link the int objects together, from rear to front, then return</span></span><br><span class="line"><span class="comment">       the address of the last int object in the block. */</span></span><br><span class="line">    p = &amp;((PyIntBlock *)p)-&gt;objects[<span class="number">0</span>];</span><br><span class="line">    q = p + N_INTOBJECTS;</span><br><span class="line">    <span class="keyword">while</span> (--q &gt; p)</span><br><span class="line">        Py_TYPE(q) = (struct _typeobject *)(q<span class="number">-1</span>);</span><br><span class="line">    Py_TYPE(q) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p + N_INTOBJECTS - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建整数的时候，会先尝试从 <code>free_list</code> 中取，如果没有空闲的，就会尝试 <code>fill_free_list</code>。这个新的 <code>PyIntBlock</code> 中，每一个 <code>PyIntObject</code> 都借用 <code>ob_type</code> 来连接成链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_TYPE(ob) (((PyObject*)(ob))-&gt;ob_type)</span></span><br></pre></td></tr></table></figure><p>这里只是借用，初看源码的朋友不要被这里搞混了。因为此时这块内存并没有存放整数，它的成员自然可以借来他用。<code>free_list</code> 指向数组的末尾，从后往前链接到数组首部。</p><h3 id="大整数销毁"><a href="#大整数销毁" class="headerlink" title="大整数销毁"></a>大整数销毁</h3><p>当一个整数销毁时，便会进入 <code>int_dealloc</code> 函数内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">int_dealloc(PyIntObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyInt_CheckExact(v)) &#123;</span><br><span class="line">        Py_TYPE(v) = (struct _typeobject *)free_list;</span><br><span class="line">        free_list = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(v)-&gt;tp_free((PyObject *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在正常情况下不会走到 <code>else</code> 分支，意味着所谓的销毁，只是把这个整数的 <code>PyIntObject</code> 重新放回 <code>free_list</code> 链表中，并不会释放这块内存。这岂不会造成内存泄漏？只能说，理论上会。整数对象所占用的内存空间，只和这个程序同时拥有的最多的整数数量有关。</p><p>上述做法也是为了优化性能，虚拟机不再需要频繁的 <code>malloc</code> 和 <code>free</code>。</p><h3 id="小整数"><a href="#小整数" class="headerlink" title="小整数"></a>小整数</h3><p>除了普通的整数外，Python 中还存在着一种小整数对象。在之前的 <code>PyInt_FromLong</code> 函数中，我们略了一部分，现在我们从另一个角度看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyInt_FromLong(<span class="keyword">long</span> ival)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> PyIntObject *v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123;</span><br><span class="line">        v = small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当想创建的整数在 <code>-NSMALLNEGINTS ~ NSMALLPOSINTS</code> 之间时，就会从 <code>small_ints</code> 数组中直接取出。这范围内的整数即为小整数。小整数使用广泛，循环的初始值，终结值，步进值等等，都是数值很小的整数。小整数从 Python 虚拟机运行之初就存在，使用它们既不需要 <code>malloc</code> 和 <code>free</code>，甚至连指针操作 <code>free_list</code> 也不要。效率比大整数更高。</p><p>而小整数的范围可在编译 Python 时指定，默认为 <code>-5 ~ 257</code>。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>改造一下整数打印函数，反映出内存的变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> values[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> refcounts[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/* ARGSUSED */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">int_print(PyIntObject *v, FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">     <span class="comment">/* flags -- not used but required by interface */</span></span><br><span class="line">&#123;</span><br><span class="line">    PyIntObject * intObjectPtr;</span><br><span class="line">    PyIntBlock * p = block_list;</span><br><span class="line">    PyIntBlock * last = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> int_val = v-&gt;ob_ival;</span><br><span class="line">    Py_BEGIN_ALLOW_THREADS</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%ld"</span>, int_val);</span><br><span class="line">    Py_END_ALLOW_THREADS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        last = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    intObjectPtr = last-&gt;objects;</span><br><span class="line">    intObjectPtr += N_INTOBJECTS<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nvalue's address is @%p\n"</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++, --intObjectPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        values[i] = intObjectPtr-&gt;ob_ival;</span><br><span class="line">        refcounts[i] = intObjectPtr-&gt;ob_refcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  value : "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  refcnt : "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, refcounts[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" block_list count : %d\n"</span>, count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" free_list address : %p\n"</span>, free_list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行重新编译后的 python 虚拟机。</p><h3 id="大整数实验"><a href="#大整数实验" class="headerlink" title="大整数实验"></a>大整数实验</h3><p>首先是连续创建两个大整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1111</span></span><br><span class="line">value<span class="string">'s address is @0x100303888</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     587     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038a0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b=2222</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b</span></span><br><span class="line"><span class="string">2222</span></span><br><span class="line"><span class="string">value'</span>s address <span class="keyword">is</span> @<span class="number">0x1003038a0</span></span><br><span class="line">  value : <span class="number">-5</span>    <span class="number">-4</span>      <span class="number">-3</span>      <span class="number">-2</span>      <span class="number">-1</span>      <span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">  refcnt : <span class="number">1</span>    <span class="number">1</span>       <span class="number">1</span>       <span class="number">1</span>       <span class="number">54</span>      <span class="number">389</span>     <span class="number">587</span>     <span class="number">84</span></span><br><span class="line"> block_list count : <span class="number">9</span></span><br><span class="line"> free_list address : <span class="number">0x1003038b8</span></span><br></pre></td></tr></table></figure><p>第一次的 <code>free_list</code>，正好是第二次整数的地址。可以看到小整数都至少有一个引用，有些多于一次是因为 python 虚拟机内部使用的缘故。</p><p>当尝试创建一个相同的大整数时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="number">2222</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">2222</span></span><br><span class="line">value<span class="string">'s address is @0x1003038b8</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     587     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038d0</span></span><br></pre></td></tr></table></figure><p>可以看出，虽然值相同，但并不是同一个内存块。</p><h3 id="小整数实验"><a href="#小整数实验" class="headerlink" title="小整数实验"></a>小整数实验</h3><p>创建两个相同的小整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">1</span></span><br><span class="line">value<span class="string">'s address is @0x100604ce8</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     591     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038d0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; c=1</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; c</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">value'</span>s address <span class="keyword">is</span> @<span class="number">0x100604ce8</span></span><br><span class="line">  value : <span class="number">-5</span>    <span class="number">-4</span>      <span class="number">-3</span>      <span class="number">-2</span>      <span class="number">-1</span>      <span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">  refcnt : <span class="number">1</span>    <span class="number">1</span>       <span class="number">1</span>       <span class="number">1</span>       <span class="number">54</span>      <span class="number">389</span>     <span class="number">592</span>     <span class="number">84</span></span><br><span class="line"> block_list count : <span class="number">9</span></span><br><span class="line"> free_list address : <span class="number">0x100303828</span></span><br></pre></td></tr></table></figure><p>可以看出，整数 1 只是增加了引用计数，内存块是同一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-的面向对象&quot;&gt;&lt;a href=&quot;#Python-的面向对象&quot; class=&quot;headerlink&quot; title=&quot;Python 的面向对象&quot;&gt;&lt;/a&gt;Python 的面向对象&lt;/h2&gt;&lt;p&gt;面向对象编程中，对象是数据以及基于这些数据的操作的集合，实际
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 开始</title>
    <link href="http://www.lyyyuna.com/2017/12/19/python-internal1-begin/"/>
    <id>http://www.lyyyuna.com/2017/12/19/python-internal1-begin/</id>
    <published>2017-12-19T08:20:02.000Z</published>
    <updated>2017-12-19T09:03:27.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p>Python 官网可以下载到<a href="https://www.python.org/downloads/source/" target="_blank" rel="noopener">源码</a>。</p><p>Linux 上编译需要先安装额外模块，例如 Ubuntu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get build-dep python</span><br><span class="line">sudo apt-get install libreadline-dev libsqlite3-dev libbz2-dev libssl-dev libreadline6-dev libsqlite3-dev liblzma-dev libbz2-dev tk8.5-dev blt-dev libgdbm-dev libssl-dev libncurses5-dev zlib1g-dev libncurses5-dev</span><br></pre></td></tr></table></figure><p>Windows 上只需打开 PC/VS9.0/pcbuild.sln，选择最少的模块 python, pythoncore 编译，如果这两个模块编译时报错，只需按照错误提示，钩上所需模块即可。</p><p>Mac 上只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>本系列文章在 Mac 上完成，但环境本身只影响编译，并不影响分析过程，读者选择方便阅读源码的环境即可。</p><h2 id="第一个实验"><a href="#第一个实验" class="headerlink" title="第一个实验"></a>第一个实验</h2><p>Mac 上编译完会生成一个 <code>python.exe</code> 的可执行文件。</p><p>让我们尝试在 Python 源码中修改整数输出的部分，在每一个 int 打印时，输出 <code>hello, world</code>。</p><p>修改 /Objects/intobject.c，添加 <code>fprintf(fp, &quot;hello, world\n&quot;);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">int_print(PyIntObject *v, FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">     <span class="comment">/* flags -- not used but required by interface */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> int_val = v-&gt;ob_ival;</span><br><span class="line">    Py_BEGIN_ALLOW_THREADS</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%ld"</span>, int_val);</span><br><span class="line">    Py_END_ALLOW_THREADS</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是实验结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">hello, world</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(1)</span><br><span class="line">hello, world</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(&apos;eee&apos;)</span><br><span class="line">eee</span><br></pre></td></tr></table></figure><p>改动只影响了整数打印的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码编译&quot;&gt;&lt;a href=&quot;#源码编译&quot; class=&quot;headerlink&quot; title=&quot;源码编译&quot;&gt;&lt;/a&gt;源码编译&lt;/h2&gt;&lt;p&gt;Python 官网可以下载到&lt;a href=&quot;https://www.python.org/downloads/source
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的 descriptor</title>
    <link href="http://www.lyyyuna.com/2017/09/14/python-descriptor/"/>
    <id>http://www.lyyyuna.com/2017/09/14/python-descriptor/</id>
    <published>2017-09-14T08:20:02.000Z</published>
    <updated>2017-11-29T00:19:00.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>通常，一个 descriptor 是具有“绑定行为”的对象属性。所绑定行为可通过 descriptor 协议被自定义的 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 方法重写。如果一个对象的上述三个方法任意一个被重写，则就可被称为 descriptor。</p><p>属性的默认操作是从对象字典中获取、设置和删除一个属性。例如，a.x 有一个查找链，先 <code>a.__dict__[&#39;x&#39;]</code>，若没有则 <code>type(a).__dict__[&#39;x&#39;]</code>，若没有增往上查找父类直到元类。如果查找链中，对象被定义了 descriptor 方法，Python 就会覆盖默认行为。</p><p>Descriptor 是一个强大的工具，虽然开发者不常接触到它，但它其实就是类、属性、函数、方法、静态方法、类方法以及 <code>super()</code> 背后的运行机制。</p><h2 id="Descriptor-协议"><a href="#Descriptor-协议" class="headerlink" title="Descriptor 协议"></a>Descriptor 协议</h2><p>三个方法原型如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">descr.__get__(self, obj, type=None) --&gt; value</span><br><span class="line"></span><br><span class="line">descr.__set__(self, obj, value) --&gt; None</span><br><span class="line"></span><br><span class="line">descr.__delete__(self, obj) --&gt; None</span><br></pre></td></tr></table></figure><p>数据 descriptor 是同时具有 <code>__get__()</code> 和 <code>__set__()</code> 方法的对象，若只有 <code>__get__()</code> 方法，则为非数据 descriptor。如果实例字典中有和数据 descriptor 同名的入口，则数据 descriptor 优先级更高。相反，非数据 descriptor 优先级低。</p><p>让 <code>__set__()</code> 方法抛出异常，就能创建一个只读数据 descriptor。</p><h2 id="调用-descriptor"><a href="#调用-descriptor" class="headerlink" title="调用 descriptor"></a>调用 descriptor</h2><p>descriptor 可以直接通过方法名调用。例如，<code>d.__get__(obj)</code>。</p><p>而通过访问对象属性，自动调用 descriptor 才是更通用的做法。例如，如果 <code>d</code> 定义了方法 <code>__get__()</code>，则 <code>obj.d</code> 会调用 <code>d.__get__(obj)</code>。</p><p>对于对象，<code>b.x</code> 会被转换成 <code>type(b).__dict__[&#39;x&#39;].__get__(b, type(b))</code>。而对于类（是的，类也可以调用），<code>B.x</code> 会被转换成 <code>B.__dict__[&#39;x&#39;].__get__(None, B)</code>。</p><h2 id="Descriptor-例子"><a href="#Descriptor-例子" class="headerlink" title="Descriptor 例子"></a>Descriptor 例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RevealAccess</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""A data descriptor that sets and returns values</span></span><br><span class="line"><span class="string">       normally and prints a message logging their access.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initval=None, name=<span class="string">'var'</span>)</span>:</span></span><br><span class="line">        self.val = initval</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype)</span>:</span></span><br><span class="line">        print(<span class="string">'Retrieving'</span>, self.name)</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, val)</span>:</span></span><br><span class="line">        print(<span class="string">'Updating'</span>, self.name)</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    x = RevealAccess(<span class="number">10</span>, <span class="string">'var "x"'</span>)</span><br><span class="line"><span class="meta">... </span>    y = <span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x = <span class="number">20</span></span><br><span class="line">Updating var <span class="string">"x"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.y</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;通常，一个 descriptor 是具有“绑定行为”的对象属性。所绑定行为可通过 descriptor 协议被自定义的 &lt;code&gt;__ge
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Writing Your Own Windows Debugger - Debug Event</title>
    <link href="http://www.lyyyuna.com/2017/05/01/write-a-windows-debugger-02-debug-event/"/>
    <id>http://www.lyyyuna.com/2017/05/01/write-a-windows-debugger-02-debug-event/</id>
    <published>2017-05-01T13:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<p>We have introduced the debug loop last time, in this post, I will talk about various debug events.</p><h3 id="RIP-EVENT"><a href="#RIP-EVENT" class="headerlink" title="RIP_EVENT"></a>RIP_EVENT</h3><p>I find very few documents about this event, only mentioned with words like <em>system error</em> or <em>internal error</em>. So I decide to print a error message and skip it. As my project is not fully tested, I have never<br>encountered such a situation.</p><h3 id="OUTPUT-DEBUG-STRING-EVENT"><a href="#OUTPUT-DEBUG-STRING-EVENT" class="headerlink" title="OUTPUT_DEBUG_STRING_EVENT"></a>OUTPUT_DEBUG_STRING_EVENT</h3><p>When the debuggee calls the <em>OutpuDebugString</em> function, it will raise this debug event. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OUTPUT_DEBUG_STRING_INFO</span> &#123;</span></span><br><span class="line">  LPSTR lpDebugStringData;</span><br><span class="line">  WORD  fUnicode;</span><br><span class="line">  WORD  nDebugStringLength;</span><br><span class="line">&#125; OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;</span><br></pre></td></tr></table></figure><ul><li>lpDebugStringData, The debugging string in the calling process’s address space.</li><li>fUnicode, The format of the debugging string. If this member is zero, the debugging string is ANSI; if it is nonzero, the string is Unicode.</li><li>nDebugStringLength, The size of the debugging string, in characters. The length includes the string’s terminating null character.</li></ul><p>With ReadProcessMemory function, the debugger can obtain the value of the string:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnOutputDebugString</span><span class="params">(<span class="keyword">const</span> OUTPUT_DEBUG_STRING_INFO* pInfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE* pBuffer = (BYTE*)<span class="built_in">malloc</span>(pInfo-&gt;nDebugStringLength);</span><br><span class="line"></span><br><span class="line">    SIZE_T bytesRead;</span><br><span class="line"></span><br><span class="line">    ReadProcessMemory(</span><br><span class="line">        g_hProcess,</span><br><span class="line">        pInfo-&gt;lpDebugStringData,</span><br><span class="line">        pBuffer, </span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        &amp;bytesRead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> requireLen = MultiByteToWideChar(</span><br><span class="line">        CP_ACP,</span><br><span class="line">        MB_PRECOMPOSED,</span><br><span class="line">        (LPCSTR)pBuffer,</span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    TCHAR* pWideStr = (TCHAR*)<span class="built_in">malloc</span>(requireLen * <span class="keyword">sizeof</span>(TCHAR));</span><br><span class="line"></span><br><span class="line">    MultiByteToWideChar(</span><br><span class="line">        CP_ACP,</span><br><span class="line">        MB_PRECOMPOSED,</span><br><span class="line">        (LPCSTR)pBuffer,</span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        pWideStr,</span><br><span class="line">        requireLen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; TEXT(<span class="string">"Debuggee debug string: "</span>) &lt;&lt; pWideStr &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pWideStr);</span><br><span class="line">    <span class="built_in">free</span>(pBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LOAD-DLL-DEBUG-EVENT"><a href="#LOAD-DLL-DEBUG-EVENT" class="headerlink" title="LOAD_DLL_DEBUG_EVENT"></a>LOAD_DLL_DEBUG_EVENT</h3><p>After the debuggee loads a dll, this debug event will be triggered. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LOAD_DLL_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  HANDLE hFile;</span><br><span class="line">  LPVOID lpBaseOfDll;</span><br><span class="line">  DWORD  dwDebugInfoFileOffset;</span><br><span class="line">  DWORD  nDebugInfoSize;</span><br><span class="line">  LPVOID lpImageName;</span><br><span class="line">  WORD   fUnicode;</span><br><span class="line">&#125; LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>You may want to use the member <em>lpImageName</em> to retrieve the dll file name, however, it doesn’t work. According the explaination on MSDN, this member is pointer to the file name of the associated <em>hFile</em>, it  may, in turn, either be NULL or point to the actual filename. Even it is not NULL, ReadProcessMemory may also return a NULL. As a result, this membor is not reliable.</p><p>It seems that there is no direct Windows API to get the filename from the file handle. Someone has tried <a href="http://blog.csdn.net/bodybo/archive/2006/08/28/1131346.aspx" target="_blank" rel="noopener">this way</a>.</p><h3 id="UNLOAD-DLL-DEBUG-EVENT"><a href="#UNLOAD-DLL-DEBUG-EVENT" class="headerlink" title="UNLOAD_DLL_DEBUG_EVENT"></a>UNLOAD_DLL_DEBUG_EVENT</h3><p>When a dll module is unloaded, this event will be triggered, nothing needs handled, just skip it.</p><h3 id="CREATE-PROCESS-DEBUG-EVENT"><a href="#CREATE-PROCESS-DEBUG-EVENT" class="headerlink" title="CREATE_PROCESS_DEBUG_EVENT"></a>CREATE_PROCESS_DEBUG_EVENT</h3><p>After the process is created, this is the first debug event. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CREATE_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  HANDLE                 hFile;</span><br><span class="line">  HANDLE                 hProcess;</span><br><span class="line">  HANDLE                 hThread;</span><br><span class="line">  LPVOID                 lpBaseOfImage;</span><br><span class="line">  DWORD                  dwDebugInfoFileOffset;</span><br><span class="line">  DWORD                  nDebugInfoSize;</span><br><span class="line">  LPVOID                 lpThreadLocalBase;</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress;</span><br><span class="line">  LPVOID                 lpImageName;</span><br><span class="line">  WORD                   fUnicode;</span><br><span class="line">&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>We can use this structure to get the symbols of the debuggee program.</p><h3 id="EXIT-PROCESS-DEBUG-EVENT"><a href="#EXIT-PROCESS-DEBUG-EVENT" class="headerlink" title="EXIT_PROCESS_DEBUG_EVENT"></a>EXIT_PROCESS_DEBUG_EVENT</h3><p>When debuggee process exits, this event will be triggered. The following structure describe the detail of the event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXIT_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  DWORD dwExitCode;</span><br><span class="line">&#125; EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>What we can do is to print the exit code.</p><h3 id="CREATE-THREAD-DEBUG-EVENT"><a href="#CREATE-THREAD-DEBUG-EVENT" class="headerlink" title="CREATE_THREAD_DEBUG_EVENT"></a>CREATE_THREAD_DEBUG_EVENT</h3><p>It is similar to the process create debug event.</p><h3 id="EXIT-THREAD-DEBUG-EVENT"><a href="#EXIT-THREAD-DEBUG-EVENT" class="headerlink" title="EXIT_THREAD_DEBUG_EVENT"></a>EXIT_THREAD_DEBUG_EVENT</h3><p>It is similar to the process exit debug event.</p><h3 id="EXCEPTION-DEBUG-EVENT"><a href="#EXCEPTION-DEBUG-EVENT" class="headerlink" title="EXCEPTION_DEBUG_EVENT"></a>EXCEPTION_DEBUG_EVENT</h3><p>It is the most important event of our debugger, I will cover it in the next post.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have introduced the debug loop last time, in this post, I will talk about various debug events.&lt;/p&gt;
&lt;h3 id=&quot;RIP-EVENT&quot;&gt;&lt;a href=&quot;#RIP-E
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Windows Debugger" scheme="http://www.lyyyuna.com/tags/Windows-Debugger/"/>
    
  </entry>
  
  <entry>
    <title>Writing Your Own Windows Debugger - Overview</title>
    <link href="http://www.lyyyuna.com/2017/04/27/write-a-windows-debugger-01-overview/"/>
    <id>http://www.lyyyuna.com/2017/04/27/write-a-windows-debugger-01-overview/</id>
    <published>2017-04-27T09:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Debuggers are the apple of the hacker’s eye. We benefit a lot from the debugger, but few of us know the principle of it.</p><p>In the book <em>Gray Hat Python</em> , the author has constructed a simple debugger. However, it is too simple, it is only a machine language level debugger, and can only set basic breakpoints and show CPU register information. We also want to know how to </p><ul><li>Show source code </li><li>Set breakpoint based on lines, not memory address</li><li>Set Step In, Step Out, Step Over</li><li>Show stack trace</li><li>Show global and local variables</li></ul><p>In this Chinese blog <a href="http://www.cnblogs.com/zplutor/archive/2011/03/04/1971279.html" target="_blank" rel="noopener">Zplutor’s</a>, I find a excellent series which has covered most above topics. I decide to write a English blog about it, and I will turn his code into a C++ version.</p><p>Before getting started, let’s make some limitations:</p><ul><li>It is only a user mode debugger.</li><li>It is only a Windows debugger. Although the principle is quite same, but Windows has offered lots of convenient APIs. The implementation will be different on Linux.</li><li>It is only a terminal-based debugger.</li><li>Different from <em>Gray Hat Python</em> , the debugger will be implemented by C++.</li><li>The debuggee program is single thread.</li></ul><p>The modified debugger can be found <a href="https://github.com/lyyyuna/anotherDebugger" target="_blank" rel="noopener">here</a>. It is only tested under Windows 10 + Visual Studio 2013.</p><h2 id="To-Start-the-Debuggee-Program"><a href="#To-Start-the-Debuggee-Program" class="headerlink" title="To Start the Debuggee Program"></a>To Start the Debuggee Program</h2><p>The so-called user mode debugger is to debug the program in user mode. Windows has provided a series of open API for debugging, and they can be devided into three categories:</p><ul><li>API for starting the debuggee program</li><li>API for handling debug event during debug loop</li><li>API for inspecing and modifying debuggee program</li></ul><p>The first thing to do before debugging a program is to start it. On Windows, we use <em>CreateProcess</em> to start to program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO startupinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">startupinfo.cb = <span class="keyword">sizeof</span>(startupinfo);</span><br><span class="line">PROCESS_INFORMATION processinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> creationflags = DEBUG_ONLY_THIS_PROCESS | CREATE_NEW_CONSOLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CreateProcess(</span><br><span class="line">    <span class="string">"L:\\git_up\\anotherDebugger\\anotherDebugger\\Debug\\test.exe"</span>,</span><br><span class="line">    <span class="comment">//path,</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    FALSE,</span><br><span class="line">    creationflags,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;startupinfo,</span><br><span class="line">    &amp;processinfo) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CreateProcess failed: "</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DEBUG_ONLY_THIS_PROCESS means the subprocess of the debuggee will not be debugged. If you need subprocess, use DEBUG_PROCESS.</li><li>CREATE_NEW_CONSOLE means the debuggee’s and debugger’s output will be separated in two consoles.</li><li>If the debugger process exits, the debuggee will also exit.</li></ul><h2 id="Debugger-loop"><a href="#Debugger-loop" class="headerlink" title="Debugger loop"></a>Debugger loop</h2><p>The debugger loop is a bit like Windows GUI message loop, some operations and exceptions will stop the debuggee and send event to the debugger. We always use </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG_EVENT debugEvent;</span><br><span class="line">WaitForDebugEvent(&amp;debugEvent, INFINITE)</span><br></pre></td></tr></table></figure><p>to capture the debug event.</p><p>There are 9 debug event in total:</p><ul><li>CREATE_PROCESS_DEBUG_EVENT. Reports a create-process debugging event. </li><li>CREATE_THREAD_DEBUG_EVENT. Reports a create-thread debugging event.</li><li>EXCEPTION_DEBUG_EVENT. Reports an exception debugging event.</li><li>EXIT_PROCESS_DEBUG_EVENT. Reports an exit-process debugging event.</li><li>EXIT_THREAD_DEBUG_EVENT. Reports an exit-thread debugging event.</li><li>LOAD_DLL_DEBUG_EVENT. Reports a load-dynamic-link-library (DLL) debugging event.</li><li>OUTPUT_DEBUG_STRING_EVENT. Reports an output-debugging-string debugging event.</li><li>RIP_EVENT. Reports a RIP-debugging event (system debugging error).</li><li>UNLOAD_DLL_DEBUG_EVENT. Reports an unload-DLL debugging event. </li></ul><p>If the debug event has been handled correctly, then</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContinueDebugEvent(debuggeeprocessID, debuggeethreadID, DBG_CONTINUE);</span><br></pre></td></tr></table></figure><p>to continue the debuggee process. Let’s combine the above to construct the debug loop:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (WaitForDebugEvent(&amp;debugEvent, INFINITE) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">    debuggeeprocessID = debugEvent.dwProcessId;</span><br><span class="line">    debuggeethreadID = debugEvent.dwThreadId;</span><br><span class="line">    <span class="keyword">if</span> (dispatchDebugEvent(debugEvent) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        ContinueDebugEvent(debuggeeprocessID, debuggeethreadID, FLAG.continueStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dispatchDebugEvent</span><span class="params">(<span class="keyword">const</span> DEBUG_EVENT &amp; debugEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (debugEvent.dwDebugEventCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CREATE_THREAD_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXIT_PROCESS_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXIT_THREAD_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> LOAD_DLL_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UNLOAD_DLL_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OUTPUT_DEBUG_STRING_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RIP_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unknown debug event."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the next part of the series, I intend to give a brief introduction about the 9 debug events.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Debuggers are the apple of the
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Windows Debugger" scheme="http://www.lyyyuna.com/tags/Windows-Debugger/"/>
    
  </entry>
  
  <entry>
    <title>分布式 B 站用户信息爬虫</title>
    <link href="http://www.lyyyuna.com/2017/04/24/bilibili-users-spider/"/>
    <id>http://www.lyyyuna.com/2017/04/24/bilibili-users-spider/</id>
    <published>2017-04-24T13:20:36.000Z</published>
    <updated>2017-11-29T00:19:00.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周末写了一个 B 站用户信息爬虫，怎么爬网页实在是没什么好讲的，所以这篇描述一下简单的分布式爬虫。</p><p>知乎和 B 站用户爬虫极其类似。它们都有两种爬取策略：</p><ul><li>从一个用户开始，爬取关注者和被关注者，将新找到的用户存储下来，然后再从其关注网络中遍历爬取新的用户。这种爬取策略类似广度优先搜素，根据著名的<a href="http://baike.baidu.com/link?url=w0Tr_YMnE4BHSLk8MN9QBaAlbAUS18BJrlq85ZuhNDYHcN4pQKXg9KIxJ6fMIcW-rr7pQbT3Ya02hlHfiFZVijScjomLbTfhvwwavVAN3XD4GQCjRACiVhza_tndVf0KUjhj1iYrBgvZ6mTe8UCGw_" target="_blank" rel="noopener">六度人脉理论</a>，我们可以将大部分用户都找出来。不过该方法会增加程序的复杂度，你得维护好已搜索用户和未搜索用户的列表，快速去重等。</li><li>大部分网站在建立用户时会使用自增字段，或者有一个字段其值会在特定的数字范围内。对于 B 站，每个人的主页就是很好的例子，<a href="http://space.bilibili.com/8222478/#!/" target="_blank" rel="noopener">http://space.bilibili.com/8222478/#!/</a>。而对于知乎，这个值藏的比较隐秘。后来我发现，当一个用户关注你之后，便会邮件一个关注者链接给你，例如 <a href="http://www.zhihu.com/l/G4gQn" target="_blank" rel="noopener">http://www.zhihu.com/l/G4gQn</a>，最后是一个 16 进制的五位数，大部分用户都是 G，E 等开头的数字。这种链接在知乎正式页面没有发现过，猜测是历史原因保留了这种形式。</li></ul><p>自增数字的方式程序更容易实现。</p><h2 id="换代理的痛点"><a href="#换代理的痛点" class="headerlink" title="换代理的痛点"></a>换代理的痛点</h2><p>剩下的问题就是反爬虫，简单的换 header 头部就不说了，因为 B 站和知乎都是根据 IP 来反爬，那么我能想到的就只有：</p><ul><li>换代理</li><li>分布式爬虫</li></ul><p>从实现方式看，代理也能看作是一个分布式爬虫。根据 HTTP 返回的状态码，可以判断：</p><ul><li>代理是否正常工作（比如连接 timeout），</li><li>对方服务器是否判定我们访问过于频繁（比如返回 403）。</li></ul><p>基于上述判断，可以实现一些复杂的代理切换策略：</p><ul><li>定时去免费代理网站下载新的代理节点，</li><li>负载均衡，将请求平均分配到每一个节点，保证不会访问过于频繁，</li><li>代理探活，将不活跃的代理清除。</li></ul><p>不幸的是，免费好用的代理非常难找，使用 scrapy 配上<a href="https://github.com/lyyyuna/bilibili_papapa/commit/632a8827c187aa051186089d715616db8ae7fd86" target="_blank" rel="noopener">我写的几百行的代理中间件</a>，也很难维持一个正常的下载速率。<br>用 Python 来爬虫几乎是网上教程的标配了 -_-，导致即使找到一个可用代理，其 IP 也早被列入服务器的黑名单。</p><h2 id="分布式爬虫"><a href="#分布式爬虫" class="headerlink" title="分布式爬虫"></a>分布式爬虫</h2><h3 id="基于-HTTP-服务器实现分布式"><a href="#基于-HTTP-服务器实现分布式" class="headerlink" title="基于 HTTP 服务器实现分布式"></a>基于 HTTP 服务器实现分布式</h3><p><img src="https://github.com/lyyyuna/blog_img/raw/master/blog/201704/http_structure.png" alt="基于 HTTP 服务器的分布式爬虫"></p><ul><li>主从之间通信借助现有的 HTTP 协议。</li><li>主控 HTTP 服务器生成用户 id，每当有一个新的 GET 请求，自增 id，并返回给客户端。</li><li>每一个爬虫在这个结构中是一个客户端，当获取到新的 id 后，便去爬取解析网页，将结果以 POST 请求的方式返回给 HTTP 服务器。</li></ul><p>优点是：</p><ul><li>HTTP 协议简单，用 Flask 框架 5 分钟即能快速搭建。</li><li>客户端数量扩展极其方便，且不需要公网 IP。</li><li>爬虫下载速率可由每个客户端各自控制。</li></ul><p>缺点是：</p><ul><li>由于 HTTP 是无状态协议，服务器端不能跟踪一个发布的 id 是否已被正确处理。有可能一个客户端只 GET 而不 POST。需要维护另外的队列来存放未完成的任务。</li><li>HTTP 服务器发布任务是被动的。</li></ul><p>这个链接<a href="https://github.com/lyyyuna/zhihu_user_papapa" target="_blank" rel="noopener">https://github.com/lyyyuna/zhihu_user_papapa</a>里是用这种思路实现的 B 站用户爬虫。</p><h3 id="基于消息队列实现分布式"><a href="#基于消息队列实现分布式" class="headerlink" title="基于消息队列实现分布式"></a>基于消息队列实现分布式</h3><p><img src="https://github.com/lyyyuna/blog_img/raw/master/blog/201704/messagequeue_structure.png" alt="基于消息队列实现分布式爬虫"></p><p>采用消息队列后，Producer 主控侧不再是被动地发布任务，而是主动推送任务。上一小节有的优点消息队列同样拥有，同时</p><ul><li>Producer 也能控制任务发布的速率。</li><li>利用消息队列的持久化能力，可以在意外退出的情况下，记录未能成功发布的任务和未能成功接收的结果。</li></ul><p>这种结构的分布式爬虫，同样需要显示地维护一来一回蓝色红色的数据流，还是稍显复杂。</p><h3 id="基于-Celery-任务队列实现分布式"><a href="#基于-Celery-任务队列实现分布式" class="headerlink" title="基于 Celery 任务队列实现分布式"></a>基于 Celery 任务队列实现分布式</h3><p><img src="https://github.com/lyyyuna/blog_img/raw/master/blog/201704/celery_structure.png" alt="基于 Celery 实现分布式爬虫"></p><p>初看上去，这个结构和上一节没有区别，但是，上图的红色数据流是不需要显示维护的！</p><p>举一个简单例子。假设在机器 A，有如下的 worker</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=<span class="string">'pyamqp://guest@localhost//'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>那么在另一台机器 B，只要运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> add</span><br><span class="line">result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>就能得到结果。同时</p><ul><li>这个被 @app.task 修饰过的方法是异步的。机器 A 可以通过 result.ready() 来来获知任务是否被执行完。通过 result.get() 得到执行的结果。</li></ul><p>基于这个思想，我完成了这个分布式爬虫<a href="https://github.com/lyyyuna/bilibili_papapa" target="_blank" rel="noopener">https://github.com/lyyyuna/bilibili_papapa</a>。只需要 Celery 的 broker 具有公网 IP，然后把程序扔给朋友让他们帮我跑就行。唯一的不便是 Celery worker 在个人电脑上部署不便，而基于 HTTP 的分布式爬虫，我只要 C# 写个 HTTP 客户端生成 exe 就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上周末写了一个 B 站用户信息爬虫，怎么爬网页实在是没什么好讲的，所以这篇描述一下简单的分布式爬虫。&lt;/p&gt;
&lt;p&gt;知乎和 B 站用户爬虫极
      
    
    </summary>
    
      <category term="网络" scheme="http://www.lyyyuna.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Celery" scheme="http://www.lyyyuna.com/tags/Celery/"/>
    
      <category term="爬虫" scheme="http://www.lyyyuna.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用 Supervisor 管理进程</title>
    <link href="http://www.lyyyuna.com/2017/04/08/supervisor01/"/>
    <id>http://www.lyyyuna.com/2017/04/08/supervisor01/</id>
    <published>2017-04-08T09:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果需要让某一个进程长期运行，该怎么做？</p><ul><li>开一个终端，SSH 连上之后不关机。</li><li>Shell 命令加一个 &amp;，把进程扔到后台。</li><li>写一个 daemon 进程。</li><li>..</li></ul><p>当终端关闭，终端下所有的进程也会被相应的杀死，即使是被扔到后台执行的 job。然而，要把自己的应用程序专门写成 daemon，会增加开发的负担。这时候，一种万能的、对原应用侵入最小的方法，Supervisor，便走进了我们的视线。</p><p>Supervisor 可不光具有后台长期执行程序的功能。先举两个实际的例子。</p><ul><li>我所在组的产品是一个邮件网关，内含七八个扫描引擎，每种引擎都会起数个进程。为了监控和管理这些进程，我们写了很多 Shell 脚本，并用一个看门狗进程来监控进程对应的 pid 文件，一旦进程意外死亡，会被看门狗拉起来。</li><li>上周末为了写一个 Django + celery + redis 的例子，开了四五个终端，由于是在 virtualenv 下开发的，每次开终端都是一堆重复的 activate 过程。</li></ul><p>这些都可以通过 Supervisor，以类似 rc.d 脚本的方式，一劳永逸的解决。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Supervisor 是由 Python 写的，安装十分简单。</p><pre><code>pip install supervisor</code></pre><p>目前只支持 Python2 (&gt;2.4)。</p><p>不过我建议使用包管理器来安装，例如 ubuntu，</p><pre><code>apt install supervisor</code></pre><p>这样安装完以后会有一个默认的配置文件生成在</p><pre><code>/etc/supervisor/supervisord.conf</code></pre><h2 id="配置一个后台进程"><a href="#配置一个后台进程" class="headerlink" title="配置一个后台进程"></a>配置一个后台进程</h2><p>Supervisor 会按以下顺序搜索配置文件，</p><ul><li>$CWD/supervisord.conf</li><li>$CWD/etc/supervisord.conf</li><li>/etc/supervisord.conf</li><li>/etc/supervisor/supervisord.conf (since Supervisor 3.3.0)</li><li>../etc/supervisord.conf (Relative to the executable)</li><li>../supervisord.conf (Relative to the executable)</li></ul><p>配置文件是 Windows 的 INI 格式，我们撇开其他节，直奔主题 [program:x] </p><p>假设有一个循环打印 hello 的程序，使用 virtualenv 中的 Python 环境运行，现在需要其在后台常驻运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /root/test/hello.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Hello, world.'</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们添加一个 [program:x] 小节为</p><pre><code>[program:hellotest]command = /root/test/venv/bin/python -u hello.pydirectory = /root/testuser = rootstdout_logfile = /root/test/hello.logredirect_stderr = trueautostart = falseautorestart = true</code></pre><p>注意要添加 -u 启动参数，不然 stdout 上的输出会被一直缓存。首先启动 Supervisor 进程本身，安装的时候其本身已经被添加为 Linux 系统的一个 service</p><pre><code># service supervisor start</code></pre><p>然后使用 supervisorctl 工具来启动我们的 hellotest</p><pre><code># supervisorctl start hellotesthellotest: started</code></pre><p>查询 hellotest 的运行状态</p><pre><code># supervisorctl status hellotesthellotest                        RUNNING   pid 898, uptime 0:02:01</code></pre><p>查看 stdout 上的输出</p><pre><code># tailf test/hello.log Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.</code></pre><p>如果我们的参数配置错误，还可以查看 Supervisor 自身的 log</p><pre><code>/var/log/supervisor/supervisor.log</code></pre><h2 id="配置一组后台进程"><a href="#配置一组后台进程" class="headerlink" title="配置一组后台进程"></a>配置一组后台进程</h2><p>配置一组后台进程与之类似，首先我们需要多个 [program:x] 小节</p><pre><code>[program:hellotest]command = /root/test/venv/bin/python -u hello.pydirectory = /root/testuser = rootstdout_logfile = /root/test/hello.logredirect_stderr = trueautorestart = trueautostart = false[program:hellotest2]command = /root/test/venv/bin/python -u hello2.pydirectory = /root/testuser = rootstdout_logfile = /root/test/hello.logredirect_stderr = trueautorestart = trueautostart = false[group:hellogroup]programs = hellotest, hellotest2</code></pre><p>启动一组中所有进程时，命令有些不同</p><pre><code>supervisorctl start hellogroup:*</code></pre><p>一旦一个 program 被加入组中，你就不能再用原先的命令启动</p><pre><code># supervisorctl start hellotesthellotest: ERROR (no such process)# supervisorctl start hellogroup:hellotest</code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>我们可以看一下进程的 pid 号来验证我们的 hello 进程确实是 Supervisor 的子进程</p><pre><code># ps -ef | grep 1182root      1182     1  0 16:07 ?        00:00:00 /usr/bin/python /usr/bin/supervisord -n -c /etc/supervisor/supervisord.confroot      1226  1182  0 16:12 ?        00:00:00 /root/test/venv/bin/python -u hello2.pyroot      1227  1182  0 16:12 ?        00:00:00 /root/test/venv/bin/python -u hello.py</code></pre><p>再用 kill 命令验证 Supervisor 具有看门狗功能</p><pre><code># kill -9 1226# ps -ef | grep 1182root      1182     1  0 16:07 ?        00:00:00 /usr/bin/python /usr/bin/supervisord -n -c /etc/supervisor/supervisord.confroot      1227  1182  0 16:12 ?        00:00:00 /root/test/venv/bin/python -u hello.pyroot      1255  1182  0 16:18 ?        00:00:00 /root/test/venv/bin/python -u hello2.py</code></pre><p>hello2.py 已经是新的 pid 号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果需要让某一个进程长期运行，该怎么做？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开一个终端，SSH 连上之后不关机。&lt;/li&gt;
&lt;li&gt;Shell 命令
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>c++ 函数重载是如何实现的</title>
    <link href="http://www.lyyyuna.com/2016/12/22/insidecppmodel2/"/>
    <id>http://www.lyyyuna.com/2016/12/22/insidecppmodel2/</id>
    <published>2016-12-22T12:35:53.000Z</published>
    <updated>2017-11-29T02:08:03.768Z</updated>
    
    <content type="html"><![CDATA[<p>函数重载是 c++ 的编译时多态的一部分，也就是说，该行为在编译完成后即是确定的。事实上，这是编译器和链接器之间玩的小花招。链接器通过符号（symbol）定位各个函数，所谓符号可以简单理解为一个字符串。</p><p>编译器会给每个函数名一个符号，在 c 语言中，符号名只和函数名有关。</p><p>来一个 c 语言程序的例子，使用 Visual Studio 编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 Visual Studio 自带的工具 dumpbin 查看 .obj 文件的符号表</p><pre><code>017 00000000 SECT4  notype ()    External     | _add</code></pre><p>我们换一个函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用 dumpbin 查看 .obj 文件的符号表</p><pre><code>017 00000000 SECT4  notype ()    External     | _add</code></pre><p>还是同样的符号。所以， c 语言编译器不支持函数重载，函数名相同的话，链接器永远只能看到一个名字。</p><p>那么，c++ 呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">add(<span class="built_in">string</span>(<span class="string">"1"</span>), <span class="built_in">string</span>(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用 dumpbin 查看 .obj 文件的符号表</p><pre><code>2F3 00000000 SECT87 notype ()    External     | ?add@@YAXHH@Z (void __cdecl add(int,int))2F4 00000000 SECT89 notype ()    External     | ?add@@YAXNN@Z (void __cdecl add(double,double))2F5 00000000 SECT8B notype ()    External     | ?add@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z (void __cdecl add(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;))</code></pre><p>可以看到，每个符号都不一样啦。这时候的函数声明不仅和函数名有关，也和参数类型有关，但和返回类型无关。符号能唯一确定，编译器自然也能顺利实现重载。</p><p>顺便可以发现，同一个函数声明在 c 和 c++ 中是完全不一样的。这也是为什么 c 和 c++ 之间动静态库不能直接互相调用的原因。为此 cpp 使用了 extern “C” 语法，强制使用 c++ 编译器使用 c 语言的符号命名方法。</p><p>我们实验一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">add(<span class="built_in">string</span>(<span class="string">"1"</span>), <span class="built_in">string</span>(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 .obj 文件的符号表</p><pre><code>2F3 00000000 SECTD3 notype ()    External     | _add2F4 00000000 SECT87 notype ()    External     | ?add@@YAXNN@Z (void __cdecl add(double,double))2F5 00000000 SECT89 notype ()    External     | ?add@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z (void __cdecl add(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;))</code></pre><p>可以看到，第一个函数的符号和 c 语言一致了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数重载是 c++ 的编译时多态的一部分，也就是说，该行为在编译完成后即是确定的。事实上，这是编译器和链接器之间玩的小花招。链接器通过符号（symbol）定位各个函数，所谓符号可以简单理解为一个字符串。&lt;/p&gt;
&lt;p&gt;编译器会给每个函数名一个符号，在 c 语言中，符号名只和
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="cpp" scheme="http://www.lyyyuna.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>c++ 虚函数是如何实现的</title>
    <link href="http://www.lyyyuna.com/2016/12/21/insidecppmodel1/"/>
    <id>http://www.lyyyuna.com/2016/12/21/insidecppmodel1/</id>
    <published>2016-12-21T12:35:53.000Z</published>
    <updated>2017-11-29T00:19:00.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>探索 c++ 对象内部的实现是一件非常有趣的事情。c++ 分为编译时多态和运行时多态。运行时多态依赖于虚函数，大部分人或许听说过虚函数是由虚函数表+虚函数指针实现的，但，真的是这样吗？虽然 c++ 规范有着复杂的语言细节，但底层实现机制却任由编译器厂商想象。（没准某种特殊的处理器电路结构原生支持虚函数，没准这个处理器压根不是冯纽曼型，或者将来厂商发明了比虚函数表更有效率的数据结构。）</p><p>本篇文章就来实际检验一下 Visual Studio 2013 编译器在无优化条件下，虚函数的实现。</p><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>封装把实例的数据和操作结合在了一起，但实例本身只有数据，没有函数，同一个类的函数是共享的。我们通过一个例子来间接证明这一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"heel"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base1 b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b1) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>打印</p><pre><code>4</code></pre><p>如果类中有虚函数，则会在对象中加入一个虚函数指针，该指针指向一个虚函数表，表中是各个虚函数的地址。</p><pre><code>+--------+       +---------+| pvtbl  |------&gt;| vfunc1  |+--------+       +---------+| data1  |       | vfunc2  |+--------+       +---------+| ...    |       | ...     |</code></pre><p>当子类继承父类时，会依次覆盖虚函数表中的各个项，如果子类没有重写某项，那该项就保留。当实例化对象后，虚函数指针就作为一个隐藏数据存在于实例中。如果通过父类指针调用普通成员函数，由于普通函数和类型绑定在一起，所以仍会调用父类成员函数；如果通过父类指针调用虚函数，则会通过对象的虚指针找到虚函数表（即子类的虚函数表），定位虚函数项，实现多态。</p><p>原理是不是很简单？c++ 就是通过这种看似原始的方式实现高级抽象。以上是编译器的通用做法，我手上的 Visual Studio 2013 编译器就是这么做的，为了提高性能，VS 保证虚函数指针存在于对象实例中最前面位置（历史上也有编译器不这么做，好像是 Borland 的？）。</p><h2 id="Visual-Studio-2013-中的实现"><a href="#Visual-Studio-2013-中的实现" class="headerlink" title="Visual Studio 2013 中的实现"></a>Visual Studio 2013 中的实现</h2><p>来一个例子（能这么写是因为我已知了 Visual Studio 2013 编译后对象的内存布局）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func2"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func3"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::func1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::func3"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b, b1;</span><br><span class="line"><span class="keyword">int</span>** pvirtualtable1 = (<span class="keyword">int</span>**)&amp;b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base object vtbl address: "</span> &lt;&lt; pvirtualtable1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span>** pvirtualtable11 = (<span class="keyword">int</span>**)&amp;b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"another Base object vtbl address: "</span> &lt;&lt; pvirtualtable11[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"function in virtual table"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (Base::func)pvirtualtable1[<span class="number">0</span>][i] != <span class="literal">NULL</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> p = (Base::func)pvirtualtable1[<span class="number">0</span>][i];</span><br><span class="line">p();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span>** pvirtualtable2 = (<span class="keyword">int</span>**)&amp;d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived object vtbl address: "</span> &lt;&lt; pvirtualtable2[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"function in virtual table"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (Base::func)pvirtualtable2[<span class="number">0</span>][i] != <span class="literal">NULL</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> p = (Base::func)pvirtualtable2[<span class="number">0</span>][i];</span><br><span class="line">p();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印</p><pre><code>Base object pvtbl address: 0029DA58another Base object pvtbl address: 0029DA58function address in virtual tableBase::func1Base::func2Base::func3Derived object pvtbl address: 0029DB20function address in virtual tableDerived::func1Base::func2Derived::func3</code></pre><p>可以看到，同一类型不同实例的虚函数表是相同的，继承之后，子类有了自己的虚函数表，表也有相应的更新(Derived::func1, Derived::func3)，表中未重写的项还保留为原值(Base::func2)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;探索 c++ 对象内部的实现是一件非常有趣的事情。c++ 分为编译时多态和运行时多态。运行时多态依赖于虚函数，大部分人或许听说过虚函数是由虚
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="cpp" scheme="http://www.lyyyuna.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Python 访问外围作用域中的变量</title>
    <link href="http://www.lyyyuna.com/2016/09/10/python-nonlocal-variable/"/>
    <id>http://www.lyyyuna.com/2016/09/10/python-nonlocal-variable/</id>
    <published>2016-09-10T13:33:31.000Z</published>
    <updated>2017-11-29T00:19:00.165Z</updated>
    
    <content type="html"><![CDATA[<p>在表达式中引用变量时，Python 会按照如下的顺序遍历各个作用域，寻找该变量：</p><ol><li>当前函数作用域</li><li>任何外围作用域（比如包含当前函数的其他函数）</li><li>global 作用域，即代码所在的模块的作用域</li></ol><p>如果上述作用域内都找不到变量，就会报 NameError 异常。</p><p>但是对变量赋值时，规则会有所不同。</p><ol><li>如果当前作用域变量已存在，那么其值会被替换。</li><li>如果不存在，则会视为在当前作用域定义新变量，而不是向外围作用域中寻找。</li></ol><p>如下函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">    helper()</span><br><span class="line">    <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">function()</span><br></pre></td></tr></table></figure><p>由于 helper 中变量是赋值，这里 flag 输出仍为 True。习惯了 c 语言之类静态类型语言，这种设计起初会感到困惑，但其可以有效地防止局部变量污染函数外的环境。</p><p>需求总是多样的，一定有程序员想在赋值时访问外围作用域。如果是 Python2，他可以这么做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    flag = [<span class="keyword">True</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        flag[<span class="number">0</span>] = <span class="keyword">False</span></span><br><span class="line">    helper()</span><br><span class="line">    <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">function()</span><br></pre></td></tr></table></figure><p>先用 flag[0] 是读操作，产生一次变量引用，寻找到外围作用域中 flag，这时候再赋值 flag[0] = False 便不会新定义变量了。</p><p>如果是 Python3，则可以使用 nonlocal 关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> flag</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">    helper()</span><br><span class="line">    <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">function()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在表达式中引用变量时，Python 会按照如下的顺序遍历各个作用域，寻找该变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前函数作用域&lt;/li&gt;
&lt;li&gt;任何外围作用域（比如包含当前函数的其他函数）&lt;/li&gt;
&lt;li&gt;global 作用域，即代码所在的模块的作用域&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework 模板与数据驱动测试</title>
    <link href="http://www.lyyyuna.com/2016/07/29/robotframework-template-and-data-driven/"/>
    <id>http://www.lyyyuna.com/2016/07/29/robotframework-template-and-data-driven/</id>
    <published>2016-07-29T11:59:52.000Z</published>
    <updated>2017-11-29T00:19:00.166Z</updated>
    
    <content type="html"><![CDATA[<p>Robot Framework 是关键字驱动的测试框架，虽然关键字驱动高度抽象了底层实现，减少维护成本，降低了对测试人员编程水平的需求，但在某些类型的测试中，数据驱动导向的测试用例比重多，比如常见的用户输入框就有海量的输入可能性。Robot Framework 提供了测试模板，可以将其转换为数据驱动的测试。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>如果有一个接受参数的关键字，那么它就可以被用作模板。下面的例子展示了这一点。</p><pre><code>*** Settings ***Test Setup        PrepareTest Template     Compare Two Number ${one} ${three}*** Test Cases ***Template test case    1    2    1    1    2    3    2    2*** Keywords ***Compare Two Number ${one} ${three}    Should Be Equal    ${one}    ${three}</code></pre><p>这里展示了比较两个数是否相等的例子，可以看到只需填入输入数据即可。你也可以用 [Template] 为每个 Test Case 单独指定模板。</p><h2 id="与循环执行的区别"><a href="#与循环执行的区别" class="headerlink" title="与循环执行的区别"></a>与循环执行的区别</h2><p>有人会问，能否运用循环语句来模拟上述行为呢？</p><p>首先，由于 Robot Framework 是个测试框架，编程能力被弱化不少，模板语法显得简洁 ^_^，然后，在用例中混入过多的执行控制流也不是推荐的行为（或者绝对地说，用例中就不应该有循环、判断语句）。</p><p>其次，模板是处于 continue on failure 模式中，某一项输入 Fail，还会继续执行其他输入。普通 Case 一旦有个语句 Fail，该 Case 就会 tear down。比如上面给的例子，第一行和第二行就会 Fail，实际执行结果如下：</p><pre><code># logStarting test: Testcases.UI Test.Template test case20160729 12:08:56.652 :  FAIL : 1 != 220160729 12:08:56.668 :  FAIL : 2 != 3Ending test:   Testcases.UI Test.Template test case# report========================================================Testcases                                                                                                                                                                ========================================================Testcases.UI Test                                                                                                                                                        ========================================================Template test case                                                                                                                                               | FAIL |Several failures occurred:1) 1 != 22) 2 != 3--------------------------------------------------------Testcases.UI Test                                                                                                                                                | FAIL |1 critical test, 0 passed, 1 failed1 test total, 0 passed, 1 failed========================================================Testcases                                                                                                                                                        | FAIL |1 critical test, 0 passed, 1 failed1 test total, 0 passed, 1 failed========================================================</code></pre><p>单个输入中的 Fail 不会中断执行流。</p><h2 id="一些不足"><a href="#一些不足" class="headerlink" title="一些不足"></a>一些不足</h2><p>这些不足是我自己感受，可能并不准确。</p><p>我自己在自动化测试中使用数据驱动测试方法，只是希望减轻手工编写的工作量，对于执行流上的步骤不想简化。我希望每个输入都能完整地走完一遍 Test Setup | Test Execuation | Test Teardown 过程，遗憾的是好像 Robot Framework 做不到。下面是例子，这里增加了一个 Test Setup。</p><pre><code>*** Settings ***Test Setup        PrepareTest Template     Compare Two Number ${one} ${three}*** Test Cases ***Template test case    1    2    1    1    2    3    2    2*** Keywords ***Compare Two Number ${one} ${three}    Should Be Equal    ${one}    ${three}Prepare    Log    hello, world</code></pre><p>可以看到 hello, world 只打印了一次。</p><pre><code>Starting test: Testcases.UI Test.Template test case20160729 12:08:56.652 :  INFO : hello, world20160729 12:08:56.652 :  FAIL : 1 != 220160729 12:08:56.668 :  FAIL : 2 != 3Ending test:   Testcases.UI Test.Template test case</code></pre><p>这就使得框架对测试输入有要求：输入数据不能对后续输入有影响。一旦在执行过程中有 Fail 发生，就无法用 Test Teardown 恢复测试环境（Run Keyword And Continue On Failure 关键字可能可以解决该问题，但这样写逻辑上并不清晰）。</p><p>使用 Library 导入的标准库和外部库也有问题，测试框架会为每个 Case 生成一个库的实例（即 Python, Java 类的实例），模板中每一行输入都共享一个实例，若是类中有全局变量，便会在各个输入之间产生干扰。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Robot Framework 是关键字驱动的测试框架，虽然关键字驱动高度抽象了底层实现，减少维护成本，降低了对测试人员编程水平的需求，但在某些类型的测试中，数据驱动导向的测试用例比重多，比如常见的用户输入框就有海量的输入可能性。Robot Framework 提供了测试模
      
    
    </summary>
    
      <category term="自动化测试" scheme="http://www.lyyyuna.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="robot framework" scheme="http://www.lyyyuna.com/tags/robot-framework/"/>
    
  </entry>
  
  <entry>
    <title>基于 BP 神经网络的手写体数字识别 - 优化</title>
    <link href="http://www.lyyyuna.com/2016/06/30/handwritten-neural-net04/"/>
    <id>http://www.lyyyuna.com/2016/06/30/handwritten-neural-net04/</id>
    <published>2016-06-30T12:25:58.000Z</published>
    <updated>2017-11-29T00:19:00.164Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({  TeX: { equationNumbers: { autoNumber: "AMS" } }});</script><p>目前为止，我们论述中，似乎手写数字图像本身并没有太多篇幅。这就是神经网络的特点，那 784 个像素点只是神经网络的输入，不需要任何图像处理。</p><p>95% 的识别率看起来很高了，但还有不少提升空间。本篇文章将介绍多种优化方法。</p><h2 id="交叉熵代价函数"><a href="#交叉熵代价函数" class="headerlink" title="交叉熵代价函数"></a>交叉熵代价函数</h2><p>理想情况下我们的神经网络能够快速地从错误中学习。但实际过程中却可能学习缓慢。让我们看下面这个例子：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tikz28.png" alt="例子"></p><p>我们期望该神经元在输入 1 时输出 0。若神经元权重初始值为 0.6，偏移初始值为 0.9，则初始输出为 0.82，离预期输出还有一段距离。我们选择学习率 $\eta=0.15$，点击 <strong>Run</strong> 观察输出变化和二次代价函数的变化动画：</p><p><script type="text/javascript" src="//cdn.bootcss.com/paper.js/0.9.25/paper-full.min.js"></script></p><p><script type="text/paperscript" src="/customjs/saturation1.js" canvas="saturation1"><br></script></p><center><br><canvas id="saturation1" width="520" height="300"></canvas><br></center><p>可以看到，神经元一直在“学习进步”，且“进步”神速，最终的输出也接近于 0。现在将权重初始值和偏移初始值都设为 2.0，再点击 <strong>Run</strong> 观察动画：</p><p><script type="text/paperscript" src="/customjs/saturation2.js" canvas="saturation2"><br></script></p><center><br><canvas id="saturation2" width="520" height="300"></canvas><br></center><p>参数未变，结果造成学习速度减慢。仔细观察，开始的 150 个 epoch 权重和偏移几乎保持不变。过了这个点，神经元又变成了“进步”神速的好孩子。</p><p>我们经常把自学习与人类的学习作比较，这里神经元的学习过程显得反常。当人类发现自己错误的离谱时会学习较快，而大部分未优化的神经元却在错误中踌躇不前。</p><p>让我们来探究一下问题的缘由。神经元学习慢，等同于权重和偏移变化慢，等同于代价函数的偏导数 $\partial C/\partial w$ 和 $\partial C / \partial b$ 较小。我们的二次代价函数为</p><p>\begin{eqnarray}<br>  C = \frac{(y-a)^2}{2},<br>\label{54}<br>\end{eqnarray}</p><p>其中，$a$ 是当训练输入 $x=1$ 时神经元的输出，$y=0$ 是期望输出。将 $a=\sigma(z), z = wx+b$ 代入上式，并求取偏导数可得</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial w} &amp; = &amp; (a-y)\sigma’(z) x = a \sigma’(z) \label{55}\\<br>  \frac{\partial C}{\partial b} &amp; = &amp; (a-y)\sigma’(z) = a \sigma’(z),<br>\label{56}<br>\end{eqnarray}</p><p>结合我们的 $\sigma$ 函数图像，即 sigmoid 函数图像：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/sigmoid_function.png" alt="sigmoid 函数"></p><p>当神经元的输出接近于 0 时，曲线变得很平缓，所以 $\sigma’(z)$ 的值很小，结合公式 (\ref{55}) 和 (\ref{56}) 可知，$\partial C/\partial w$ 和 $\partial C / \partial b$ 的值很小。</p><h3 id="介绍交叉熵代价函数"><a href="#介绍交叉熵代价函数" class="headerlink" title="介绍交叉熵代价函数"></a>介绍交叉熵代价函数</h3><p>假设我们要训练如下的神经元，输入变量为 $x_1, x_2, …$，对应的权重为 $w_1, w_2, …$，偏移为 $b$：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tikz29.png" alt="多输入神经元"></p><p>其中输出是 $a=\sigma(z), z = \sum_j w_j x_j+b$。对此，我们定义该神经元的交叉熵代价函数为</p><p>\begin{eqnarray}<br>  C = -\frac{1}{n} \sum_x \left[y \ln a + (1-y ) \ln (1-a) \right],<br>\label{57}<br>\end{eqnarray}</p><p>其中，$n$ 是所有训练数据的总和，$x$ 和 $y$ 是相应的输入和期望输出。为什么公式 (\ref{57}) 可以作为代价函数？</p><p>首先，由于 $a$ 的取值在 0, 1 之间，$y \ln a + (1-y) \ln (1-a)$ 为负，取反后公式 (\ref{57}) 非负。然后，当实际输出 $a$ 接近期望输出 $y$ 时，交叉熵接近于 0。这两点是代价函数的基本条件。将 $a = \sigma(z)$ 代入公式 (\ref{57}) 并计算交叉熵对权重的偏导，得</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial w_j} &amp; = &amp; -\frac{1}{n} \sum_x \left(<br>    \frac{y }{\sigma(z)} -\frac{(1-y)}{1-\sigma(z)} \right)<br>  \frac{\partial \sigma}{\partial w_j} \label{58}\\<br> &amp; = &amp; -\frac{1}{n} \sum_x \left(<br>    \frac{y}{\sigma(z)}<br>    -\frac{(1-y)}{1-\sigma(z)} \right)\sigma’(z) x_j.<br>\label{59}<br>\end{eqnarray}</p><p>合并成一个分母，得</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial w_j} &amp; = &amp; \frac{1}{n}<br>  \sum_x \frac{\sigma’(z) x_j}{\sigma(z) (1-\sigma(z))}<br>  (\sigma(z)-y).<br>\label{60}<br>\end{eqnarray}</p><p>由于 $\sigma’(z) = \sigma(z)(1-\sigma(z))$，上式还可以抵消，进一步简化为</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial w_j} =  \frac{1}{n} \sum_x x_j(\sigma(z)-y).<br>\label{61}<br>\end{eqnarray}</p><p>权重的学习速率由 $\sigma(z)-y$ 控制，误差越大，学习越快。二次代价函数 (\ref{55}) 中，正是由于 $\sigma’(z)$ 的存在，自学习的速率减慢，而公式 (\ref{61}) 消掉了这一项。同理，可得交叉熵对权重的偏导数为</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial b} = \frac{1}{n} \sum_x (\sigma(z)-y).<br>\label{62}<br>\end{eqnarray}</p><p>同样，恼人的 $\sigma’(z)$ 也被消掉了。</p><p>让我们再来看一下之前动画，这次使用交叉熵作为代价函数，且学习率改为 $\eta=0.005$。第一个，权重初始值是 0.6，偏移初始值是 0.9，点击 <strong>Run</strong>。</p><p><script type="text/paperscript" src="/customjs/saturation3.js" canvas="saturation3"><br></script></p><center><br><canvas id="saturation3" width="520" height="300"></canvas><br></center><p>意料之中，学习速度还是很快。第二个，权重和偏移初始值都为 2，点击 <strong>Run</strong>。</p><p><script type="text/paperscript" src="/customjs/saturation4.js" canvas="saturation4"><br></script></p><center><br><canvas id="saturation4" width="520" height="300"></canvas><br></center><p>神经元还是学习迅速。你可能注意到了 $\eta$ 的变化，这会不会影响试验结果？其实，我们关心的不是神经元学习的绝对速度，而是学习速度本身的变化。</p><p>上述结论完全可以推广到多层多神经元的网络，定义交叉熵为</p><p>\begin{eqnarray}  C = -\frac{1}{n} \sum_x<br>  \sum_j \left[y_j \ln a^L_j + (1-y_j) \ln (1-a^L_j) \right].<br>\label{63}<br>\end{eqnarray}</p><p>那什么时候该用交叉熵而不是二次代价函数？对于 sigmoid 神经元，交叉熵几乎永远是更优选择，也被实践证明。</p><h3 id="柔性最大值传输-softmax"><a href="#柔性最大值传输-softmax" class="headerlink" title="柔性最大值传输 softmax"></a>柔性最大值传输 softmax</h3><p>通过将神经网络的输出由 sigmoid 换成 softmax 层可以进一步改善学习缓慢的问题。 </p><p>对于输出层，其权重输入为 $z^L_j = \sum_{k} w^L_{jk} a^{L-1}_k + b^L_j$，施加 softmax 函数，输出层激励为</p><p>\begin{eqnarray}<br>  a^L_j = \frac{e^{z^L_j}}{\sum_k e^{z^L_k}},<br>\label{78}<br>\end{eqnarray}</p><p>其中，分母是所有输出神经元输出之和。又是一个看起来意义不明的函数。如果我们将所有激励相加，会发现其值正好等于 1，</p><p>\begin{eqnarray}<br>  \sum_j a^L_j &amp; = &amp; \frac{\sum_j e^{z^L_j}}{\sum_k e^{z^L_k}} = 1.<br>\label{79}<br>\end{eqnarray}</p><p>当某一个激励增加时，其他的激励必须相应地减少以保证和不变。换句话说，如果将 softmax 作为输出层，神经网络的所有输出符合概率分布。这又是一个方便的特性，尤其对于手写数字识别来说，每个输出代表每个数字的概率，之前 sigmoid 的方案有可能会有如下的输出</p><pre><code>[0.9, 0.3, 0.4, 0.1, 0.0, 0.4, 0.0, 0.0, 0.0, 0.1]</code></pre><p>每个概率之间并没有联系，sigmoid 输出神经元只是各顾各的训练。而且人们拿到这个结果肯定会非常疑惑，为啥概率相加不等于 1？</p><h2 id="过拟合和正则化"><a href="#过拟合和正则化" class="headerlink" title="过拟合和正则化"></a>过拟合和正则化</h2><p>诺贝尔物理学奖获得者费米曾经和他的同事讨论一个数学模型。该模型能够很好地解释实验结果，但费米仍有疑虑。他问该模型用了多少个自由变量，同事回答四个。费米回答：“我记得我朋友冯诺依曼曾经说过，四个变量我能描述一头大象，五个变量就能让他转鼻子了”。</p><p>拥有大量自由变量的模型很容易就描述大部分实验现象。但是不能说符合实验现象的模型就是好模型。有足够自由变量的模型中，几乎可以描述任何给定大小的数据集，但没有抓住现象背后的本质。这种情况下，模型只能适用于现有数据，面对新的情况却束手无策。模型的真正考验，是它有能力对未出现的现象做出预言。</p><p>费米和诺依曼对四变量的模型就产生了质疑。而我们手写数字识别系统有 30 个隐藏神经元，有将近 24000 个变量！若是 100 个隐藏神经元，那就有近 80000 个变量！这么多变量，不禁要问，结果可信么？会出现费米和诺依曼担心的问题么？</p><p>让我们来模拟一下这种情况的发生。我们使用 30 个隐藏神经元，但我们不使用 50000 个 MNIST 训练图像，相反，只是用 1000 个训练图像。这样，问题会更显著。训练使用交叉熵函数，学习率 $\eta=0.5$，mini-batch 大小为 10，训练 400 个epochs。让我们用 <a href="https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network2.py" target="_blank" rel="noopener">network2</a> 来观察变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mnist_loader </span><br><span class="line">training_data, validation_data, test_data = mnist_loader.load_data_wrapper()</span><br><span class="line"><span class="keyword">import</span> network2 </span><br><span class="line">net = network2.Network([<span class="number">784</span>, <span class="number">30</span>, <span class="number">10</span>], cost=network2.CrossEntropyCost) </span><br><span class="line">net.large_weight_initializer()</span><br><span class="line">net.SGD(training_data[:<span class="number">1000</span>], <span class="number">400</span>, <span class="number">10</span>, <span class="number">0.5</span>, evaluation_data=test_data, monitor_evaluation_accuracy=<span class="keyword">True</span>, monitor_training_cost=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>首先是代价函数随学习进度的变化图像：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/overfitting1.png" alt="代价函数变化"></p><p>看起来不错，代价不断减小，似乎说明我们的神经网络一直在进步。但是测试集上识别率却不是那么回事：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/overfitting2.png" alt="识别率变化"></p><p>280 个 epoch 之后，识别率处于波动稳定状态，且远低于之前达到的 95% 识别率。训练数据的交叉熵和测试集的实际结果截然不同，出现了费米担心的问题。可以说，280 个 epoch 之后的学习完全无用，标准说法是<strong>过拟合 overfitting</strong>。</p><p>让我们在做一点更直观的比较：训练集和测试集的交叉熵横向对比，及识别率横向对比。</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/overfitting3.png" alt="测试集交叉熵"></p><p>交叉熵仅仅下降了 15 个 epoch，之后就一路飙高，持续恶化。这是我们模型过拟合的又一个标志。这里有个小疑问，epoch 15 和 epoch 280 哪个属于开始过拟合？从实践的角度看，我们真正的关心的是测试集（更接近真实情况）上的识别率，交叉熵只是算法的附带物，所以我们认为，epoch 280 之后，过拟合开始占据神经网络的学习过程。</p><p>下面是训练集的识别率变化：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/overfitting4.png" alt="训练集识别率"></p><p>我们的模型能够 100% 地描述 1000 个训练图像，实际却不能很好地分类测试数字。</p><p>最明显的检测过拟合的方法是观察测试集上识别率的变化。如果发现测试集识别率不再改善，就应该停止训练。这也是<a href="http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/">之前文章-代码实现</a>为什么要再引入验证集的原因，毕竟测试集是最终判定结果用的，应该与训练过程彻底分离。</p><pre><code>training_data, validation_data, test_data = mnist_loader.load_data_wrapper()</code></pre><p>我们一直在讨论 1000 个训练图片的过拟合问题，那 50000 个图片结果还是一样吗？这里给出结果：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/overfitting_full.png" alt="扩大训练集"></p><p>可以看到，过拟合不再那么明显了，训练集的识别率只比测试集高 1.5% 左右。这也间接说明，大量训练数据下神经网络难以达到过拟合。不过训练集并不是那么容易获得的。</p><h3 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化 Regularization"></a>正则化 Regularization</h3><p>首先要明确一点，我们并不想减少网络中变量的数目，我们需要这种特性来描述现实世界复杂的变化。</p><p>正则化方法能够缓解过拟合问题，最常用的是权重衰减法或者叫 $L_2$ 正则化。$L_2$ 正则化只是在原先的代价函数中加入一个正则项：</p><p>\begin{eqnarray}<br>C = -\frac{1}{n} \sum_{xj} \left[ y_j \ln a^L_j+(1-y_j) \ln<br>(1-a^L_j)\right] + \frac{\lambda}{2n} \sum_w w^2.<br>\label{85}<br>\end{eqnarray}</p><p>等式右边第一项是交叉熵，第二项是网络中所有权重的平方和，并乘以系数 $\lambda /2n$，其中 $\lambda &gt; 0$，称作正则化参数。</p><p>正则化不只适用于交叉熵代价函数，二次代价函数也可以使用：</p><p>\begin{eqnarray}<br>C = \frac{1}{2n} \sum_x |y-a^L|^2 +<br>  \frac{\lambda}{2n} \sum_w w^2.<br>\label{86}<br>\end{eqnarray}</p><p>总结下来就是</p><p>\begin{eqnarray}<br>C = C_0 + \frac{\lambda}{2n}<br>\sum_w w^2,<br>\label{87}<br>\end{eqnarray}</p><p>其中 $C_0$ 是未正则化的代价函数。观察该式，可以发现正则化逼迫自学习过程选择更小的权重，权重越大，代价也越高。由于代价函数的变换，随机梯度下降法中偏导数的计算也要随之改变：</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial w} &amp; = &amp; \frac{\partial C_0}{\partial w} +<br>  \frac{\lambda}{n} w \label{88}\\<br>  \frac{\partial C}{\partial b} &amp; = &amp; \frac{\partial C_0}{\partial b}.<br>\label{89}<br>\end{eqnarray}</p><p>$\partial C_0 / \partial w$ 和 $\partial C_0 / \partial b$ 仍让可以用<a href="http://www.lyyyuna.com/2016/06/26/handwritten-neural-net03/">上一篇</a>的反向传播算法求得。对偏移的偏导数并没有改变，所以据梯度下降法学习规则仍为：</p><p>\begin{eqnarray}<br>b &amp; \rightarrow &amp; b -\eta \frac{\partial C_0}{\partial b}.<br>\label{90}<br>\end{eqnarray}</p><p>而权重的自学习规则则变成：</p><p>\begin{eqnarray}<br>  w &amp; \rightarrow &amp; w-\eta \frac{\partial C_0}{\partial<br>    w}-\frac{\eta \lambda}{n} w \label{91}\\<br>  &amp; = &amp; \left(1-\frac{\eta \lambda}{n}\right) w -\eta \frac{\partial<br>    C_0}{\partial w}.<br>\label{92}<br>\end{eqnarray}</p><p>可以看到，权重 $w$ 乘以了一个小于 1 的系数 $1-\frac{\eta \lambda}{n}$，称为权重衰减，有减小权重的趋势。而后一项由于偏导有正有负，所以权重值并不是单调递减，两项相加，彼此制约。</p><p>以上是梯度下降法，随机梯度下降法也只要做相应的调整：</p><p>\begin{eqnarray}<br>  w \rightarrow \left(1-\frac{\eta \lambda}{n}\right) w -\frac{\eta}{m}<br>  \sum_x \frac{\partial C_x}{\partial w},<br>\label{93}<br>\end{eqnarray}</p><p>\begin{eqnarray}<br>  b \rightarrow b - \frac{\eta}{m} \sum_x \frac{\partial C_x}{\partial b},<br>\label{94}<br>\end{eqnarray}</p><p>其中，求和是对一个 mini-batch 内所有数据的求和。</p><p>让我们实验一下。这次在 <a href="https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network2.py" target="_blank" rel="noopener">network2</a> 中加入正则化参数 $\lambda=0.1$。对比之前 1000 个训练数据集的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mnist_loader </span><br><span class="line">training_data, validation_data, test_data = mnist_loader.load_data_wrapper() </span><br><span class="line"><span class="keyword">import</span> network2 </span><br><span class="line">net = network2.Network([<span class="number">784</span>, <span class="number">30</span>, <span class="number">10</span>], cost=network2.CrossEntropyCost)</span><br><span class="line">net.large_weight_initializer()</span><br><span class="line">net.SGD(training_data[:<span class="number">1000</span>], <span class="number">400</span>, <span class="number">10</span>, <span class="number">0.5</span>, </span><br><span class="line">        evaluation_data=test_data, lmbda = <span class="number">0.1</span>, </span><br><span class="line">        monitor_evaluation_cost=<span class="keyword">True</span>, monitor_evaluation_accuracy=<span class="keyword">True</span>, </span><br><span class="line">        monitor_training_cost=<span class="keyword">True</span>, monitor_training_accuracy=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>训练集的交叉熵代价看来没什么问题：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/regularized1.png" alt="训练集的代价"></p><p>但这次识别率却是一直在上升：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/regularized2.png" alt="识别率上升"></p><p>我们在试一下 50000 个训练数据的情况：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/regularized_full.png" alt="识别率"></p><p>训练集和测试集的识别率只差 1% 左右，而正则化之前这一值是 1.5%。</p><p>用以下参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net = network2.Network([<span class="number">784</span>, <span class="number">100</span>, <span class="number">10</span>], cost=network2.CrossEntropyCost)</span><br><span class="line">net.large_weight_initializer()</span><br><span class="line">net.SGD(training_data, <span class="number">60</span>, <span class="number">10</span>, <span class="number">0.1</span>, lmbda=<span class="number">5.0</span>,</span><br><span class="line">      evaluation_data=validation_data,</span><br><span class="line">      monitor_evaluation_accuracy=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>识别率提高到 98%。你可以认为，由于过拟合的存在，神经网络模型易陷入局部最优解，正则之后，跳出局部最优，滚向全局最优，最终带来识别率的提升。</p><h3 id="为什么正则化能抑制过拟合"><a href="#为什么正则化能抑制过拟合" class="headerlink" title="为什么正则化能抑制过拟合"></a>为什么正则化能抑制过拟合</h3><p>从正则化的结果来看，似乎权重值越小越能抑制过拟合。</p><p>让我们看一个经典的例子，假设要对下图所示的点建立一个模型：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tenpoints1.png" alt="很多点"></p><p>数一下，有 10 个点，那可以用一个 9 次函数精确地描述它，$y = a_0 x^9 + a_1 x^8 + \ldots + a_9$：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tenpoints2.png" alt="九次函数"></p><p>如果允许一些误差，也可以使用一个简单的线性模型：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tenpoints3.png" alt="线性模型"></p><p>那么，哪个才是更好的模型？哪个才能描述还未出现的新点？实践表明，允许一定误差的模型更符合实际情况。现实世界伴随着大量不确定性，传感器采集的噪声和仪器本身的精度都会给训练集加入一定的<strong>噪声</strong>，这样，后一个模型便在预测新点时占据了优势。</p><p>回到我们的神经网络，当输入因为某些噪声剧烈变化时，较小的权值 $w$ 能够防止网络整体特性改变过大，网络也就不会去“学习”那些没用的噪声信息了。相反，对于手写数字图像那些重复的特征，神经网络在一遍遍的 mini-batch 中，“铭记在心”。</p><p>人们也称这个思想为<strong>奥卡姆剃刀原理</strong>：当两个假说具有完全相同的解释力和预测力时，我们以那个较为简单的假说作为讨论依据。</p><h3 id="其他抑制过拟合的方法"><a href="#其他抑制过拟合的方法" class="headerlink" title="其他抑制过拟合的方法"></a>其他抑制过拟合的方法</h3><p>当然还有很多抑制过拟合的方法，比如：</p><p><strong>$L_1$ 正则化</strong>，即换一个正则函数。</p><p><strong>dropout</strong>：学习过程中随机删去一些神经元。</p><p><strong>人工扩展训练集</strong>：这也是我比较喜欢的一个方法，可以通过平移、缩放、旋转、elastic distortions 等扩展数据集。扩展数据简单粗暴有效，微软研究院的研究员用 elastic distortions 扩展数据后，就将 MNIST 识别率提高到了 99.3%。</p><h2 id="改进权重初始化"><a href="#改进权重初始化" class="headerlink" title="改进权重初始化"></a>改进权重初始化</h2><p>我们在初始化权重和偏移时，选择高斯随机，均值为 0，标准差为 1。权重输入为 $z = \sum_j w_j x_j+b$，随着输入神经元数目的增加，标准差也随之增加，例如 1000 个神经元，其正太分布曲线为</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/gauss1.png" alt="正太分布"></p><p>曲线非常平坦，意味着 $z \gg 1, z \ll -1$ 的可能性都大大增加，输出 $\sigma(z)$ 极有可能饱和，出现过拟合的现象。解决的方法也非常简单，初始化时标准差选为 $1/\sqrt{n_{\rm in}}$。</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/gauss2.png" alt="改进的正太分布"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是 network2.py 的源码（当然我不是写的啦，<a href="http://michaelnielsen.org/" target="_blank" rel="noopener">Michael Nielsen</a> 的杰作），所用技术和算法已在上文逐一阐述。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""network2.py</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">An improved version of network.py, implementing the stochastic</span></span><br><span class="line"><span class="string">gradient descent learning algorithm for a feedforward neural network.</span></span><br><span class="line"><span class="string">Improvements include the addition of the cross-entropy cost function,</span></span><br><span class="line"><span class="string">regularization, and better initialization of network weights.  Note</span></span><br><span class="line"><span class="string">that I have focused on making the code simple, easily readable, and</span></span><br><span class="line"><span class="string">easily modifiable.  It is not optimized, and omits many desirable</span></span><br><span class="line"><span class="string">features.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Libraries</span></span><br><span class="line"><span class="comment"># Standard library</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Third-party libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Define the quadratic and cross-entropy cost functions</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuadraticCost</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(a, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return the cost associated with an output ``a`` and desired output</span></span><br><span class="line"><span class="string">        ``y``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span>*np.linalg.norm(a-y)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delta</span><span class="params">(z, a, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return the error delta from the output layer."""</span></span><br><span class="line">        <span class="keyword">return</span> (a-y) * sigmoid_prime(z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossEntropyCost</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(a, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return the cost associated with an output ``a`` and desired output</span></span><br><span class="line"><span class="string">        ``y``.  Note that np.nan_to_num is used to ensure numerical</span></span><br><span class="line"><span class="string">        stability.  In particular, if both ``a`` and ``y`` have a 1.0</span></span><br><span class="line"><span class="string">        in the same slot, then the expression (1-y)*np.log(1-a)</span></span><br><span class="line"><span class="string">        returns nan.  The np.nan_to_num ensures that that is converted</span></span><br><span class="line"><span class="string">        to the correct value (0.0).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> np.sum(np.nan_to_num(-y*np.log(a)-(<span class="number">1</span>-y)*np.log(<span class="number">1</span>-a)))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delta</span><span class="params">(z, a, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return the error delta from the output layer.  Note that the</span></span><br><span class="line"><span class="string">        parameter ``z`` is not used by the method.  It is included in</span></span><br><span class="line"><span class="string">        the method's parameters in order to make the interface</span></span><br><span class="line"><span class="string">        consistent with the delta method for other cost classes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (a-y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Main Network class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sizes, cost=CrossEntropyCost)</span>:</span></span><br><span class="line">        <span class="string">"""The list ``sizes`` contains the number of neurons in the respective</span></span><br><span class="line"><span class="string">        layers of the network.  For example, if the list was [2, 3, 1]</span></span><br><span class="line"><span class="string">        then it would be a three-layer network, with the first layer</span></span><br><span class="line"><span class="string">        containing 2 neurons, the second layer 3 neurons, and the</span></span><br><span class="line"><span class="string">        third layer 1 neuron.  The biases and weights for the network</span></span><br><span class="line"><span class="string">        are initialized randomly, using</span></span><br><span class="line"><span class="string">        ``self.default_weight_initializer`` (see docstring for that</span></span><br><span class="line"><span class="string">        method).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.num_layers = len(sizes)</span><br><span class="line">        self.sizes = sizes</span><br><span class="line">        self.default_weight_initializer()</span><br><span class="line">        self.cost=cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_weight_initializer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize each weight using a Gaussian distribution with mean 0</span></span><br><span class="line"><span class="string">        and standard deviation 1 over the square root of the number of</span></span><br><span class="line"><span class="string">        weights connecting to the same neuron.  Initialize the biases</span></span><br><span class="line"><span class="string">        using a Gaussian distribution with mean 0 and standard</span></span><br><span class="line"><span class="string">        deviation 1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Note that the first layer is assumed to be an input layer, and</span></span><br><span class="line"><span class="string">        by convention we won't set any biases for those neurons, since</span></span><br><span class="line"><span class="string">        biases are only ever used in computing the outputs from later</span></span><br><span class="line"><span class="string">        layers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.biases = [np.random.randn(y, <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> self.sizes[<span class="number">1</span>:]]</span><br><span class="line">        self.weights = [np.random.randn(y, x)/np.sqrt(x)</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(self.sizes[:<span class="number">-1</span>], self.sizes[<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">large_weight_initializer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize the weights using a Gaussian distribution with mean 0</span></span><br><span class="line"><span class="string">        and standard deviation 1.  Initialize the biases using a</span></span><br><span class="line"><span class="string">        Gaussian distribution with mean 0 and standard deviation 1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Note that the first layer is assumed to be an input layer, and</span></span><br><span class="line"><span class="string">        by convention we won't set any biases for those neurons, since</span></span><br><span class="line"><span class="string">        biases are only ever used in computing the outputs from later</span></span><br><span class="line"><span class="string">        layers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This weight and bias initializer uses the same approach as in</span></span><br><span class="line"><span class="string">        Chapter 1, and is included for purposes of comparison.  It</span></span><br><span class="line"><span class="string">        will usually be better to use the default weight initializer</span></span><br><span class="line"><span class="string">        instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.biases = [np.random.randn(y, <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> self.sizes[<span class="number">1</span>:]]</span><br><span class="line">        self.weights = [np.random.randn(y, x)</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(self.sizes[:<span class="number">-1</span>], self.sizes[<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedforward</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""Return the output of the network if ``a`` is input."""</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">            a = sigmoid(np.dot(w, a)+b)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">(self, training_data, epochs, mini_batch_size, eta,</span></span></span><br><span class="line"><span class="function"><span class="params">            lmbda = <span class="number">0.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            evaluation_data=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_evaluation_cost=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_evaluation_accuracy=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_training_cost=False,</span></span></span><br><span class="line"><span class="function"><span class="params">            monitor_training_accuracy=False)</span>:</span></span><br><span class="line">        <span class="string">"""Train the neural network using mini-batch stochastic gradient</span></span><br><span class="line"><span class="string">        descent.  The ``training_data`` is a list of tuples ``(x, y)``</span></span><br><span class="line"><span class="string">        representing the training inputs and the desired outputs.  The</span></span><br><span class="line"><span class="string">        other non-optional parameters are self-explanatory, as is the</span></span><br><span class="line"><span class="string">        regularization parameter ``lmbda``.  The method also accepts</span></span><br><span class="line"><span class="string">        ``evaluation_data``, usually either the validation or test</span></span><br><span class="line"><span class="string">        data.  We can monitor the cost and accuracy on either the</span></span><br><span class="line"><span class="string">        evaluation data or the training data, by setting the</span></span><br><span class="line"><span class="string">        appropriate flags.  The method returns a tuple containing four</span></span><br><span class="line"><span class="string">        lists: the (per-epoch) costs on the evaluation data, the</span></span><br><span class="line"><span class="string">        accuracies on the evaluation data, the costs on the training</span></span><br><span class="line"><span class="string">        data, and the accuracies on the training data.  All values are</span></span><br><span class="line"><span class="string">        evaluated at the end of each training epoch.  So, for example,</span></span><br><span class="line"><span class="string">        if we train for 30 epochs, then the first element of the tuple</span></span><br><span class="line"><span class="string">        will be a 30-element list containing the cost on the</span></span><br><span class="line"><span class="string">        evaluation data at the end of each epoch. Note that the lists</span></span><br><span class="line"><span class="string">        are empty if the corresponding flag is not set.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> evaluation_data: n_data = len(evaluation_data)</span><br><span class="line">        n = len(training_data)</span><br><span class="line">        evaluation_cost, evaluation_accuracy = [], []</span><br><span class="line">        training_cost, training_accuracy = [], []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(epochs):</span><br><span class="line">            random.shuffle(training_data)</span><br><span class="line">            mini_batches = [</span><br><span class="line">                training_data[k:k+mini_batch_size]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">0</span>, n, mini_batch_size)]</span><br><span class="line">            <span class="keyword">for</span> mini_batch <span class="keyword">in</span> mini_batches:</span><br><span class="line">                self.update_mini_batch(</span><br><span class="line">                    mini_batch, eta, lmbda, len(training_data))</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Epoch %s training complete"</span> % j</span><br><span class="line">            <span class="keyword">if</span> monitor_training_cost:</span><br><span class="line">                cost = self.total_cost(training_data, lmbda)</span><br><span class="line">                training_cost.append(cost)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Cost on training data: &#123;&#125;"</span>.format(cost)</span><br><span class="line">            <span class="keyword">if</span> monitor_training_accuracy:</span><br><span class="line">                accuracy = self.accuracy(training_data, convert=<span class="keyword">True</span>)</span><br><span class="line">                training_accuracy.append(accuracy)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Accuracy on training data: &#123;&#125; / &#123;&#125;"</span>.format(</span><br><span class="line">                    accuracy, n)</span><br><span class="line">            <span class="keyword">if</span> monitor_evaluation_cost:</span><br><span class="line">                cost = self.total_cost(evaluation_data, lmbda, convert=<span class="keyword">True</span>)</span><br><span class="line">                evaluation_cost.append(cost)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Cost on evaluation data: &#123;&#125;"</span>.format(cost)</span><br><span class="line">            <span class="keyword">if</span> monitor_evaluation_accuracy:</span><br><span class="line">                accuracy = self.accuracy(evaluation_data)</span><br><span class="line">                evaluation_accuracy.append(accuracy)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Accuracy on evaluation data: &#123;&#125; / &#123;&#125;"</span>.format(</span><br><span class="line">                    self.accuracy(evaluation_data), n_data)</span><br><span class="line">            <span class="keyword">print</span></span><br><span class="line">        <span class="keyword">return</span> evaluation_cost, evaluation_accuracy, \</span><br><span class="line">            training_cost, training_accuracy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_mini_batch</span><span class="params">(self, mini_batch, eta, lmbda, n)</span>:</span></span><br><span class="line">        <span class="string">"""Update the network's weights and biases by applying gradient</span></span><br><span class="line"><span class="string">        descent using backpropagation to a single mini batch.  The</span></span><br><span class="line"><span class="string">        ``mini_batch`` is a list of tuples ``(x, y)``, ``eta`` is the</span></span><br><span class="line"><span class="string">        learning rate, ``lmbda`` is the regularization parameter, and</span></span><br><span class="line"><span class="string">        ``n`` is the total size of the training data set.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> mini_batch:</span><br><span class="line">            delta_nabla_b, delta_nabla_w = self.backprop(x, y)</span><br><span class="line">            nabla_b = [nb+dnb <span class="keyword">for</span> nb, dnb <span class="keyword">in</span> zip(nabla_b, delta_nabla_b)]</span><br><span class="line">            nabla_w = [nw+dnw <span class="keyword">for</span> nw, dnw <span class="keyword">in</span> zip(nabla_w, delta_nabla_w)]</span><br><span class="line">        self.weights = [(<span class="number">1</span>-eta*(lmbda/n))*w-(eta/len(mini_batch))*nw</span><br><span class="line">                        <span class="keyword">for</span> w, nw <span class="keyword">in</span> zip(self.weights, nabla_w)]</span><br><span class="line">        self.biases = [b-(eta/len(mini_batch))*nb</span><br><span class="line">                       <span class="keyword">for</span> b, nb <span class="keyword">in</span> zip(self.biases, nabla_b)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backprop</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return a tuple ``(nabla_b, nabla_w)`` representing the</span></span><br><span class="line"><span class="string">        gradient for the cost function C_x.  ``nabla_b`` and</span></span><br><span class="line"><span class="string">        ``nabla_w`` are layer-by-layer lists of numpy arrays, similar</span></span><br><span class="line"><span class="string">        to ``self.biases`` and ``self.weights``."""</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="comment"># feedforward</span></span><br><span class="line">        activation = x</span><br><span class="line">        activations = [x] <span class="comment"># list to store all the activations, layer by layer</span></span><br><span class="line">        zs = [] <span class="comment"># list to store all the z vectors, layer by layer</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">            z = np.dot(w, activation)+b</span><br><span class="line">            zs.append(z)</span><br><span class="line">            activation = sigmoid(z)</span><br><span class="line">            activations.append(activation)</span><br><span class="line">        <span class="comment"># backward pass</span></span><br><span class="line">        delta = (self.cost).delta(zs[<span class="number">-1</span>], activations[<span class="number">-1</span>], y)</span><br><span class="line">        nabla_b[<span class="number">-1</span>] = delta</span><br><span class="line">        nabla_w[<span class="number">-1</span>] = np.dot(delta, activations[<span class="number">-2</span>].transpose())</span><br><span class="line">        <span class="comment"># Note that the variable l in the loop below is used a little</span></span><br><span class="line">        <span class="comment"># differently to the notation in Chapter 2 of the book.  Here,</span></span><br><span class="line">        <span class="comment"># l = 1 means the last layer of neurons, l = 2 is the</span></span><br><span class="line">        <span class="comment"># second-last layer, and so on.  It's a renumbering of the</span></span><br><span class="line">        <span class="comment"># scheme in the book, used here to take advantage of the fact</span></span><br><span class="line">        <span class="comment"># that Python can use negative indices in lists.</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> xrange(<span class="number">2</span>, self.num_layers):</span><br><span class="line">            z = zs[-l]</span><br><span class="line">            sp = sigmoid_prime(z)</span><br><span class="line">            delta = np.dot(self.weights[-l+<span class="number">1</span>].transpose(), delta) * sp</span><br><span class="line">            nabla_b[-l] = delta</span><br><span class="line">            nabla_w[-l] = np.dot(delta, activations[-l<span class="number">-1</span>].transpose())</span><br><span class="line">        <span class="keyword">return</span> (nabla_b, nabla_w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy</span><span class="params">(self, data, convert=False)</span>:</span></span><br><span class="line">        <span class="string">"""Return the number of inputs in ``data`` for which the neural</span></span><br><span class="line"><span class="string">        network outputs the correct result. The neural network's</span></span><br><span class="line"><span class="string">        output is assumed to be the index of whichever neuron in the</span></span><br><span class="line"><span class="string">        final layer has the highest activation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The flag ``convert`` should be set to False if the data set is</span></span><br><span class="line"><span class="string">        validation or test data (the usual case), and to True if the</span></span><br><span class="line"><span class="string">        data set is the training data. The need for this flag arises</span></span><br><span class="line"><span class="string">        due to differences in the way the results ``y`` are</span></span><br><span class="line"><span class="string">        represented in the different data sets.  In particular, it</span></span><br><span class="line"><span class="string">        flags whether we need to convert between the different</span></span><br><span class="line"><span class="string">        representations.  It may seem strange to use different</span></span><br><span class="line"><span class="string">        representations for the different data sets.  Why not use the</span></span><br><span class="line"><span class="string">        same representation for all three data sets?  It's done for</span></span><br><span class="line"><span class="string">        efficiency reasons -- the program usually evaluates the cost</span></span><br><span class="line"><span class="string">        on the training data and the accuracy on other data sets.</span></span><br><span class="line"><span class="string">        These are different types of computations, and using different</span></span><br><span class="line"><span class="string">        representations speeds things up.  More details on the</span></span><br><span class="line"><span class="string">        representations can be found in</span></span><br><span class="line"><span class="string">        mnist_loader.load_data_wrapper.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> convert:</span><br><span class="line">            results = [(np.argmax(self.feedforward(x)), np.argmax(y))</span><br><span class="line">                       <span class="keyword">for</span> (x, y) <span class="keyword">in</span> data]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            results = [(np.argmax(self.feedforward(x)), y)</span><br><span class="line">                        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> data]</span><br><span class="line">        <span class="keyword">return</span> sum(int(x == y) <span class="keyword">for</span> (x, y) <span class="keyword">in</span> results)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_cost</span><span class="params">(self, data, lmbda, convert=False)</span>:</span></span><br><span class="line">        <span class="string">"""Return the total cost for the data set ``data``.  The flag</span></span><br><span class="line"><span class="string">        ``convert`` should be set to False if the data set is the</span></span><br><span class="line"><span class="string">        training data (the usual case), and to True if the data set is</span></span><br><span class="line"><span class="string">        the validation or test data.  See comments on the similar (but</span></span><br><span class="line"><span class="string">        reversed) convention for the ``accuracy`` method, above.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cost = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> data:</span><br><span class="line">            a = self.feedforward(x)</span><br><span class="line">            <span class="keyword">if</span> convert: y = vectorized_result(y)</span><br><span class="line">            cost += self.cost.fn(a, y)/len(data)</span><br><span class="line">        cost += <span class="number">0.5</span>*(lmbda/len(data))*sum(</span><br><span class="line">            np.linalg.norm(w)**<span class="number">2</span> <span class="keyword">for</span> w <span class="keyword">in</span> self.weights)</span><br><span class="line">        <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="string">"""Save the neural network to the file ``filename``."""</span></span><br><span class="line">        data = &#123;<span class="string">"sizes"</span>: self.sizes,</span><br><span class="line">                <span class="string">"weights"</span>: [w.tolist() <span class="keyword">for</span> w <span class="keyword">in</span> self.weights],</span><br><span class="line">                <span class="string">"biases"</span>: [b.tolist() <span class="keyword">for</span> b <span class="keyword">in</span> self.biases],</span><br><span class="line">                <span class="string">"cost"</span>: str(self.cost.__name__)&#125;</span><br><span class="line">        f = open(filename, <span class="string">"w"</span>)</span><br><span class="line">        json.dump(data, f)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Loading a Network</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""Load a neural network from the file ``filename``.  Returns an</span></span><br><span class="line"><span class="string">    instance of Network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    f = open(filename, <span class="string">"r"</span>)</span><br><span class="line">    data = json.load(f)</span><br><span class="line">    f.close()</span><br><span class="line">    cost = getattr(sys.modules[__name__], data[<span class="string">"cost"</span>])</span><br><span class="line">    net = Network(data[<span class="string">"sizes"</span>], cost=cost)</span><br><span class="line">    net.weights = [np.array(w) <span class="keyword">for</span> w <span class="keyword">in</span> data[<span class="string">"weights"</span>]]</span><br><span class="line">    net.biases = [np.array(b) <span class="keyword">for</span> b <span class="keyword">in</span> data[<span class="string">"biases"</span>]]</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Miscellaneous functions</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorized_result</span><span class="params">(j)</span>:</span></span><br><span class="line">    <span class="string">"""Return a 10-dimensional unit vector with a 1.0 in the j'th position</span></span><br><span class="line"><span class="string">    and zeroes elsewhere.  This is used to convert a digit (0...9)</span></span><br><span class="line"><span class="string">    into a corresponding desired output from the neural network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    e = np.zeros((<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line">    e[j] = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""The sigmoid function."""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_prime</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""Derivative of the sigmoid function."""</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(z)*(<span class="number">1</span>-sigmoid(z))</span><br></pre></td></tr></table></figure><h2 id="神经网络识别手写数字目录"><a href="#神经网络识别手写数字目录" class="headerlink" title="神经网络识别手写数字目录"></a>神经网络识别手写数字目录</h2><ol><li><a href="http://www.lyyyuna.com/2016/05/29/handwritten-neural-net/">基于 BP 神经网络的识别手写体数字 - 神经网络基础</a></li><li><a href="http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/">基于 BP 神经网络的手写体数字识别 - 设计与实现</a></li><li><a href="http://www.lyyyuna.com/2016/06/26/handwritten-neural-net03/">基于 BP 神经网络的手写体数字识别 - 反向传播算法</a></li><li><a href="http://www.lyyyuna.com/2016/06/30/handwritten-neural-net04/">基于 BP 神经网络的手写体数字识别 - 优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: &quot;AMS&quot; } }
});
&lt;/script&gt;


&lt;p&gt;目前为止，我们论述中，似
      
    
    </summary>
    
      <category term="数学" scheme="http://www.lyyyuna.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
      <category term="mnist" scheme="http://www.lyyyuna.com/tags/mnist/"/>
    
      <category term="neural network" scheme="http://www.lyyyuna.com/tags/neural-network/"/>
    
  </entry>
  
  <entry>
    <title>基于 BP 神经网络的手写体数字识别 - 反向传播算法</title>
    <link href="http://www.lyyyuna.com/2016/06/26/handwritten-neural-net03/"/>
    <id>http://www.lyyyuna.com/2016/06/26/handwritten-neural-net03/</id>
    <published>2016-06-26T01:10:05.000Z</published>
    <updated>2017-11-29T00:19:00.164Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({  TeX: { equationNumbers: { autoNumber: "AMS" } }});</script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/">上一篇文章</a>使用随机梯度下降法实现神经网络自学习的过程。但仍然留有一个问题，如何快速计算代价函数的梯度？这一篇文章将介绍反向传播算法将之解决。</p><p>反向传播算法最初是由 <a href="http://en.wikipedia.org/wiki/David_Rumelhart" target="_blank" rel="noopener">David Rumelhart</a>, <a href="http://www.cs.toronto.edu/~hinton/" target="_blank" rel="noopener">Geoffrey Hinton</a>, 和 <a href="http://en.wikipedia.org/wiki/Ronald_J._Williams" target="_blank" rel="noopener">Ronald Williams</a> 在其 1986 的<a href="http://www.nature.com/nature/journal/v323/n6088/pdf/323533a0.pdf" target="_blank" rel="noopener">论文</a> 中提出的。在该文中，作者将反向传播算法运用到多种神经网络中，其自学习过程都大大加快，并推动了神经网络算法走向实用。今天，反向传播算法可以说是神经网络算法中的“老黄牛”了。</p><p>其实反向传播不仅仅是一个快速算法那么简单，其还揭示了权重和偏移是如何影响网络的行为。</p><h2 id="热身：利用矩阵快速计算神经网络的输出"><a href="#热身：利用矩阵快速计算神经网络的输出" class="headerlink" title="热身：利用矩阵快速计算神经网络的输出"></a>热身：利用矩阵快速计算神经网络的输出</h2><p>在讨论反向传播之前，首先来看一下如何快速计算神经网络的输出。虽然上一篇文章中已经介绍了 feedforward 函数，但还是有必要熟悉反向传播算法中使用的数学符号。</p><p>首先是明确的权重定义。使用 $w^l_{jk}$ 表示权重，代表连接  $(l-1)^{\rm th}$ 层第 $k^{\rm th}$ 个神经元 和 $l^{\rm th}$ 层第 $j^{\rm th}$ 个神经元的权重。举例来说，第二层第四个神经元和第三层第二个神经元之间的权重连接为</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tikz16.png" alt="权重连接"></p><p>对于网络的偏移和激励我们将使用类似的符号。即 $b^l_j$ 是 $l^{\rm th}$ 层第 $j^{\rm th}$ 个神经元的偏移，$a^l_j$ 是 $l^{\rm th}$ 层第 $j^{\rm th}$ 个神经元的激励。如图所示：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tikz17.png" alt="偏移和激励"></p><p>有了这些记号，第 $l^{\rm th}$ 层第 $j^{\rm th}$ 个神经元的激励 $a^l_j$ 可以由第 $(l-1)^{\rm th}$ 层的所有激励求得：</p><p>\begin{eqnarray}<br>  a^{l}_j = \sigma\left( \sum_k w^{l}_{jk} a^{l-1}_k + b^l_j \right),<br>\label{23}<br>\end{eqnarray}</p><p>其中，求和是对第 $(l-1)^{\rm th}$ 层所有的神经元求和。为了将表达式转换成矩阵的形式，这里为每一层 $l$ 定义一个权重矩阵 $w^l$。该矩阵中第 $j^{\rm th}$ 行第 $k^{\rm th}$ 列的元素为 $w^l_{jk}$。类似的，为每一层定义了一个偏移向量 $b^l$，每一个神经元的偏移为 $b^l_j$。最后，我们定义第 $k$ 层所有的激励 $a^l_j$ 的集合为激励向量 $a^l$。</p><p>对于公式 (\ref{23})，我们还需要向量化函数 $\sigma$。因为我们不是将整个矩阵作为一个参数传递给函数，而是对矩阵的每一个元素应用相同的函数，即 $\sigma(v)$ 的元素为 $\sigma(v)_j = \sigma(v_j)$。举例来说，假如我们有一个函数 $f(x)=x^2$，那么函数 $f$ 的向量化是：</p><p>\begin{eqnarray}<br>  f\left(\left[ \begin{array}{c} 2 \ 3 \end{array} \right] \right)<br>  = \left[ \begin{array}{c} f(2) \ f(3) \end{array} \right]<br>  = \left[ \begin{array}{c} 4 \ 9 \end{array} \right],<br>\label{24}<br>\end{eqnarray}</p><p>有了这些，我们将公式 (\ref{23})重写成下列更紧凑的形式：</p><p>\begin{eqnarray}<br>  a^{l} = \sigma(w^l a^{l-1}+b^l).<br>\label{25}<br>\end{eqnarray}</p><p>这个表达式给了我们更全局的视角：本层的激励是如何与上一层的激励相关联的。计算 $a^l$ 时，会计算出中间结构 $z^l \equiv w^l a^{l-1}+b^l$。这一项我们称之为第 $l$ 层的加权输入。$z^l$ 的每一个元素为 $z^l_j= \sum_k w^l_{jk} a^{l-1}_k+b^l_j$，即 $z^l_j$ 是第 $l$ 层第 $j$ 个神经元激励函数的加权输入。公式 (\ref{25}) 有时也会写作 $a^l =\sigma(z^l)$。</p><h2 id="代价函数的两个前提假设"><a href="#代价函数的两个前提假设" class="headerlink" title="代价函数的两个前提假设"></a>代价函数的两个前提假设</h2><p>反向传播算法是为了计算代价函数 $C$ 的两个偏导数 $\partial C / \partial w$ 和 $\partial C / \partial b$。<br>首先看我们的二次代价函数</p><p>\begin{eqnarray}<br>  C = \frac{1}{2n} \sum_x |y(x)-a^L(x)|^2,<br>\label{26}<br>\end{eqnarray}</p><p>其中 $n$ 是训练数据的总数，求和是对每一个数据求和，$y=y(x)$ 是相应的期望输出，$L$ 是网络的总层数，$a^L = a^L(x)$ 是实际的网络输出。</p><p>第一个假设是代价函数可以写作时单个训练数据误差 $C_x =\frac{1}{2} |y-a^L |^2$ 的平均值 $C = \frac{1}{n} \sum_x C_x$。这个假设对于后续介绍的其他代价函数也是成立的。</p><p>之所以这么假设是因为反向传播算法只能够计算单个训练数据的偏导数 $\partial C_x / \partial w$ 和 $\partial C_x / \partial b$。最后对所有数据求平均值得 $\partial C / \partial w$ 和 $\partial C / \partial b$。</p><p>第二个假设是误差可以写作神经网络输出的函数：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tikz18.png" alt="输出的函数"></p><p>例如，二次代价函数就满足这一要求，单个训练数据 $x$ 的二次误差可以写成：</p><p>\begin{eqnarray}<br>  C = \frac{1}{2} |y-a^L|^2 = \frac{1}{2} \sum_j (y_j-a^L_j)^2,<br>\label{27}<br>\end{eqnarray}</p><p>其中，对单个样本来说，$x$ 是定值，期望输出 $y$ 也是定值，唯一的变量就是网络输出 $a^L$，即满足第二条假设。</p><h2 id="反向传播的四个基本公式"><a href="#反向传播的四个基本公式" class="headerlink" title="反向传播的四个基本公式"></a>反向传播的四个基本公式</h2><p>反向传播算法基于最基本的线性代数操作，比如向量相加、向量与矩阵相乘等。其中有一个比较少见，假设 $s$ 和 $t$ 是两个同维的向量，我们定义 $s \odot t$ 为两个向量对应分量的乘积。那么其每个元素为 $(s \odot t)_j = s_jt_j$。例如，</p><p>\begin{eqnarray}<br>\left[\begin{array}{c} 1 \\ 2 \end{array}\right]<br>  \odot \left[\begin{array}{c} 3 \\ 4\end{array} \right]<br>= \left[ \begin{array}{c} 1 \times 3 \\ 2 \times 4 \end{array} \right]<br>= \left[ \begin{array}{c} 3 \\ 8 \end{array} \right].<br>\label{28}<br>\end{eqnarray}</p><p>这种元素对元素的乘积也称作 Hadamard 积或者是 Schur 积。Numpy 对这种运算有着良好的优化。</p><p>然后我们继续引入一个中间变量 $\delta^l_j$，我们称作第 $l$ 层第 $j$ 个神经元的误差。为了形象地理解误差到底是什么，假设在我们的神经网络中有一个小妖精：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/tikz19.png" alt="网络中的小妖精"></p><p>这个妖精坐在 $l$ 层的第 $j$ 个神经元上。当输入到来时，它故意扰乱神经元的正常工作。它在神经元的加权输入中加入了一个小的变化 $\Delta z^l_j$，这样输出变成了 $\sigma(z^l_j+\Delta z^l_j)$。这个变化向后层神经网络传递，最终到输出层导致误差相应地改变为 $\frac{\partial C}{\partial z^l_j} \Delta z^l_j$。</p><p>现在，我们钦定了这个妖精是个好妖精，在试图帮助我们减小误差。当 $\frac{\partial C}{\partial z^l_j}$ 是个很大的正数（负数）时，通过选择 $\Delta z^l_j$ 为负值（正）即可减小误差。但如果 $\frac{\partial C}{\partial z^l_j}$ 接近于零，那么这时这个好妖精无论做什么都对误差结果影响不大，这时可以认为网络接近最优值。</p><p>以上说明 $\frac{\partial C}{\partial z^l_j}$ 是一个可以用来量化神经元误差 的量。所以我们定义</p><p>\begin{eqnarray}<br>  \delta^l_j \equiv \frac{\partial C}{\partial z^l_j}.<br>\label{29}<br>\end{eqnarray}</p><p>你可能会奇怪为什么要引入一个新的中间量–加权输入 $z^l_j$，而不是直接使用激励 $a^l_j$？纯粹是因为这个中间量让最后的反向传播表达式更简洁。</p><p><strong>输出层的误差</strong>，$\delta^L$，该误差分量由下式给出</p><p>\begin{eqnarray}<br>  \delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j).<br>\tag{BP1}\label{BP1}<br>\end{eqnarray}</p><p>这是一个非常自然的表达式，等式右边第一项为 $\partial C / \partial a^L_j$，反映了误差在第 $j$ 个输出激励影响下变化的速度。若某个特定的输出神经元对误差 $C$ 影响不大，则 $\delta^L_j$ 很小。右边第二项为 $\sigma’(z^L_j)$，反应了 $z^L_j$ 对激励函数 $\delta$ 的影响。</p><p>公式 (\ref{BP1}) 非常容易计算。加权输入在 feedforward 正向传播时即可顺便计算，而 sigmoid 激励函数和二次代价函数的偏导也易可得。鉴于 (\ref{BP1}) 是以每个元素的形式给出的，有必要改写成矩阵的形式：</p><p>\begin{eqnarray}<br>  \delta^L = \nabla_a C \odot \sigma’(z^L).<br>\tag{BP1a}\label{BP1a}<br>\end{eqnarray}</p><p>这里，$\nabla_a C$ 是偏导数 $\partial C / \partial a^L_j$ 组成的向量。你可以认为 $\nabla_a C$ 反映了误差相对于输出激励的变化。由二次代价函数 $C = \frac{1}{2} \sum_j (y_j-a_j)^2$ 的偏导数 $\partial C / \partial a^L_j = (a_j-y_j)$ 可得：$\nabla_a C =(a^L-y)$。最终公式 (\ref{BP1}) 变成</p><p>\begin{eqnarray}<br>  \delta^L = (a^L-y) \odot \sigma’(z^L).<br>\label{30}\end{eqnarray}</p><p><strong>通过下一层误差可以求本层误差</strong>，即</p><p>\begin{eqnarray}<br>  \delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l),<br>\tag{BP2}\label{BP2}<br>\end{eqnarray}</p><p>初看上去这个公式有点复杂，但其意义显而易见。$l+1$ 层的误差 $\delta^{l+1}$，通过权重矩阵的转置 $(w^{l+1})^T$ 反向转播到第 $l$ 层，然后与 $\sigma’(z^l)$ 做 Hadamard 积即可求得 $l$ 层的误差。</p><p>通过公式 (\ref{BP1}) 和公式 (\ref{BP2}) 的组合，每一层的误差都能求得。</p><p><strong>误差相对于偏移的变化率</strong>，即偏导数为</p><p>\begin{eqnarray}  \frac{\partial C}{\partial b^l_j} =<br>  \delta^l_j.<br>\tag{BP3}\label{BP3}<br>\end{eqnarray}</p><p>这意味着其偏导数就是误差的值本身，我们也可以简写为</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial b} = \delta,<br>\label{31}<br>\end{eqnarray}</p><p><strong>误差相对于权重的变化率</strong>，即偏导数为</p><p>\begin{eqnarray}<br>  \frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j.<br>\tag{BP4}\label{BP4}<br>\end{eqnarray}</p><p>这意味着我们可以通过上一层的激励和本层的误差来求取偏导数，我们也可以简写为</p><p>\begin{eqnarray}<br>\frac{\partial C}{\partial w} = a_{\rm in} \delta_{\rm out},<br>\label{32}<br>\end{eqnarray}</p><p>上一层的激励如果接近于零，$a_{\rm in} \approx 0$，那么 $\partial C / \partial w$ 也会非常小，这种情况下，权重的自学习速度减慢了。</p><h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p>由公式 (\ref{BP1})-(\ref{BP4}) 即可得反向传播算法的步骤如下：</p><p><strong>首先，输入一个 mini-batch 量的训练数据。</strong></p><p><strong>然后，对每一个训练数据 $x$ 施加以下步骤：</strong></p><ol><li><strong>正向传播</strong>：对每一层 $l=2,3,…,L$ 计算 $z^{x,l} = w^l a^{x,l-1}+b^l$ 和 $a^{x,l} = \sigma(z^{x,l})$。</li><li><strong>计算最后一层误差</strong> $\delta^{x,L}$：计算向量 $\delta^{x,L} = \nabla_a C_x \odot \sigma’(z^{x,L})$。</li><li><strong>反向传播误差</strong>：对每一层 $l=L-1,L-2,…,2$ 计算 $\delta^{x,l} = ((w^{l+1})^T \delta^{x,l+1})\odot \sigma’(z^{x,l})$。</li></ol><p><strong>最后，为这个 mini-batch 中的训练数据计算下降的梯度：</strong>对于每一层 $l=L,L-1,…,2$ 更新权重和偏移 $w^l \rightarrow w^l-\frac{\eta}{m} \sum_x \delta^{x,l} (a^{x,l-1})^T, b^l \rightarrow b^l-\frac{\eta}{m}\sum_x \delta^{x,l}$。</p><p>写成代码即为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backprop</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">     <span class="string">"""Return a tuple "(nabla_b, nabla_w)" representing the</span></span><br><span class="line"><span class="string">     gradient for the cost function C_x.  "nabla_b" and</span></span><br><span class="line"><span class="string">     "nabla_w" are layer-by-layer lists of numpy arrays, similar</span></span><br><span class="line"><span class="string">     to "self.biases" and "self.weights"."""</span></span><br><span class="line">     nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">     nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">     <span class="comment"># feedforward</span></span><br><span class="line">     activation = x</span><br><span class="line">     activations = [x] <span class="comment"># list to store all the activations, layer by layer</span></span><br><span class="line">     zs = [] <span class="comment"># list to store all the z vectors, layer by layer</span></span><br><span class="line">     <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">         z = np.dot(w, activation)+b</span><br><span class="line">         zs.append(z)</span><br><span class="line">         activation = sigmoid(z)</span><br><span class="line">         activations.append(activation)</span><br><span class="line">     <span class="comment"># backward pass</span></span><br><span class="line">     delta = self.cost_derivative(activations[<span class="number">-1</span>], y) * \</span><br><span class="line">         sigmoid_prime(zs[<span class="number">-1</span>])</span><br><span class="line">     nabla_b[<span class="number">-1</span>] = delta</span><br><span class="line">     nabla_w[<span class="number">-1</span>] = np.dot(delta, activations[<span class="number">-2</span>].transpose())</span><br><span class="line">     <span class="comment"># Note that the variable l in the loop below is used a little</span></span><br><span class="line">     <span class="comment"># differently to the notation in Chapter 2 of the book.  Here,</span></span><br><span class="line">     <span class="comment"># l = 1 means the last layer of neurons, l = 2 is the</span></span><br><span class="line">     <span class="comment"># second-last layer, and so on.  It's a renumbering of the</span></span><br><span class="line">     <span class="comment"># scheme in the book, used here to take advantage of the fact</span></span><br><span class="line">     <span class="comment"># that Python can use negative indices in lists.</span></span><br><span class="line">     <span class="keyword">for</span> l <span class="keyword">in</span> xrange(<span class="number">2</span>, self.num_layers):</span><br><span class="line">         z = zs[-l]</span><br><span class="line">         sp = sigmoid_prime(z)</span><br><span class="line">         delta = np.dot(self.weights[-l+<span class="number">1</span>].transpose(), delta) * sp</span><br><span class="line">         nabla_b[-l] = delta</span><br><span class="line">         nabla_w[-l] = np.dot(delta, activations[-l<span class="number">-1</span>].transpose())</span><br><span class="line">     <span class="keyword">return</span> (nabla_b, nabla_w)</span><br></pre></td></tr></table></figure><h2 id="神经网络识别手写数字目录"><a href="#神经网络识别手写数字目录" class="headerlink" title="神经网络识别手写数字目录"></a>神经网络识别手写数字目录</h2><ol><li><a href="http://www.lyyyuna.com/2016/05/29/handwritten-neural-net/">基于 BP 神经网络的识别手写体数字 - 神经网络基础</a></li><li><a href="http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/">基于 BP 神经网络的手写体数字识别 - 设计与实现</a></li><li><a href="http://www.lyyyuna.com/2016/06/26/handwritten-neural-net03/">基于 BP 神经网络的手写体数字识别 - 反向传播算法</a></li><li><a href="http://www.lyyyuna.com/2016/06/30/handwritten-neural-net04/">基于 BP 神经网络的手写体数字识别 - 优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: &quot;AMS&quot; } }
});
&lt;/script&gt;


&lt;h2 id=&quot;前言&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="数学" scheme="http://www.lyyyuna.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
      <category term="mnist" scheme="http://www.lyyyuna.com/tags/mnist/"/>
    
      <category term="neural network" scheme="http://www.lyyyuna.com/tags/neural-network/"/>
    
  </entry>
  
  <entry>
    <title>基于 BP 神经网络的手写体数字识别 - 设计与实现</title>
    <link href="http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/"/>
    <id>http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/</id>
    <published>2016-06-25T09:56:33.000Z</published>
    <updated>2017-11-29T00:19:00.163Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({  TeX: { equationNumbers: { autoNumber: "AMS" } }});</script><h2 id="手写体数字识别的神经网络结构"><a href="#手写体数字识别的神经网络结构" class="headerlink" title="手写体数字识别的神经网络结构"></a>手写体数字识别的神经网络结构</h2><p><a href="http://www.lyyyuna.com/2016/05/29/handwritten-neural-net/">上一篇文章</a>中我们简单介绍了神经网络，接下来让我们运用到主题中 —— 手写体数字识别。</p><p>手写数字识别可以分为两大子问题。第一是如何将一串数字分割成单个的数字，第二是识别单个数字。我们将专注于解决第二个问题，因为分割问题并不难，而且和我们的主题——神经网络相差甚远。</p><p>为了识别单个的数字，我们将使用三层神经网络：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/three-layers.png" alt="三层神经网络"></p><p>输入层的神经元将对输入的像素值编码。神经网络的训练数据包含了 $28 \times 28$ 像素的扫描图，所以输入层有 $784 = 28 \times 28$ 个神经元。为了简便起见，上图中没有 $784$ 个输入神经元全部画出。每一个像素是灰度值，$0.0$ 代表白色，$1.0$ 代表黑色，两者之间的为逐渐变黑的灰色。</p><p>第二层是隐藏层。让我们记隐藏层的神经元数量为 $n$，我们将对 $n$ 的不同值实验。上图中，$n=15$。</p><p>输出层包含 $10$ 个神经元。如果第一个输出被激活了，即 $\mbox{output} \approx 1$，意味着神经网络判定当前数字为 $0$。如果第二个输出神经元被激活，则神经网络认为当前数字很有可能为 $1$。以此类推。最后对 $10$ 个输出神经元进行排序，哪个最高说明神经网络认为其最有可能。比如第 $6$ 个神经元输出最高，则输入图像最有可能是数字 $6$。</p><p>你可能会想为什么会用十个输出神经元？毕竟我们的目标是判断出每一个图片对应的数字，理论上，四个输出的组合就可以编码，$2^4 = 16$ 完全可以包含 $10$ 个值。要回答这个问题还是得靠实验：我们对两种输出编码方案都做了实验，用 $10$ 个输出的效果更好。让我们做一个启发式的思考，用四个 bit 来唯一确定一个数字，意味着得百分百识别出图像，说一不二。而有些时候字确实写的难以辨认，连人类自己都只能说‘大概是 4 或者 9’这种话，这时候，给出 $10$ 个数字的概率更符合人脑的思维方式。</p><h2 id="基于梯度下降法学习"><a href="#基于梯度下降法学习" class="headerlink" title="基于梯度下降法学习"></a>基于梯度下降法学习</h2><p>现在我们已经设计出神经网络的结构了，那如何识别出数字呢？第一件事是找到训练集。我们将使用 <a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST 数据集</a>。MNIST 是经过修改的 <a href="http://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology" target="_blank" rel="noopener">NIST</a> 数据子集，NIST 即 United States’ National Institute of Standards and Technology。以下是部分数据：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/some-samples.png" alt="部分数据"></p><p>图像已经被分割成单个的数字，而且没有噪点等，不需要做图像预处理。MNIST 数据集包括两部分，第一部分包含 60000 个图像，被用作训练数据。这些图像来自 250 个人，半数来自美国人口普查局的员工，另外半数是高中生。图片是 $28 \times 28$ 的灰度图。第二部分是 10000 张图片的测试集。我们将使用测试集来评估人工神经网络的学习效果。为了取得更好的测试效果，测试集来自另外 250 个人。这样，测试集和训练集的完全不同能够更好验证结果。</p><p>我们将使用 $x$ 来标记训练输入。虽然图片是一个二维数组，不过我们输入会采用 $28 \times 28 = 784$ 的向量。向量中的每一项为图片每一个像素的灰度值。输出我们将记为输出向量 $y = y(x)$。如果一个训练图片是数字 6，则 $y(x) = (0, 0, 0, 0, 0, 0, 1, 0, 0, 0)^\mathrm{T}$。请注意，$\mathrm{T}$ 是转置操作。</p><p>算法的目标是找到权重和偏移，对于所有训练输入 $x$，网络都能够输出正确的 $y(x)$。为了量化我们与目标的接近程度，定义以下的代价函数：</p><p>\begin{eqnarray}  C(w,b) \equiv<br>  \frac{1}{2n} \sum_x | y(x) - a|^2.  \label{6}<br>\end{eqnarray}</p><p>这里，记 $w$ 为网络所有的权重集，$b$ 为所有的偏移，$n$ 为训练输入的总数，$a$ 为实际的输出向量，求和是对所有训练输入而言。当然，$a$ 应该是 $x,w,b$ 的函数。记号 $| v |$ 为向量 $v$ 的长度。我们称 $C$ 为二次代价函数，其实就是均方差啦， MSE (mean squared error)。可以看出，该代价函数为非负值，并且，当所有训练数据的 $y(x)$ 接近实际输出 $a$ 时，代价函数 $C(w,b) \approx 0$。所以，当神经网络工作良好的时候，$C(w,b)$ 很小，相反，该值会很大，即训练集中有很大一部分预期输出 $y(x)$ 和实际输出 $a$ 不符。我们训练算法的目标，就是找到一组权重和偏移，让误差尽可能的小。</p><p>为什么会用二次函数误差？毕竟我们感兴趣的是能被正确分类的图片数量。为什么不直接以图片数量为目标，比如目标是识别的数量最大化？问题是，正确分类图像的数量不是权值和偏置的光滑函数，大部分情况下，变量的变化不会导致识别数量的变化，也就难以调整权重和偏移。</p><p>你可能还会好奇，二次函数是最好的选择吗？其他的代价函数会不会得到完全不同的权值和偏移，效果更好呢？事实上，确实有更好的代价函数，以后的文章还会继续探讨。不过，本文继续使用二次函数，它对我们理解神经网络的基本自学习过程非常有益。</p><p>接下来，我们介绍梯度下降法，它可以用来解决最小化问题。</p><p>假设我们要最小化函数 $C(v), v=v_1,v_2$。该函数图像为：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/func_plot.png" alt="函数图像"></p><p>我们要找到 $C$ 的全局最小值。一种做法是计算函数的导数，找到各个极值。课本上的导数很好求解。不幸的是，现实生活中，问题所代表的函数经常包含过多的变量。尤其是神经网络中，有数以万计的权值和偏移，不可能直接求取极值。</p><p>幸好还有其他方法。让我们换种思维方式，对比那个函数图像，将函数看作一个山谷，并假设有一个小球沿着山谷斜坡滑动。直觉告诉我们小球最终会滑向坡底。也许这就能用来找到最小值？我们为“小球”随机选择一个起点，然后模拟“小球”沿斜坡滑动。“小球”运动的方向可以通过偏导数确定，这些偏导数包含了山谷形状的信息。</p><p>是否需要牛顿力学公式来获取小球的运动，考虑摩擦力和重力呢？并不需要，我们是在制定一个最小化 $C$ 的算法，而不是去精确模拟物理学规律。</p><p>让我们记球在 $v_1$ 方向移动了很小的量 $\Delta v_1$，在 $v_2$ 的方向移动了 $\Delta v_2$，总的 $C$ 的改变量为：</p><p>\begin{eqnarray}<br>  \Delta C \approx \frac{\partial C}{\partial v_1} \Delta v_1 +<br>  \frac{\partial C}{\partial v_2} \Delta v_2.<br>\label{7}<br>\end{eqnarray}</p><p>我们目标是找到一组 $\Delta v_1$ 和 $\Delta v_2$，使 $\Delta C$ 为负，即使球向谷底滚去。接下来记 $\Delta v \equiv (\Delta v_1, \Delta v_2)^T$ 为 $v$ 的总变化，并且记梯度向量 $\nabla C$ 为：</p><p>\begin{eqnarray}<br>  \nabla C \equiv \left( \frac{\partial C}{\partial v_1},<br>  \frac{\partial C}{\partial v_2} \right)^T.<br>\label{8}<br>\end{eqnarray}</p><p>其中梯度向量符号 $\nabla C$ 会比较抽象，因为它纯粹就是一个数学上的概念。有了梯度符号，我们可以将式 (\ref{8}) 改写为</p><p>\begin{eqnarray}<br>  \Delta C \approx \nabla C \cdot \Delta v.<br>\label{9}<br>\end{eqnarray}</p><p>从该式可以看出，梯度向量 $\nabla C$ 将 $v$ 的变化反应到 $C$ 中，且我们也找到了如何让 $\Delta C$ 为负的方法。尤其是当我们选择</p><p>\begin{eqnarray}<br>  \Delta v = -\eta \nabla C,<br>\label{10}<br>\end{eqnarray}</p><p>当 $\eta$ 是一个很小的正参数时（其实该参数就是学习率），公式 (\ref{9}) 表明 $\Delta C \approx -\eta\nabla C \cdot \nabla C = -\eta |\nabla C|^2$。因为 $| \nabla C|^2 \geq 0$，能保证 $\Delta C \leq 0$。这正是我们需要的特性！在梯度下降学习法中，我们使用公式 (\ref{10}) 计算 $\Delta v$，然后移动球到新的位置：</p><p>\begin{eqnarray}<br>  v \rightarrow v’ = v -\eta \nabla C.<br>\label{11}<br>\end{eqnarray}</p><p>然后不停使用这一公式计算下一步，直到 $C$ 不再减小为止，即找到了全局最小值。</p><p>总结一下，首先重复计算梯度 $\nabla C$，然后向相反方向移动，画成图就是</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201606/gradient.png" alt="梯度学习法"></p><p>请注意，上述梯度下降的规则并没有复制出真正的物理运动。在真实生活中，球有动量，滚向谷底后还会继续滚上去，在摩擦力的作用下才会最终停下。但我们的算法中没这么复杂。</p><p>为了使算法正常工作，公式 (\ref{9}) 中的学习率 $\eta$ 要尽可能的小，不然最终可能 $\Delta C &gt; 0$。同时学习率不能过小，不然会导致每一次迭代中 $\Delta v$ 过小，算法工作会非常慢。</p><p>尽管到现在我们一直用两个变量的函数 $C$ 举例。但其实对于多变量的函数，这仍是适用的。假设 $C$ 有 $m$ 个变量，$v_1,…, v_m$，那么变化 $\Delta C$ 为</p><p>\begin{eqnarray}<br>  \Delta C \approx \nabla C \cdot \Delta v,<br>\label{12}<br>\end{eqnarray}</p><p>其中 $\Delta v = (\Delta v_1,\ldots, \Delta v_m)^T$，梯度向量 $\nabla C$ 为</p><p>\begin{eqnarray}<br>  \nabla C \equiv \left(\frac{\partial C}{\partial v_1}, \ldots,<br>  \frac{\partial C}{\partial v_m}\right)^T.<br>\label{13}<br>\end{eqnarray}</p><p>梯度下降法虽然简单，但实际上很有效，也是一个经典的最优化方法，在神经网络中我们将用它来寻找代价函数的最小值。</p><p>同时，人们研究了大量梯度下降法的变种，包括去模拟真实的物理学，但都效果不好。因为这些变种算法不光计算一次偏导数，还需要计算二次偏导，这对计算机来说是巨大的挑战，尤其是有着上百万神经元的神经网络。</p><p>我们将使用梯度下降法来来找到权重 $w_k$ 和偏移 $b_l$。类比上述的梯度法，这里变量 $v_j$ 即为权重和偏移，而梯度 $\nabla C$ 为 $\partial C / \partial w_k$ 和 $\partial C/ \partial b_l$。梯度下降的更新规则如下：</p><p>\begin{eqnarray}<br>  w_k &amp; \rightarrow &amp; w_k’ = w_k-\eta \frac{\partial C}{\partial w_k} \label{16}\\<br>  b_l &amp; \rightarrow &amp; b_l’ = b_l-\eta \frac{\partial C}{\partial b_l}.<br>\label{17}<br>\end{eqnarray}</p><p>重复上述规则，找到代价函数的最小值，实现神经网络的自学习。</p><p>在适用梯度下降法时仍有一些挑战，比如公式 (\ref{6}) 中代价函数是每一个训练样本的误差 $C_x \equiv \frac{|y(x)-a|^2}{2}$ 的平均值。这意味着计算梯度时，需要每一个训练样本计算梯度。当样本数量很多时，就会造成性能的问题。</p><p>随机梯度下降法能够解决这一问题，加速学习过程。算法每次随机从训练输入中选取 $m$ 个数据，$X_1, X_2,\ldots, X_m $，记为 mini-batch。当 $m$ 足够大时，$\nabla C_{X_j}$ 将十分接近所有样本的平均值 $\nabla C_x$，即</p><p>\begin{eqnarray}<br>  \frac{\sum_{j=1}^m \nabla C_{X_{j}}}{m} \approx \frac{\sum_x \nabla C_x}{n} = \nabla C,<br>\label{18}<br>\end{eqnarray}</p><p>交换等式两边得</p><p>\begin{eqnarray}<br>  \nabla C \approx \frac{1}{m} \sum_{j=1}^m \nabla C_{X_{j}},<br>\label{19}<br>\end{eqnarray}</p><p>这样，我们把总体的梯度转换成计算随机选取的 mini-batch 的梯度。将随机梯度下降法运用到神经网络中，则权重和偏移为</p><p>\begin{eqnarray}<br>  w_k  \rightarrow &amp; w_k’ = w_k-\frac{\eta}{m}  \sum_j \frac{\partial C_{X_j}}{\partial w_k}<br>\label{20}<br>\end{eqnarray}</p><p>\begin{eqnarray}<br>  b_l  \rightarrow &amp; b_l’ = b_l-\frac{\eta}{m}  \sum_j \frac{\partial C_{X_j}}{\partial b_l},<br>\label{21}<br>\end{eqnarray}</p><p>其中，求和是对当前 mini-batch 中训练样本 $X_j$ 求和。然后选取下一组 mini-batch 重复上述过程，直到所有的训练输入全部选取完成，训练的一个 epoch 完成。<br>接着我们可以开始一个新的 epoch。</p><p>对于 MNIST 数据集来说，一共有 $n=60000$ 个数据，如果选择 mini-batch 的大小 $m=10$，则计算梯度的速度可以比原先快 $6000$ 倍。当然，加速计算的结果只是近似值，尽管会有一些统计学上的波动，但精确的梯度计算并不重要，只要小球下降的大方向不错就行。为什么我敢这么说，因为实践证明了啊，随机梯度也是大多数自学习算法的基石。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们将官方的 MNIST 数据分成三部分，50000 个训练集，10000 个验证集，10000 个测试集。验证集用于在训练过程中实时观察神经网络正确率的变化，测试集用于测试最终神经网络的正确率。</p><p>下面介绍一下代码的核心部分。首先是 Network 类的初始化部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sizes)</span>:</span></span><br><span class="line">        self.num_layers = len(sizes)</span><br><span class="line">        self.sizes = sizes</span><br><span class="line">        self.biases = [np.random.randn(y, <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> sizes[<span class="number">1</span>:]]</span><br><span class="line">        self.weights = [np.random.randn(y, x) </span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(sizes[:<span class="number">-1</span>], sizes[<span class="number">1</span>:])]</span><br></pre></td></tr></table></figure><p>列表 sizes 表示神经网络每一层所包含的神经元个数。比如我们想创建一个 2 个输入神经元，3 个神经元在中间层，一个输出神经元的网络，那么可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net = Network([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>偏移和权重都是使用 np.random.randn 函数随机初始化的，平均值为 0，标准差为 1。这种随机初始化并不是最佳方案，后续文章会逐步优化。</p><p>请注意，偏移和权重被初始化为 Numpy 矩阵。net.weights[1] 代表连接第二和第三层神经元的权重。</p><p>下面是 sigmoid 函数的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-z))</span><br></pre></td></tr></table></figure><p>注意到虽然输入 $z$ 是向量，但 Numpy 能够自动处理，为向量中的每一个元素作相同的 sigmoid 运算。</p><p>然后是计算 sigmoid 函数的导数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_prime</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""Derivative of the sigmoid function."""</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(z)*(<span class="number">1</span>-sigmoid(z))</span><br></pre></td></tr></table></figure><p>每一层相对于前一层的输出为</p><p>\begin{eqnarray}<br>  a’ = \sigma(w a + b).<br>\label{22}<br>\end{eqnarray}</p><p>对应的是 feedforward 函数当：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feedforward</span><span class="params">(self, a)</span>:</span></span><br><span class="line">    <span class="string">"""Return the output of the network if "a" is input."""</span></span><br><span class="line">    <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">        a = sigmoid(np.dot(w, a)+b)</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>当然，Network 对象最重要的任务还是自学习。下面的 SGD 函数实现了随机梯度下降法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">(self, training_data, epochs, mini_batch_size, eta,</span></span></span><br><span class="line"><span class="function"><span class="params">        test_data=None)</span>:</span></span><br><span class="line">    <span class="string">"""Train the neural network using mini-batch stochastic</span></span><br><span class="line"><span class="string">    gradient descent.  The "training_data" is a list of tuples</span></span><br><span class="line"><span class="string">    "(x, y)" representing the training inputs and the desired</span></span><br><span class="line"><span class="string">    outputs.  The other non-optional parameters are</span></span><br><span class="line"><span class="string">    self-explanatory.  If "test_data" is provided then the</span></span><br><span class="line"><span class="string">    network will be evaluated against the test data after each</span></span><br><span class="line"><span class="string">    epoch, and partial progress printed out.  This is useful for</span></span><br><span class="line"><span class="string">    tracking progress, but slows things down substantially."""</span></span><br><span class="line">    <span class="keyword">if</span> test_data: n_test = len(test_data)</span><br><span class="line">    n = len(training_data)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(epochs):</span><br><span class="line">        random.shuffle(training_data)</span><br><span class="line">        mini_batches = [</span><br><span class="line">            training_data[k:k+mini_batch_size]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">0</span>, n, mini_batch_size)]</span><br><span class="line">        <span class="keyword">for</span> mini_batch <span class="keyword">in</span> mini_batches:</span><br><span class="line">            self.update_mini_batch(mini_batch, eta)</span><br><span class="line">        <span class="keyword">if</span> test_data:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Epoch &#123;0&#125;: &#123;1&#125; / &#123;2&#125;"</span>.format(</span><br><span class="line">                j, self.evaluate(test_data), n_test)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Epoch &#123;0&#125; complete"</span>.format(j)</span><br></pre></td></tr></table></figure><p>列表 training_data 是由 (x,y) 元组构成，代表训练集的输入和期望输出。而 test_data 则是验证集（非测试集，这里变量名有些歧义），在每一个 epoch 结束时对神经网络正确率做一下检测。其他变量的含义比较显见，不再赘述。</p><p>SGD 函数在每一个 epoch 开始时随机打乱训练集，然后按照 mini-batch 的大小对数据分割。在每一步中对一个 mini_batch 计算梯度，在 self.update_mini_batch(mini_batch, eta) 更新权重和偏移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_mini_batch</span><span class="params">(self, mini_batch, eta)</span>:</span></span><br><span class="line">    <span class="string">"""Update the network's weights and biases by applying</span></span><br><span class="line"><span class="string">    gradient descent using backpropagation to a single mini batch.</span></span><br><span class="line"><span class="string">    The "mini_batch" is a list of tuples "(x, y)", and "eta"</span></span><br><span class="line"><span class="string">    is the learning rate."""</span></span><br><span class="line">    nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">    nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> mini_batch:</span><br><span class="line">        delta_nabla_b, delta_nabla_w = self.backprop(x, y)</span><br><span class="line">        nabla_b = [nb+dnb <span class="keyword">for</span> nb, dnb <span class="keyword">in</span> zip(nabla_b, delta_nabla_b)]</span><br><span class="line">        nabla_w = [nw+dnw <span class="keyword">for</span> nw, dnw <span class="keyword">in</span> zip(nabla_w, delta_nabla_w)]</span><br><span class="line">    self.weights = [w-(eta/len(mini_batch))*nw </span><br><span class="line">                    <span class="keyword">for</span> w, nw <span class="keyword">in</span> zip(self.weights, nabla_w)]</span><br><span class="line">    self.biases = [b-(eta/len(mini_batch))*nb </span><br><span class="line">                   <span class="keyword">for</span> b, nb <span class="keyword">in</span> zip(self.biases, nabla_b)]</span><br></pre></td></tr></table></figure><p>其中最关键的是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta_nabla_b, delta_nabla_w = self.backprop(x, y)</span><br></pre></td></tr></table></figure><p>这就是反向转播算法，这是一个快速计算代价函数梯度的方法。所以 update_mini_batch 仅仅是计算这些梯度，然后用来更新 self.weights 和 self.biases。这里暂时不介绍它，它牵涉较多内容，下一篇文章会重点阐述。</p><p>让我们看一下 <a href="https://github.com/mnielsen/neural-networks-and-deep-learning/tree/master/src" target="_blank" rel="noopener">完整的程序</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### Libraries</span></span><br><span class="line"><span class="comment"># Standard library</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># Third-party libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sizes)</span>:</span></span><br><span class="line">        <span class="string">"""The list ``sizes`` contains the number of neurons in the</span></span><br><span class="line"><span class="string">        respective layers of the network.  For example, if the list</span></span><br><span class="line"><span class="string">        was [2, 3, 1] then it would be a three-layer network, with the</span></span><br><span class="line"><span class="string">        first layer containing 2 neurons, the second layer 3 neurons,</span></span><br><span class="line"><span class="string">        and the third layer 1 neuron.  The biases and weights for the</span></span><br><span class="line"><span class="string">        network are initialized randomly, using a Gaussian</span></span><br><span class="line"><span class="string">        distribution with mean 0, and variance 1.  Note that the first</span></span><br><span class="line"><span class="string">        layer is assumed to be an input layer, and by convention we</span></span><br><span class="line"><span class="string">        won't set any biases for those neurons, since biases are only</span></span><br><span class="line"><span class="string">        ever used in computing the outputs from later layers."""</span></span><br><span class="line">        self.num_layers = len(sizes)</span><br><span class="line">        self.sizes = sizes</span><br><span class="line">        self.biases = [np.random.randn(y, <span class="number">1</span>) <span class="keyword">for</span> y <span class="keyword">in</span> sizes[<span class="number">1</span>:]]</span><br><span class="line">        self.weights = [np.random.randn(y, x)</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(sizes[:<span class="number">-1</span>], sizes[<span class="number">1</span>:])]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feedforward</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""Return the output of the network if ``a`` is input."""</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">            a = sigmoid(np.dot(w, a)+b)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">(self, training_data, epochs, mini_batch_size, eta,</span></span></span><br><span class="line"><span class="function"><span class="params">            test_data=None)</span>:</span></span><br><span class="line">        <span class="string">"""Train the neural network using mini-batch stochastic</span></span><br><span class="line"><span class="string">        gradient descent.  The ``training_data`` is a list of tuples</span></span><br><span class="line"><span class="string">        ``(x, y)`` representing the training inputs and the desired</span></span><br><span class="line"><span class="string">        outputs.  The other non-optional parameters are</span></span><br><span class="line"><span class="string">        self-explanatory.  If ``test_data`` is provided then the</span></span><br><span class="line"><span class="string">        network will be evaluated against the test data after each</span></span><br><span class="line"><span class="string">        epoch, and partial progress printed out.  This is useful for</span></span><br><span class="line"><span class="string">        tracking progress, but slows things down substantially."""</span></span><br><span class="line">        <span class="keyword">if</span> test_data: n_test = len(test_data)</span><br><span class="line">        n = len(training_data)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(epochs):</span><br><span class="line">            random.shuffle(training_data)</span><br><span class="line">            mini_batches = [</span><br><span class="line">                training_data[k:k+mini_batch_size]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">0</span>, n, mini_batch_size)]</span><br><span class="line">            <span class="keyword">for</span> mini_batch <span class="keyword">in</span> mini_batches:</span><br><span class="line">                self.update_mini_batch(mini_batch, eta)</span><br><span class="line">            <span class="keyword">if</span> test_data:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Epoch &#123;0&#125;: &#123;1&#125; / &#123;2&#125;"</span>.format(</span><br><span class="line">                    j, self.evaluate(test_data), n_test)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Epoch &#123;0&#125; complete"</span>.format(j)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_mini_batch</span><span class="params">(self, mini_batch, eta)</span>:</span></span><br><span class="line">        <span class="string">"""Update the network's weights and biases by applying</span></span><br><span class="line"><span class="string">        gradient descent using backpropagation to a single mini batch.</span></span><br><span class="line"><span class="string">        The ``mini_batch`` is a list of tuples ``(x, y)``, and ``eta``</span></span><br><span class="line"><span class="string">        is the learning rate."""</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> mini_batch:</span><br><span class="line">            delta_nabla_b, delta_nabla_w = self.backprop(x, y)</span><br><span class="line">            nabla_b = [nb+dnb <span class="keyword">for</span> nb, dnb <span class="keyword">in</span> zip(nabla_b, delta_nabla_b)]</span><br><span class="line">            nabla_w = [nw+dnw <span class="keyword">for</span> nw, dnw <span class="keyword">in</span> zip(nabla_w, delta_nabla_w)]</span><br><span class="line">        self.weights = [w-(eta/len(mini_batch))*nw</span><br><span class="line">                        <span class="keyword">for</span> w, nw <span class="keyword">in</span> zip(self.weights, nabla_w)]</span><br><span class="line">        self.biases = [b-(eta/len(mini_batch))*nb</span><br><span class="line">                       <span class="keyword">for</span> b, nb <span class="keyword">in</span> zip(self.biases, nabla_b)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backprop</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return a tuple ``(nabla_b, nabla_w)`` representing the</span></span><br><span class="line"><span class="string">        gradient for the cost function C_x.  ``nabla_b`` and</span></span><br><span class="line"><span class="string">        ``nabla_w`` are layer-by-layer lists of numpy arrays, similar</span></span><br><span class="line"><span class="string">        to ``self.biases`` and ``self.weights``."""</span></span><br><span class="line">        nabla_b = [np.zeros(b.shape) <span class="keyword">for</span> b <span class="keyword">in</span> self.biases]</span><br><span class="line">        nabla_w = [np.zeros(w.shape) <span class="keyword">for</span> w <span class="keyword">in</span> self.weights]</span><br><span class="line">        <span class="comment"># feedforward</span></span><br><span class="line">        activation = x</span><br><span class="line">        activations = [x] <span class="comment"># list to store all the activations, layer by layer</span></span><br><span class="line">        zs = [] <span class="comment"># list to store all the z vectors, layer by layer</span></span><br><span class="line">        <span class="keyword">for</span> b, w <span class="keyword">in</span> zip(self.biases, self.weights):</span><br><span class="line">            z = np.dot(w, activation)+b</span><br><span class="line">            zs.append(z)</span><br><span class="line">            activation = sigmoid(z)</span><br><span class="line">            activations.append(activation)</span><br><span class="line">        <span class="comment"># backward pass</span></span><br><span class="line">        delta = self.cost_derivative(activations[<span class="number">-1</span>], y) * \</span><br><span class="line">            sigmoid_prime(zs[<span class="number">-1</span>])</span><br><span class="line">        nabla_b[<span class="number">-1</span>] = delta</span><br><span class="line">        nabla_w[<span class="number">-1</span>] = np.dot(delta, activations[<span class="number">-2</span>].transpose())</span><br><span class="line">        <span class="comment"># Note that the variable l in the loop below is used a little</span></span><br><span class="line">        <span class="comment"># differently to the notation in Chapter 2 of the book.  Here,</span></span><br><span class="line">        <span class="comment"># l = 1 means the last layer of neurons, l = 2 is the</span></span><br><span class="line">        <span class="comment"># second-last layer, and so on.  It's a renumbering of the</span></span><br><span class="line">        <span class="comment"># scheme in the book, used here to take advantage of the fact</span></span><br><span class="line">        <span class="comment"># that Python can use negative indices in lists.</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> xrange(<span class="number">2</span>, self.num_layers):</span><br><span class="line">            z = zs[-l]</span><br><span class="line">            sp = sigmoid_prime(z)</span><br><span class="line">            delta = np.dot(self.weights[-l+<span class="number">1</span>].transpose(), delta) * sp</span><br><span class="line">            nabla_b[-l] = delta</span><br><span class="line">            nabla_w[-l] = np.dot(delta, activations[-l<span class="number">-1</span>].transpose())</span><br><span class="line">        <span class="keyword">return</span> (nabla_b, nabla_w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self, test_data)</span>:</span></span><br><span class="line">        <span class="string">"""Return the number of test inputs for which the neural</span></span><br><span class="line"><span class="string">        network outputs the correct result. Note that the neural</span></span><br><span class="line"><span class="string">        network's output is assumed to be the index of whichever</span></span><br><span class="line"><span class="string">        neuron in the final layer has the highest activation."""</span></span><br><span class="line">        test_results = [(np.argmax(self.feedforward(x)), y)</span><br><span class="line">                        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> test_data]</span><br><span class="line">        <span class="keyword">return</span> sum(int(x == y) <span class="keyword">for</span> (x, y) <span class="keyword">in</span> test_results)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost_derivative</span><span class="params">(self, output_activations, y)</span>:</span></span><br><span class="line">        <span class="string">"""Return the vector of partial derivatives \partial C_x /</span></span><br><span class="line"><span class="string">        \partial a for the output activations."""</span></span><br><span class="line">        <span class="keyword">return</span> (output_activations-y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Miscellaneous functions</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""The sigmoid function."""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1.0</span>+np.exp(-z))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_prime</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""Derivative of the sigmoid function."""</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(z)*(<span class="number">1</span>-sigmoid(z))</span><br></pre></td></tr></table></figure><p>让我们来看一下这个最简单的 BP 神经网络在手写数字识别上效果如何。初始化一个含有 30 个神经元的隐藏层。训练 30 个 epoch，mini-batch 大小为 10，学习率 $\eta=3.0$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mnist_loader</span><br><span class="line">training_data, validation_data, test_data = mnist_loader.load_data_wrapper()</span><br><span class="line"><span class="keyword">import</span> network</span><br><span class="line">net = network.Network([<span class="number">784</span>, <span class="number">30</span>, <span class="number">10</span>])</span><br><span class="line"><span class="keyword">import</span> network</span><br><span class="line">net = network.Network([<span class="number">784</span>, <span class="number">30</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>结果为</p><pre><code>Epoch 0: 9129 / 10000Epoch 1: 9295 / 10000Epoch 2: 9348 / 10000...Epoch 27: 9528 / 10000Epoch 28: 9542 / 10000Epoch 29: 9534 / 10000</code></pre><p>看来不错！识别率达到了 95.42%！如果将隐藏层的神经元增加到 100 个，最终识别率达到了 96.59%！</p><h2 id="神经网络识别手写数字目录"><a href="#神经网络识别手写数字目录" class="headerlink" title="神经网络识别手写数字目录"></a>神经网络识别手写数字目录</h2><ol><li><a href="http://www.lyyyuna.com/2016/05/29/handwritten-neural-net/">基于 BP 神经网络的识别手写体数字 - 神经网络基础</a></li><li><a href="http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/">基于 BP 神经网络的手写体数字识别 - 设计与实现</a></li><li><a href="http://www.lyyyuna.com/2016/06/26/handwritten-neural-net03/">基于 BP 神经网络的手写体数字识别 - 反向传播算法</a></li><li><a href="http://www.lyyyuna.com/2016/06/30/handwritten-neural-net04/">基于 BP 神经网络的手写体数字识别 - 优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: &quot;AMS&quot; } }
});
&lt;/script&gt;


&lt;h2 id=&quot;手写体数字识别
      
    
    </summary>
    
      <category term="数学" scheme="http://www.lyyyuna.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
      <category term="mnist" scheme="http://www.lyyyuna.com/tags/mnist/"/>
    
      <category term="neural network" scheme="http://www.lyyyuna.com/tags/neural-network/"/>
    
  </entry>
  
  <entry>
    <title>基于 BP 神经网络的识别手写体数字 - 神经网络基础</title>
    <link href="http://www.lyyyuna.com/2016/05/29/handwritten-neural-net/"/>
    <id>http://www.lyyyuna.com/2016/05/29/handwritten-neural-net/</id>
    <published>2016-05-29T00:57:52.000Z</published>
    <updated>2017-11-29T00:19:00.163Z</updated>
    
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">MathJax.Hub.Config({  TeX: { equationNumbers: { autoNumber: "AMS" } }});</script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上个月，公司内部举办了机器学习比赛，内容是识别手写体数字。</p><p>我提交的方案参考 <a href="http://michaelnielsen.org/" target="_blank" rel="noopener">Michael Nielsen</a>。以下大部分内容也参考了<a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">他写的深度学习在线电子书</a>。</p><p>人类视觉系统其实非常神奇，恐怕自己都没意识到，考虑以下的手写数字：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/504192.png" alt="504192"></p><p>大部分人能够识别出数字为 504192。人脑每一半球都有着近 1.4 亿个神经元，之间有数以百亿的连接，能够进行复杂的图像处理。相当于每个人随身携带了一台超级计算机，数百万年的进化让该系统训练有素，能够适应并理解视觉世界。</p><p>当真正开始编写程序时，就会意识到手写数字中复杂之处。在教小孩认数字 9 时，可能会 “这个数字顶上有个圈，右下角有个垂直的竖线。。”，或者你给他看一眼写的 9，他就能学会了。但这些步骤根本无法用传统的算法来描述，因为一个手写数字有着无限的细节。</p><p>神经网络算法则用另一种方法来解决问题。首先，会准备如下的训练数据，</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/train_data.png" alt="训练数据"></p><p>然后，系统便以此为基础<strong>学习</strong>。换句话说，神经网络能够使用这些训练数据自动推导出识别手写数字的规则。并且，训练集越多，神经网络准确率越高。所以虽然上图只展示了 100 个数字，但如果有上百万个训练集的话，我们的手写数字识别器效果会更好。</p><p>神经网络是一个简单易实现的算法，不会超过 100 行代码。我们也会在将来探讨更为复杂的深度学习算法。</p><h2 id="感知器-Perceptron"><a href="#感知器-Perceptron" class="headerlink" title="感知器 Perceptron"></a>感知器 Perceptron</h2><p>什么是神经网络？我们从<strong>感知器</strong>说起。</p><p>感知器是上世纪 50 年代，<a href="http://en.wikipedia.org/wiki/Frank_Rosenblatt" target="_blank" rel="noopener">Frank Rosenblatt</a> 受 <a href="http://en.wikipedia.org/wiki/Warren_McCulloch" target="_blank" rel="noopener">Warren McCulloch</a> 和 <a href="http://en.wikipedia.org/wiki/Walter_Pitts" target="_blank" rel="noopener">Walter Pitts</a> <a href="http://scholar.google.ca/scholar?cluster=4035975255085082870" target="_blank" rel="noopener">工作</a>的启发，所提出的概念。如今，其他的人工神经元模型更常用，最广泛的是 <strong>sigmoid</strong> 神经元。现在先让我们看看感知器模型，它将帮助我们了解为什么 sigmoid 神经元更受欢迎。</p><p>感知器如何工作呢？一个感知器有多个二进制输入，$x_1, x_2, …$，并只有一个二进制的输出：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/perceptron.png" alt="感知器模型"></p><p>这个例子中，感知器有三个输入，$x_1, x_2, x_3$。通常输入数目由需要而定。Rosenblatt 给每一个输入引入一个权重，$w_1, w_2, …$，在输出增加一个阈值，超过阈值时才会输出 1，以下为输出与输入的关系：</p><p>\begin{equation}<br>output = \left\{\begin{aligned}<br>0, \sum_jw_jx_j \leq threshold \\<br>1, \sum_jw_jx_j &gt; threshold<br>\end{aligned}\right.<br>\end{equation}</p><p>这个简单的公式就是感知器的工作原理！</p><p>下面给出一个简单的模型，虽然不是实际例子，但易于理解。假设周末即将来临，你听说自己所在的城市会举办奶酪节。你太喜欢奶酪了，但还是得考虑一下周末的天气情况。你将根据下面三个因素来做决定：</p><ol><li>天气怎样？</li><li>你的女朋友和你一起去吗？</li><li>节日举办地驾车方便吗？</li></ol><p>将这三种因素量化成二进制数 $x_1, x_2, x_3$。比如如果天气好，则 $x_1=1$，否则为 $x_1=0$。其他三种因素同理。现在假设你太喜欢奶酪了，以至于女朋友和交通不遍都不太影响你，但你又怕糟糕的天气弄脏衣服。我们可以将感知器设计为：天气权重$w_1=6$，女朋友权重 $w_2=2$ 和交通状况权重 $w_3=2$。可以看到天气占了很大的权重。最后将感知器阈值设为 5 便得到了我们需要的决策模型。一旦天气不好，感知器输出为 0，天气晴朗就输出 1。而女朋友同去与否和交通状况都没法影响感知器输出。</p><p>通过改变加权系数和阈值，便能得到不同的决策系统。比如将阈值调整为 3，这样女朋友就对你很重要啦，她要是想去，天气再糟你也得跟着一起受罪。</p><p>虽然感知器并不是人类决策系统的完整模型，但其能对各种条件做加权。而且似乎越复杂的网路越能做出微妙的决策：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/complex_perceptron.png" alt="复杂网络"></p><p>在这个网络中，第一列感知器 - 我们也称作感知器第一层，只是简单地对输入做加权。而第二层感知器则对第一层决策的结果再一步加权，做出更复杂更抽象的决定。同样还可以增加神经网络的层数来作出更复杂的决定。</p><p>顺便提一句，上述定义中，感知器只有一个输出，但是上述网络似乎有多个输出。事实上，这仍然是单输出系统，只是单个输出连接到了下一层的多个输入而已。</p><p>让我们来简化一下感知器的数学表达式，原来的判断条件 $\sum_jw_jx_j &gt; threshold$ 略显累赘。首先用点积形式简化，记 $w \cdot x \equiv \sum_j w_j x_j$，其中 $w$ 是权重向量，$x$ 是输入向量。然后将阈值移到不等式左边，并用偏移的概念取代它，记 $b \equiv - threshold$。感知器规则可重写如下：</p><p>\begin{equation}<br>output = \left\{\begin{aligned}<br>0, w \cdot x + b \leq 0 \\<br>1, w \cdot x + b &gt; 0<br>\end{aligned}\right.<br>\end{equation}</p><p>偏移的概念可用来度量感知器的“兴奋”程度，假如偏移值很大，那么很小的输入就会在输出端反应出来。但若偏移值很小，则说明感知器比较“迟钝”，输入很大时，输出才有变化。接下来的文章中，都会使用偏移而不是阈值的概念。</p><h2 id="sigmoid-神经元"><a href="#sigmoid-神经元" class="headerlink" title="sigmoid 神经元"></a>sigmoid 神经元</h2><p>自学习的 idea 听起来太棒了。如何为神经网络设计算法呢？假设我们的神经网络全部由感知器构成，输入为手写体数字扫描图的每一个原始像素点。我们希望神经网络能够自调整权重和偏移值，从而能对手写数字准确分类。为了解自学习过程，我们来做一个思想实验，假设我们在权重或偏移做一个小的改变，我们期望输出也会有相应小的变化：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/neural_net.png" alt="神经网络"></p><p>比如神经网络错误地将数字 9 认为为数字 8，我们就可以对参数做微调（可能某个人写的 9 像 8），修正输出，不断重复上述过程，从而使输出符合我们的预期。</p><p>实际中，由感知器组成的神经网络并不如所愿。由于感知器的输出不是连续的，0 到 1 是阶跃变化，上述参数的微调往往带来输出的剧烈变化。这下便导致自学习过程完全不可控，有时一点小小的噪声，输出就天壤之变。</p><p>针对这个问题，我们可以换用 sigmoid 神经元。sigmoid 神经元和感知器是类似的，但输出是连续且变化缓慢的。这个微小的不同使神经网络算法化成为了可能。</p><p>好，让我来描述一下 sigmoid 神经元。其结构和感知器一样：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/sigmoid.png" alt="sigmoid 神经元"></p><p>同样有输入 $x_1, x_2, …$。不同是，输入可以取 0 到 1 之间的任何值，比如 0.638。sigmoid 对每一个输入有一个权重，$w_1, w_2, …$，以及全局的偏移 $b$。但是 sigmoid 的输出不再限于 0 和 1，而是</p><p>\begin{equation}<br>  \sigma(z) \equiv \frac{1}{1+e^{-z}}.<br>\end{equation}</p><p>将 $z=w \cdot x+b$ 展开，可得</p><p>\begin{equation}<br>  \frac{1}{1+\exp(-\sum_j w_j x_j-b)}. \label{eq4}<br>\end{equation}</p><p>初看上去，sigmoid 神经元似乎与感知器有着天壤之别，其代数表达式也显得晦涩难懂。然而他们之间是有很多相似之处的。</p><p>假设当 $z\equiv w \cdot x + b$ 趋向于正无穷，则 $e^{-z}\approx 0$ 和 $\sigma(z) \approx 1$。换句话说，当输入很大时，sigmoid 神经元的输出趋向于 1，这和感知器是一样的。相反的，当 $z\equiv w \cdot x + b$ 趋向于负无穷，则 $e^{-z} \rightarrow \infty$，且 $\sigma(z) \approx 0$。这和感知器又是一样的。只有当输入不大时，才会与感知器表现不同。</p><p>让我们看一下 sigmoid 函数和阶跃函数的图像：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/sigmoid_function.png" alt="sigmoid 函数"></p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/step_function.png" alt="阶跃函数"></p><p>如果 $\sigma$ 是阶跃函数，那么 sigmoid 神经元就会退化成感知器，也就是说 sigmoid 神经元是平滑了的感知器。函数 $\sigma$ 的平滑度意味着，权重的微小变化 $\Delta w_j$ 和偏移的微小变化 $\Delta b$ 会在输出有相应的变化 $\Delta \mbox{output}$，运用泰勒公式可得：</p><p>\begin{eqnarray}<br>  \Delta \mbox{output} \approx \sum_j \frac{\partial \, \mbox{output}}{\partial w_j}<br>  \Delta w_j + \frac{\partial \, \mbox{output}}{\partial b} \Delta b,<br>\label{5}<br>\end{eqnarray}</p><p>其中，求和是对所有的权重和偏移变化求和。 $\partial \,\mbox{output} / \partial w_j$ 是 $\mbox{output}$ 对 $w_j$ 的偏导数，$\partial \, \mbox{output} /\partial b$ 是 $\mbox{output}$ 对 $b$ 的偏导数。从这个近似表达式可以看出，$\Delta \mbox{ouput}$ 是 $\Delta w_j, \Delta b$ 的线性函数。比起感知器那种非线性的输出输入关系，线性化便于调试，也有利于算法化。</p><p>如何理解 sigmoid 神经元的输出呢？显然最大的不同是 sigmoid 神经元不只输出 0 或 1，而是 0，1 之间所有的实数，比如 0.4 来指出一幅图片是 9 的概率为 40%，60% 的概率不是 9。</p><h2 id="神经网络的结构"><a href="#神经网络的结构" class="headerlink" title="神经网络的结构"></a>神经网络的结构</h2><p>神经网络的结构：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/net_structure.png" alt="神经网络的结构"></p><p>如上所述，最左边的那一层被称做输入层，其中的神经元是输入神经元。最右或者输出层包含了输出神经元，该例中只有一个输出神经元。由于中间的神经元既不是输入也不是输出，中间那层被称为隐藏层。该例中只有一个隐藏层，有些神经网络有多个隐藏层，比如下面这张图中有两个隐藏层：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201605/multi-layer_net_structure.png" alt="两个隐藏层"></p><p>神经网络输入输出的设计通常很直接。比如手写数字，假设扫描图是 $28 \times 28=784$ 的灰度图像，输入就有 784 个神经元，输出就是每个数字的概率，一共 10 个输出神经元。</p><h2 id="神经网络识别手写数字目录"><a href="#神经网络识别手写数字目录" class="headerlink" title="神经网络识别手写数字目录"></a>神经网络识别手写数字目录</h2><ol><li><a href="http://www.lyyyuna.com/2016/05/29/handwritten-neural-net/">基于 BP 神经网络的识别手写体数字 - 神经网络基础</a></li><li><a href="http://www.lyyyuna.com/2016/06/25/handwritten-neural-net02/">基于 BP 神经网络的手写体数字识别 - 设计与实现</a></li><li><a href="http://www.lyyyuna.com/2016/06/26/handwritten-neural-net03/">基于 BP 神经网络的手写体数字识别 - 反向传播算法</a></li><li><a href="http://www.lyyyuna.com/2016/06/30/handwritten-neural-net04/">基于 BP 神经网络的手写体数字识别 - 优化</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: &quot;AMS&quot; } }
});
&lt;/script&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="数学" scheme="http://www.lyyyuna.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="mnist" scheme="http://www.lyyyuna.com/tags/mnist/"/>
    
      <category term="neural network" scheme="http://www.lyyyuna.com/tags/neural-network/"/>
    
  </entry>
  
</feed>
