<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyyyuna 的小花园</title>
  
  <subtitle>动静中之动</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lyyyuna.com/"/>
  <updated>2021-01-01T04:35:19.322Z</updated>
  <id>http://www.lyyyuna.com/</id>
  
  <author>
    <name>lyyyuna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang 官方关于单元测试方法的一些建议</title>
    <link href="http://www.lyyyuna.com/2021/01/01/go-unit-test-comments/"/>
    <id>http://www.lyyyuna.com/2021/01/01/go-unit-test-comments/</id>
    <published>2021-01-01T04:20:02.000Z</published>
    <updated>2021-01-01T04:35:19.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是翻译+理解+改编自 Go 官方的<a href="https://github.com/golang/go/wiki/TestComments" target="_blank" rel="noopener">TestComments</a>，原文是 Go 源码本身开发时<code>Code Review</code>的注意项。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在测试时避免使用断言库。那些有类似<code>xUnit</code>测试框架使用背景的 Go 开发者喜欢写如下的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert.isNotNil(t, <span class="string">"obj"</span>, obj)</span><br><span class="line">assert.stringEq(t, <span class="string">"obj.Type"</span>, obj.Type, <span class="string">"blogPost"</span>)</span><br><span class="line">assert.intEq(t, <span class="string">"obj.Comments"</span>, obj.Comments, <span class="number">2</span>)</span><br><span class="line">assert.stringNotEq(t, <span class="string">"obj.Body"</span>, obj.Body, <span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>但有的断言库会过早的终止测试用例（如果断言中调用了<code>t.Fatalf</code>或者<code>panic</code>），有的会漏掉测试如何通过的关键信息。测试应该是精确的，能够一眼看出哪些部分导致用例失败，哪些部分是正确的。不仅如此，放着 Go 的语法不用，断言库却常常创造自己的一整套语法来做非空判断（<code>isNotNil</code>）、字符串比较（<code>stringEq</code>）、表达式求值等等。</p><p>综上，上面那个例子应该改写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> obj == <span class="literal">nil</span> || obj.Type != <span class="string">"blogPost"</span> || obj.Comments != <span class="number">2</span> || obj.Body == <span class="string">""</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">"AddPost() = %+v"</span>, obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用可读性高的子测试用例名"><a href="#使用可读性高的子测试用例名" class="headerlink" title="使用可读性高的子测试用例名"></a>使用可读性高的子测试用例名</h2><p>当使用<code>t.Run</code>来创建子测试时，第一个参数是用例的名字。为了确保测试结果在日志上具备高可读性，用例名应该描述要测试的场景，并保证在转义后仍可读（测试用例执行时，会将空格转换为下划线，并转义不可打印的字符）。</p><p>也可以在子测试的函数体中使用<code>t.Log</code>打印子测试用例名，或者包含在失败信息中，这两个地方用例名都不会被转义。</p><h2 id="直接比较结构体"><a href="#直接比较结构体" class="headerlink" title="直接比较结构体"></a>直接比较结构体</h2><p>如果函数返回的是结构体，不推荐一个一个字段的比较，而是构造出你预期的结果，用下文提到的<a href="#相等性比较和diff">cmp 方法</a>直接比较。该规则同样适用于数组和字典。</p><p>如果结构体之间是某种语义上的相等，或者某些字段不支持比较操作（比如类型为<code>io.Reader</code>的字段），那你可以在<a href="https://godoc.org/github.com/google/go-cmp/cmp#Diff" target="_blank" rel="noopener">cmp.Diff</a>和<a href="https://godoc.org/github.com/google/go-cmp/cmp#Equal" target="_blank" rel="noopener">cmp.Equal</a>的参数中传入类型为<a href="https://godoc.org/github.com/google/go-cmp/cmp/cmpopts" target="_blank" rel="noopener">cmpopts</a>的<a href="https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#IgnoreInterfaces" target="_blank" rel="noopener">cmpopts.IgnoreInterfaces</a>来忽略它们。要是还不行，那，就自由发挥吧。</p><p>如果函数返回多个结果，逐个比较并打印，不必拼成一个结构体。</p><h2 id="只比较稳定的结果"><a href="#只比较稳定的结果" class="headerlink" title="只比较稳定的结果"></a>只比较稳定的结果</h2><p>如果被测函数依赖的外部包不受控制，导致输出结果不稳定，就该避免在测试中使用该结果。相反，应该去比较那些在语义上稳定的信息。</p><p>那些输出格式化/序列化字符串的功能，不该假设其输出的字符串一尘不变。举个实际的例子，<code>json.Marshal</code>并不保证输出的字节流永远是相同的，历史上该函数的实现变动过。如果从字符串是否相等的角度去测试<code>json</code>库，那测试用的执行结果无法稳定。而鲁棒性的做法应去解析 JSON 字符串，然后比较其中的每个对象。</p><h2 id="相等性比较和diff"><a href="#相等性比较和diff" class="headerlink" title="相等性比较和diff"></a>相等性比较和diff</h2><p><code>==</code>操作符会按照<a href="https://golang.org/ref/spec#Comparison_operators" target="_blank" rel="noopener">Go 语言规范</a>定义的行为执行相等比较。数字、字符串和指针可以执行比较操作，结构体的每个字段如果都是以上三种类型，那结构体也可做比较。其中指针比较特别，只支持相等操作。</p><p>使用<a href="https://godoc.org/github.com/google/go-cmp/cmp" target="_blank" rel="noopener">cmp</a>包的<a href="https://godoc.org/github.com/google/go-cmp/cmp#Equal" target="_blank" rel="noopener">cmp.Equal</a>可直接比较两个任意的对象，使用<a href="https://godoc.org/github.com/google/go-cmp/cmp#Diff" target="_blank" rel="noopener">cmp.Diff</a>则会输出这两个对象间的差异，而且可读性非常高。</p><p>虽然<code>cmp</code>不在标准库中，但它是由 Go 官方维护的，和每一版的 Go 兼容，适用于大部分对象间的比较需求。</p><p>老旧的代码中会使用<code>reflect.DeepEqual</code>函数来比较复杂的结构体，现在建议用<code>cmp</code>包来代替，因为<code>reflect.DeepEqual</code>对一些未导出的字段和实现细节的变动非常敏感。</p><p>（<code>cmp</code>包使用时添加<code>cmp.Compare(proto.Equal)</code>选项即可直接用于 protocol buffer 消息的比较。）</p><h2 id="不仅打印期望值，也要打印实际值"><a href="#不仅打印期望值，也要打印实际值" class="headerlink" title="不仅打印期望值，也要打印实际值"></a>不仅打印期望值，也要打印实际值</h2><p>测试结果在打印期望结果之前，应该打印函数的实际结果。通常我们会将测试结果格式化为：<code>YourFunc(%v) = %v, want %v</code>。</p><p>对于 diff 的输出，期望结果和实际结果谁前谁后不明显，这时需要加入额外信息帮助理解。这两个什么顺序并不重要，重要的是整个工程应该具有一致性。</p><h2 id="标识函数名"><a href="#标识函数名" class="headerlink" title="标识函数名"></a>标识函数名</h2><p>在大部分测试中，失败消息应该包含所在函数名，即使该消息显而易见来自测试函数。</p><p>优先使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Errorf(<span class="string">"YourFunc(%v) = %v, want %v"</span>, in, got, want)</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.Errorf(<span class="string">"got %v, want %v"</span>, got, want)</span><br></pre></td></tr></table></figure><h2 id="标识输入"><a href="#标识输入" class="headerlink" title="标识输入"></a>标识输入</h2><p>在大部分测试中，函数输入参数也应该包含在失败消息中。如果输入参数的相关属性不明显（比如，参数较大或晦涩难懂），你应该在测试名中描述本测试的内容，并且将描述信息放入错误消息中。</p><p>对于表格驱动型测试，不要将序号作为测试名的一部分。在测试用例失败后，没人希望回到表格中一个个数来找出失败来自哪个用例。</p><h2 id="失败继续执行"><a href="#失败继续执行" class="headerlink" title="失败继续执行"></a>失败继续执行</h2><p>即使测试用例遇到了失败，它也应尽可能地继续执行，以便能在一次运行中打印出所有失败检查点。这样，如果有人要依照测试结果修复代码时，不用一遍遍重复执行用例来找出下一个 bug。</p><p>从实际角度出发，优先使用<code>t.Error</code>而不是<code>t.Fatal</code>。当比较函数的多个输出时，对每一个分别使用<code>t.Error</code>。</p><p><code>t.Fatal</code>适合在 setup 中使用，因为 setup 一旦失败，其余的步骤便没有再执行的必要。表格驱动的测试中，<code>t.Fatal</code>适合在所有子测试开始前使用。表格中的每一测试用例若遇到不可恢复的错误，如何处理要分具体情况：</p><ul><li>如果你没有使用<code>t.Run</code>运行子测试，那应该使用<code>t.Error</code>并使用<code>conitnue</code>语句直接跳转到下一项用例。</li><li>如果你使用<code>t.Run</code>运行子测试，那<code>t.Fatal</code>只会中断当前用例，其余子测试会继续执行。</li></ul><h2 id="标记测试辅助函数"><a href="#标记测试辅助函数" class="headerlink" title="标记测试辅助函数"></a>标记测试辅助函数</h2><p>辅助函数常用于 setup 和 teardown 任务中，比如构造一个测试数据。</p><p>在辅助函数中调用<a href="https://godoc.org/testing#T.Helper" target="_blank" rel="noopener">t.Helper</a>后，如果辅助函数中某个判断出错，那在测试日志中的错误提示会忽略该辅助函数的调用栈，标记出错的行会焦点在测试用例中，而非在辅助函数中。有点绕，看个例子便一目了然。</p><p>例如未使用<code>t.Helper</code>之前：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testHelper</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Helper()</span><br><span class="line">t.Fatal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloWorld</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">testHelper(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出错信息为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- FAIL: TestHelloWorld (0.00s)</span><br><span class="line">    main_test.go:6:</span><br><span class="line">FAIL</span><br><span class="line">FAILtest.test0.001s</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure><p>标记代码后：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testHelper</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Helper()</span><br><span class="line">t.Fatal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloWorld</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">testHelper(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出错信息为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- FAIL: TestHelloWorld (0.00s)</span><br><span class="line">    main_test.go:11:</span><br><span class="line">FAIL</span><br><span class="line">FAILtest.test0.002s</span><br><span class="line">FAIL</span><br></pre></td></tr></table></figure><p>可以看到，显示出错的第几行不一样。显然若<code>testHelper</code>被多个测试用例调用，后者的测试日志更易排查。</p><h2 id="打印-diff"><a href="#打印-diff" class="headerlink" title="打印 diff"></a>打印 diff</h2><p>如果函数返回的输出比较长，而出错的地方只是其中一小段，那很难一眼看出区别。这对调试不友好，建议直接输出期望和实际结果的 diff 值。</p><h2 id="表格驱动测试-vs-多个测试函数"><a href="#表格驱动测试-vs-多个测试函数" class="headerlink" title="表格驱动测试 vs 多个测试函数"></a>表格驱动测试 vs 多个测试函数</h2><p>当多个测试用例有着相同的测试逻辑，只是输入数据不同时，就应该使用<a href="https://github.com/golang/go/wiki/TableDrivenTests" target="_blank" rel="noopener">表格驱动测试</a>方法。</p><p>而当每个测试用例需用不同的方法验证时，表格驱动就显得不合适，因为那样就不得不写一堆控制变量放入表格中，将原本的测试逻辑淹没其中，降低了用例的可读性和表格的可维护性。</p><p>实际测试两种方法需结合使用。比如可以写两个表格驱动测试方法，一个测试函数的正常返回结果，另一个测试不同错误消息。</p><h2 id="测试错误语义"><a href="#测试错误语义" class="headerlink" title="测试错误语义"></a>测试错误语义</h2><p>单元测试避免使用字符串比较或者是<code>reflect.DeepEqual</code>去检查函数的错误输出。错误消息若随着业务成长需要经常变动，你会不得不经常修改单元测试用例。</p><p>而依赖库中的错误消息则相对稳定，拿来做字符串比较是可接受的。</p><p>我们应该区分哪些是为了提高排查效率增添的错误消息，哪些只是用于内部编程，而多用<code>fmt.Errorf</code>恰恰会打破内部的稳定性，应尽量少用。</p><p>许多人并不关心他们的 API 返回具体什么错误消息，这种情况下，单元测试中只做错误非空判断就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是翻译+理解+改编自 Go 官方的&lt;a href=&quot;https://github.com/golang/go/wiki/TestComm
      
    
    </summary>
    
      <category term="测试" scheme="http://www.lyyyuna.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Go" scheme="http://www.lyyyuna.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 与子测试</title>
    <link href="http://www.lyyyuna.com/2020/12/14/go-testing-in-go-subtests/"/>
    <id>http://www.lyyyuna.com/2020/12/14/go-testing-in-go-subtests/</id>
    <published>2020-12-14T08:20:02.000Z</published>
    <updated>2020-12-31T15:00:01.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>表格驱动测试可谓是最受欢迎的测试方法了，它抽取了相似用例的公共步骤，结构清晰，维护简单，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOlder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">age1     <span class="keyword">int</span></span><br><span class="line">age2     <span class="keyword">int</span></span><br><span class="line">expected <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">        <span class="comment">// 第一个测试用例</span></span><br><span class="line">&#123;</span><br><span class="line">age1:     <span class="number">1</span>,</span><br><span class="line">age2:     <span class="number">2</span>,</span><br><span class="line">expected: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">        <span class="comment">// 第二个测试用例</span></span><br><span class="line">&#123;</span><br><span class="line">age1:     <span class="number">2</span>,</span><br><span class="line">age2:     <span class="number">1</span>,</span><br><span class="line">expected: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">_, p1 := NewPerson(c.age1)</span><br><span class="line">_, p2 := NewPerson(c.age2)</span><br><span class="line"></span><br><span class="line">got := p1.older(p2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> got != c.expected &#123;</span><br><span class="line">t.Errorf(<span class="string">"Expected %v &gt; %v, got %v"</span>, p1.age, p2.age, got)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法有着一个致命的缺陷，你无法像之前一样选择某个用例执行，即不支持 <code>go test -run regex</code> 命令行来选择只执行第一个或第二个测试用例。</p><p><code>Go 1.7</code> 中加入了子测试的概念，以解决该问题。</p><h2 id="什么是-Go-的子测试"><a href="#什么是-Go-的子测试" class="headerlink" title="什么是 Go 的子测试"></a>什么是 Go 的子测试</h2><p>子测试在 <code>testing</code> 包中由 <a href="https://golang.org/pkg/testing/#T.Run" target="_blank" rel="noopener">Run 方法</a> 提供，它有俩个参数：子测试的名字和子测试函数，其中名字是子测试的标识符。</p><p>子测试和其他普通的测试函数一样，是在独立的 goroutine 中运行，测试结果也会计入测试报告，所有子测试运行完毕后，父测试函数才会结束。</p><h2 id="如何使用t-Run"><a href="#如何使用t-Run" class="headerlink" title="如何使用t.Run"></a>如何使用<code>t.Run</code></h2><p>使用<code>t.Run</code>重构前言中的测试代码，代码变动了不少：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOlder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="keyword">string</span></span><br><span class="line">age1     <span class="keyword">int</span></span><br><span class="line">age2     <span class="keyword">int</span></span><br><span class="line">expected <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;</span><br><span class="line">name:     <span class="string">"FirstOlderThanSecond"</span>,</span><br><span class="line">age1:     <span class="number">1</span>,</span><br><span class="line">age2:     <span class="number">2</span>,</span><br><span class="line">expected: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:     <span class="string">"SecondOlderThanFirst"</span>,</span><br><span class="line">age1:     <span class="number">2</span>,</span><br><span class="line">age2:     <span class="number">1</span>,</span><br><span class="line">expected: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">t.Run(c.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">_, p1 := NewPerson(c.age1)</span><br><span class="line">_, p2 := NewPerson(c.age2)</span><br><span class="line"></span><br><span class="line">got := p1.older(p2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> got != c.expected &#123;</span><br><span class="line">t.Errorf(<span class="string">"Expected %v &gt; %v, got %v"</span>, p1.age, p2.age, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们修改了定义用例的结构体，加入了<code>string</code>类型的<code>name</code>属性。这样每个用例都有了自己的名字来标示自己。例如，第一个用例由于参数<code>arg1</code>大于参数<code>arg2</code>，所以被命名称<code>FirstOlderThanSecond</code>。</p><p>然后在<code>for</code>循环中，我们把整个测试逻辑包裹在<code>t.Run</code>块中，并把用例名作为第一个参数。</p><p>运行该测试，可得：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v -count=1</span><br><span class="line">=== RUN   TestOlder</span><br><span class="line">=== RUN   TestOlder/FirstOlderThanSecond</span><br><span class="line">=== RUN   TestOlder/SecondOlderThanFirst</span><br><span class="line">--- PASS: TestOlder (0.00s)</span><br><span class="line">    --- PASS: TestOlder/FirstOlderThanSecond (0.00s)</span><br><span class="line">    --- PASS: TestOlder/SecondOlderThanFirst (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok  person0.004s</span><br></pre></td></tr></table></figure><p>从结果中我们发现，<code>TestOlder</code>派生出另外两个子测试函数：<code>TestOlder/FirstOlderThanSecond</code> 和 <code>TestOlder/SecondOlderThanFirst</code>。在这两个子测试结束之前，<code>TestOlder</code>都不会结束。</p><p>子测试函数的测试结果在终端里是缩进的，且测试用例的名字都以<code>TestOlder</code>开头，这些都用来凸显测试用例之间的父子关系。</p><h2 id="go-test选择子测试运行"><a href="#go-test选择子测试运行" class="headerlink" title="go test选择子测试运行"></a><code>go test</code>选择子测试运行</h2><p>在调试特定测试用例或复现某个 bug 时我们常用<code>go test -run=regex</code>来指定。子测试<code>regex</code>的命名规则和上一节中测试结果一致：<code>父测试名/子测试名</code>。</p><p>比如可用以下命令执行子测试<code>FirstOlderThenSecond</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v -count=1 -run=<span class="string">"TestOlder/FirstOlderThanSecond"</span></span><br><span class="line">=== RUN   TestOlder</span><br><span class="line">=== RUN   TestOlder/FirstOlderThanSecond</span><br><span class="line">--- PASS: TestOlder (0.00s)</span><br><span class="line">    --- PASS: TestOlder/FirstOlderThanSecond (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>如果要执行某个父测试下的所有子测试，可键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v -count=1 -run=<span class="string">"TestOlder"</span></span><br><span class="line">=== RUN   TestOlder</span><br><span class="line">=== RUN   TestOlder/FirstOlderThanSecond</span><br><span class="line">=== RUN   TestOlder/SecondOlderThanFirst</span><br><span class="line">--- PASS: TestOlder (0.00s)</span><br><span class="line">    --- PASS: TestOlder/FirstOlderThanSecond (0.00s)</span><br><span class="line">    --- PASS: TestOlder/SecondOlderThanFirst (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><h2 id="Setup-和-Teardown-和-TestMain"><a href="#Setup-和-Teardown-和-TestMain" class="headerlink" title="Setup 和 Teardown 和 TestMain"></a>Setup 和 Teardown 和 TestMain</h2><p>使用过其他测试框架的同学一定不会对<code>Setup</code>和<code>Teardown</code>陌生，这几乎是测试框架的标配。而 <code>testing</code> 包长期以来在这块是缺失的，我们无法为所有的测试用例添加一些公共的初始化和结束步骤。引入<code>t.Run</code>之后，我们便可以实现缺失的功能。</p><p>请看下面的例子，在子测试开始时，先调用<code>setupSubtest(t)</code>做初始化工作，然后使用<code>defer teardownSubtest(t)</code>保证在<code>t.Run</code>结束前执行清理工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupSubtest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Logf(<span class="string">"[SETUP] Hello 👋!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teardownSubtest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Logf(<span class="string">"[TEARDOWN] Bye, bye 🖖!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOlder</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">t.Run(c.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            <span class="comment">// setup</span></span><br><span class="line">            setupSubtest(t)</span><br><span class="line">            <span class="comment">// teardown</span></span><br><span class="line"><span class="keyword">defer</span> teardownSubtest(t)</span><br><span class="line"></span><br><span class="line">_, p1 := NewPerson(c.age1)</span><br><span class="line">_, p2 := NewPerson(c.age2)</span><br><span class="line"></span><br><span class="line">got := p1.older(p2)</span><br><span class="line"></span><br><span class="line">t.Logf(<span class="string">"[TEST] Hello from subtest %s \n"</span>, c.name)</span><br><span class="line"><span class="keyword">if</span> got != c.expected &#123;</span><br><span class="line">t.Errorf(<span class="string">"Expected %v &gt; %v, got %v"</span>, p1.age, p2.age, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试后，可以看到<code>Setup</code>和<code>Teardown</code>在每个子测试中都会被调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v -count=1 -run=<span class="string">"TestOlder"</span></span><br><span class="line">=== RUN   TestOlder</span><br><span class="line">=== RUN   TestOlder/FirstOlderThanSecond</span><br><span class="line">=== RUN   TestOlder/SecondOlderThanFirst</span><br><span class="line">--- PASS: TestOlder (0.00s)</span><br><span class="line">    --- PASS: TestOlder/FirstOlderThanSecond (0.00s)</span><br><span class="line">        person_test.go:33: [SETUP] Hello 👋!</span><br><span class="line">        person_test.go:71: [TEST] Hello from subtest FirstOlderThanSecond</span><br><span class="line">        person_test.go:37: [TEARDOWN] Bye, <span class="built_in">bye</span> 🖖!</span><br><span class="line">    --- PASS: TestOlder/SecondOlderThanFirst (0.00s)</span><br><span class="line">        person_test.go:33: [SETUP] Hello 👋!</span><br><span class="line">        person_test.go:71: [TEST] Hello from subtest SecondOlderThanFirst</span><br><span class="line">        person_test.go:37: [TEARDOWN] Bye, <span class="built_in">bye</span> 🖖!</span><br><span class="line">PASS</span><br><span class="line">ok  person0.005s</span><br></pre></td></tr></table></figure><p>进一步的，每个包的测试文件其实都包含一个“隐藏”的<code>TestMain(m *testing.M)</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若重写该函数，在<code>m.Run</code>上下加入<code>Setup</code>和<code>Teardown</code>后便得到了全局的初始化和清理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupSubtest</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"[SETUP] Hello 👋!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teardownSubtest</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"[TEARDOWN] Bye, bye 🖖!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">    setupSubtest()</span><br><span class="line">    code := m.Run()</span><br><span class="line">    teardownSubtest(t)</span><br><span class="line">    os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;表格驱动测试可谓是最受欢迎的测试方法了，它抽取了相似用例的公共步骤，结构清晰，维护简单，比如：&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="测试" scheme="http://www.lyyyuna.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Go" scheme="http://www.lyyyuna.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能分析 - 如何理解系统平均负载</title>
    <link href="http://www.lyyyuna.com/2020/06/25/perftest-analysis-load-average/"/>
    <id>http://www.lyyyuna.com/2020/06/25/perftest-analysis-load-average/</id>
    <published>2020-06-25T08:30:38.000Z</published>
    <updated>2020-12-31T15:00:01.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的文章已经详细讨论了平均负载的含义，并尝试解释其合理性，现在我们来看一下大佬 Brendan Gregg 对该指标的看法。</p><p>本文大部分内容翻译、删减并理解自<a href="http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html" target="_blank" rel="noopener">Linux Load Averages: Solving the Mystery</a>。</p><p><a href="http://www.lyyyuna.com/2020/05/29/perftest-analysis-cpu1/">第一篇文章</a>，uptime 的 man 帮助文档有个未解之谜：为什么 Linux 上平均负载不仅关注可运行的任务，也关注<strong>不可中断睡眠</strong>状态的任务？我从未看到过官方的解释（也许有，但我没找到）。本文将解答这一问题，让每个开发者都能理解并运用这一指标。</p><p>Linux 的平均负载是<strong>系统平均负载</strong>，它显示的是系统对运行和等待线程（任务）数量的需求。既然这个指标是需求，那它有可能比系统正处理的任务数量多。大部分工具会显示三个数值，分别是 1 分钟，5 分钟和 15 分钟的平均负载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 16:48:24 up  4:11,  1 user,  load average: 25.25, 23.40, 23.46</span><br><span class="line"></span><br><span class="line">top - 16:48:42 up  4:12,  1 user,  load average: 25.25, 23.14, 23.37</span><br><span class="line"></span><br><span class="line">$ cat /proc/loadavg </span><br><span class="line">25.72 23.19 23.35 42/3411 43603</span><br></pre></td></tr></table></figure><p>对指标的解释：</p><ul><li>如果平均值是 0.0，那说明系统处于空闲状态。</li><li>如果 1 分钟内的平均负载高于 5 分钟和 15 分钟，那说明负载正在升高。</li><li>如果 1 分钟内的平均负载低于 5 分钟和 15 分钟，那说明负载正在降低。</li><li>如果数值高于 CPU 数量，那可能有性能问题。</li></ul><p>由这三个数值，你可以判断出负载在升高或降低。单个数值也有参考意义，比如企业云服务的伸缩可以据此作参考。单个数值<code>23-25</code>没有意义，有了其他信息比如 CPU 数量，你才能判断 CPU 是否处于瓶颈。分析性能，我通常会用一些其它指标来辅助分析，而不是在平均负载这一数值上死磕。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>最原始的平均负载只计算对 CPU 的需求：运行进程数量+就绪进程数量。在 1973 年 8 月的<a href="https://tools.ietf.org/html/rfc546" target="_blank" rel="noopener">RFC 546 TENEX Load Averages</a>有一个漂亮的解释：</p><blockquote><p>[1] The TENEX load average is a measure of CPU demand. The load average is an average of the number of runnable processes over a given time period. For example, an hourly load average of 10 would mean that (for a single CPU system) at any time during that hour one could expect to see 1 process running and 9 others ready to run (i.e., not blocked for I/O) waiting for the CPU.</p></blockquote><p>翻译：</p><blockquote><p>TENEX 平均负载是对 CPU 需求的度量。平均负载是一段时间内可运行进程的平均数量。例如在单核系统上，一小时内平均负载是 10，说明在这一小时内的任意的时刻都可以看到有 1 个进程在运行，另外 9 个处于就绪态（就绪不是指阻塞于 I/O）。</p></blockquote><p>这个版本的<a href="https://tools.ietf.org/html/rfc546" target="_blank" rel="noopener">RFC 546</a>有一张来自 1973.7 的扫描手绘图，显示系统负载指标已经使用了数十年：</p><p><img src="/img/posts/perf-cpu/rfc546.jpg" alt="手绘图"></p><p><a href="https://github.com/PDP-10/tenex" target="_blank" rel="noopener">TENEX的源码</a>现在还能找到，以下是一段 DEC 汇编语言的摘录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NRJAVS==3               ;平均负载的数量</span><br><span class="line">GS RJAV,NRJAVS          ;活跃进程的指数平均值</span><br><span class="line">[...]</span><br><span class="line">;更新可运行任务的平均数量</span><br><span class="line"></span><br><span class="line">DORJAV: MOVEI 2,^D5000</span><br><span class="line">        MOVEM 2,RJATIM          ;指定下次更新的时刻</span><br><span class="line">        MOVE 4,RJTSUM           ;当前时刻 NBPROC+NGPROC 的积分值，对于离散函数，此处积分为求和</span><br><span class="line">        SUBM 4,RJAVS1           ;与上个值的差值</span><br><span class="line">        EXCH 4,RJAVS1</span><br><span class="line">        FSC 4,233               ;FLOAT IT</span><br><span class="line">        FDVR 4,[5000.0]         ;过去 5000ms 内的平均值</span><br><span class="line">[...]</span><br><span class="line">;指数计算数组 EXP(-T/C)，其中 T=5s</span><br><span class="line"></span><br><span class="line">EXPFF:  EXP 0.920043902 ;C = 1 MIN</span><br><span class="line">        EXP 0.983471344 ;C = 5 MIN</span><br><span class="line">        EXP 0.994459811 ;C = 15 MIN</span><br></pre></td></tr></table></figure><p>Linux 源码里也硬编码了 1 分钟、5 分钟和 15 分钟的常量。以下是<a href="https://github.com/torvalds/linux/blob/master/include/linux/sched/loadavg.h" target="_blank" rel="noopener">include/linux/sched/loadavg.h</a>的代码摘录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define EXP_1           1884            /* 1/exp(5sec/1min) as fixed-point */</span><br><span class="line">#define EXP_5           2014            /* 1/exp(5sec/5min) */</span><br><span class="line">#define EXP_15          2037            /* 1/exp(5sec/15min) */</span><br></pre></td></tr></table></figure><h2 id="三个数值"><a href="#三个数值" class="headerlink" title="三个数值"></a>三个数值</h2><p>这三个数值代表公式会分别计算 1 分钟、5 分钟和 15 分钟内的平均负载，采样间隔为 5 秒。可换算成公式后，你会发现它们不是真的在计算平均值，更不需要连续采样 1 分钟、5 分钟和 15 分钟。汇编可读性差，让我们换成等价的 python 伪代码就一目了然：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">e_1 = <span class="number">0.920043902</span>  </span><br><span class="line">e_5 = <span class="number">0.983471344</span></span><br><span class="line">e_15 = <span class="number">0.994459811</span></span><br><span class="line"></span><br><span class="line">e = e_1</span><br><span class="line"></span><br><span class="line">s = <span class="number">0</span></span><br><span class="line">ls = [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">    s = (<span class="number">1</span>-e) * <span class="number">1</span> + e * s</span><br><span class="line">    ls.append(s)</span><br><span class="line"></span><br><span class="line">print(ls[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 如果 num = 12，即 12*5=60s</span></span><br><span class="line"><span class="comment"># 那 ls[-1] == 0.6321230185169127</span></span><br></pre></td></tr></table></figure><p>这是一种离散化的<strong>指数平滑法</strong>，1, 5, 15 仅是在公式计算不同的指数常量，公式每个采样周期迭代计算，所得是估计值。</p><p>拿一个单核空闲系统做实验，从 0 时刻起启动一个单线程 CPU 跑满的任务，那 60 秒后， 1 分钟平均负载显示约为 0.62，与上述伪代码理论计算值 0.63 相当。如果负载一直持续，最终 1 分钟平均负载为 1。</p><p><img src="/img/posts/perf-cpu/loadavg.png" alt="系统负载实验 - 指数衰减可视化图"></p><p>更多公式和实验的讨论，请参考 Dr. Neil Gunther 的文章 <a href="http://www.teamquest.com/import/pdfs/whitepaper/ldavg1.pdf" target="_blank" rel="noopener">How It Works</a>，也可以参考 Linux 源码中的<a href="https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c" target="_blank" rel="noopener">注释</a>。</p><h2 id="Linux-不可中断任务"><a href="#Linux-不可中断任务" class="headerlink" title="Linux 不可中断任务"></a>Linux 不可中断任务</h2><p>当平均负载指标第一次出现在 Linux 上时，和其它操作系统一样，它只反映了系统对 CPU 的需求。然而不久之后，Linux 把处于不可中断状态（<code>TASK_UNINTERRUPTIBLE</code>或<code>nr_uninterruptible</code>）的任务数量也纳入其中。阻塞于磁盘 I/O 和某些锁的进程即为不可中断进程，这些进程不能被信号量打断。在<code>ps</code>和<code>top</code>命令中，这些进程被标注为<code>D</code>状态，ps(1) 帮助文档中称之为“不可中断睡眠（通常是IO）”。</p><p>加入不可中断状态意味着若磁盘（或者 NFS）I/O 工作负载升高，测量的系统负载也会升高。对来自其它操作系统阵营的使用者，这无疑会给他们误解。</p><p>为什么？为什么 Linux 要这么做？</p><p>有数不清的文章指出了 Linux 系统负载的多面性，但无一解释这么做的动机。我猜测，Linux 这么做是想从总体上反映系统需求。</p><h2 id="不可中断任务的起源"><a href="#不可中断任务的起源" class="headerlink" title="不可中断任务的起源"></a>不可中断任务的起源</h2><p>该改动早于 2005 年，2005 年以前，Linux 并不是由 git 管理的，所以没有 git commit history 来确认当时合入的动机。我在 <a href="http://oldlinux.org/Linux.old/mail-archive/" target="_blank" rel="noopener">oldlinux.org</a> 备份的邮件列表中翻到了这么一封邮件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">From: Matthias Urlichs &lt;urlichs@smurf.sub.org&gt;</span><br><span class="line">Subject: Load average broken ?</span><br><span class="line">Date: Fri, 29 Oct 1993 11:37:23 +0200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The kernel only counts &quot;runnable&quot; processes when computing the load average.</span><br><span class="line">I don&apos;t like that; the problem is that processes which are swapping or</span><br><span class="line">waiting on &quot;fast&quot;, i.e. noninterruptible, I/O, also consume resources.</span><br><span class="line"></span><br><span class="line">It seems somewhat nonintuitive that the load average goes down when you</span><br><span class="line">replace your fast swap disk with a slow swap disk...</span><br><span class="line"></span><br><span class="line">Anyway, the following patch seems to make the load average much more</span><br><span class="line">consistent WRT the subjective speed of the system. And, most important, the</span><br><span class="line">load is still zero when nobody is doing anything. ;-)</span><br><span class="line"></span><br><span class="line">--- kernel/sched.c.orig Fri Oct 29 10:31:11 1993</span><br><span class="line">+++ kernel/sched.c  Fri Oct 29 10:32:51 1993</span><br><span class="line">@@ -414,7 +414,9 @@</span><br><span class="line">    unsigned long nr = 0;</span><br><span class="line"></span><br><span class="line">    for(p = &amp;LAST_TASK; p &gt; &amp;FIRST_TASK; --p)</span><br><span class="line">-       if (*p &amp;&amp; (*p)-&gt;state == TASK_RUNNING)</span><br><span class="line">+       if (*p &amp;&amp; ((*p)-&gt;state == TASK_RUNNING) ||</span><br><span class="line">+                  (*p)-&gt;state == TASK_UNINTERRUPTIBLE) ||</span><br><span class="line">+                  (*p)-&gt;state == TASK_SWAPPING))</span><br><span class="line">            nr += FIXED_1;</span><br><span class="line">    return nr;</span><br><span class="line"> &#125;</span><br><span class="line">--</span><br><span class="line">Matthias Urlichs        \ XLink-POP N|rnberg   | EMail: urlichs@smurf.sub.org</span><br><span class="line">Schleiermacherstra_e 12  \  Unix+Linux+Mac     | Phone: ...please use email.</span><br><span class="line">90491 N|rnberg (Germany)  \   Consulting+Networking+Programming+etc&apos;ing      42</span><br></pre></td></tr></table></figure><p>改动是由 Matthias 引入，最终在<code>Linux 0.99.14</code>中合入。从邮件中可以确认，平均负载的这一改动就是为了反映对系统资源的总体需求：即 CPU 平均负载 –&gt; 系统资源负载。</p><p>27 年前，Matthias 用慢速 swap 磁盘做例子是合理的：swap 磁盘拖慢了系统性能，那平均负载这一指标理应升高，然而按当时的计算方法，平均负载反而会降低，因为该指标只计入了处于可运行状态的任务，而慢速 swap 磁盘导致的大量任务不可运行没有被统计在内。这显然有悖常理，所以 Matthias 提交了这一补丁。</p><h2 id="如今的不可中断任务"><a href="#如今的不可中断任务" class="headerlink" title="如今的不可中断任务"></a>如今的不可中断任务</h2><p>除了磁盘 I/O, CPU 外还有别的原因会导致 Linux 平均负载升高吗？是的，虽然我猜测在 1993 年时，还没有其它代码路径会设置 <code>TASK_UNINTERRUPTIBLE</code>。在<code>Linux 0.99.14</code>，有 13 条代码路径会直接设置<code>TASK_UNINTERRUPTIBLE</code>或<code>TASK_SWAPPING</code>（后来 Linux 移除了 swap 状态）。而在 2017 年的<code>Linux 4.12</code>，则有 400 多种可能会设置<code>TASK_UNINTERRUPTIBLE</code>，包括一些锁原语。</p><p>既然可能性如此之多，是不是每种都和系统负载有关？本文作者给 Matthias 发邮件询问了此事，Matthias 则回复：</p><blockquote><p>“The point of “load average” is to arrive at a number relating how busy the system is from a human point of view. TASK_UNINTERRUPTIBLE means (meant?) that the process is waiting for something like a disk read which contributes to system load. A heavily disk-bound system might be extremely sluggish but only have a TASK_RUNNING average of 0.1, which doesn’t help anybody.”</p></blockquote><p>翻译如下：</p><blockquote><p>“平均负载”的意义在于从人的角度描述系统的繁忙程度。TASK_UNINTERRUPTIBLE 意味着（过去意味着？）进程在等待某些资源，比如读磁盘，这些行为会增加系统负载。疯狂读磁盘的系统性能奇差，但此刻 TASK_RUNNING 任务的平均数量只有 0.1，单看这个值也就没参考意义了。</p></blockquote><p>Matthias 仍认为这么计算是对的，不过给出的解释仍和 93 年相同。</p><p>但是现在有更多的情况会让任务处于<code>TASK_UNITERRUPTIBLE</code>状态，是否应该改进计算平均负载的算法，剪去多余分支呢？Linux 调度器维护者 Peter Zijstra 给出了一种解法：用<code>task_struct-&gt;in_iowait</code>替换<code>TASK_UNITERRUPTIBLE</code>，这样平均负载仍然反映对 CPU 和磁盘的需求。</p><p>但绕了这么一大圈，真的测到我们想要的了吗？我们是要反映对系统线程的需求，还是反映对物理资源的需求？如果是前者，那由于不可中断锁而阻塞的线程也应纳入统计，因为系统需要这些线程，它们并不是空闲的。</p><p>为了更好地理解不可中断的代码路径，首先我们需要一种度量进程各阶段实际耗时的方法，然后才能量化每个场景所花的时间，检验平均负载这一指标能否切合实际。</p><h2 id="测量不可中断任务"><a href="#测量不可中断任务" class="headerlink" title="测量不可中断任务"></a>测量不可中断任务</h2><p>下图是一个生产环境服务器的 off-CPU 火焰图（On-CPU 是任务在CPU上运行的消耗，off-CPU 就是任务由于某种原因阻塞的消耗，如等待IO，等待锁，等待定时器，等待内存页面的swap等），测量持续了 60 秒，并过滤出了处于<code>TASK_UNINTERRUPTIBLE</code>的任务的内核栈：</p><object type="image/svg+xml" data="/img/posts/perf-cpu/out.offcputime_unint02.svg"></object><p>完整的栈显示出来就像一把火焰，你可以点击放大查看火焰图的细节。x 轴上的长度正比于阻塞 off-CPU 的时间，顺序是随机的。上图显示 60s 内只有 926ms 的时间处于不可中断睡眠，只给平均负载增加了 0.015。其中大部分是 cgroup 调用，系统本身并没有太多磁盘 I/O。</p><p>接下来这张图更有趣，测量只持续了 10 秒：</p><object type="image/svg+xml" data="/img/posts/perf-cpu/out.offcputime_unint01.svg"></object><p>图中用洋红色高亮的栈帧均是<code>rwsem_down_read_failed()</code>，加起来增加了 0.3 的平均负载。让我们摘录<code>rwsem_down_read_failed()</code>的部分代码，可以看到其在获取锁时给任务设置了<code>TASK_UNINTERRUPTIBLE</code>状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* wait to be given the lock */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    set_task_state(tsk, TASK_UNINTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">if</span> (!waiter.task)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 锁有不可中断(mutex_lock(), down())和可中断(mutex_lock_interruptible(), down_interruptible())两个版本，可中断版本允许信号绕过锁机制唤醒阻塞的任务。通常不可中断锁的睡眠时间很短，一般不影响平均负载，但在这个例子中，增加了 0.30。如果该值在上一个数量级，那就有必要做深入的性能分析，以减少锁竞争来降低平均负载。</p><p>这么看来，那些阻塞于不可中断锁上的线程也会造成 Linux 软件资源的紧缺，计算负载时不能只关注硬件资源（CPU，磁盘I/O）。</p><h2 id="分解-Linux-平均负载"><a href="#分解-Linux-平均负载" class="headerlink" title="分解 Linux 平均负载"></a>分解 Linux 平均负载</h2><p>平均负载只是一个数，能否分解出其中的各个部分呢？看这个例子：在一个 8 核的系统上，用<code>tar</code>解压文件，一共用时数分钟，大部分时间阻塞于读磁盘。然后用<code>pidstat</code>, <code>iostat</code>, <code>uptime</code>在三个窗口同时收集性能信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">terma$ pidstat -p `pgrep -x tar` 60</span><br><span class="line">Linux 4.9.0-rc5-virtual (bgregg-xenial-bpf-i-0b7296777a2585be1)     08/01/2017  _x86_64_    (8 CPU)</span><br><span class="line"></span><br><span class="line">10:15:51 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">10:16:51 PM     0     18468    2.85   29.77    0.00   32.62     3  tar</span><br><span class="line"></span><br><span class="line">termb$ iostat -x 60</span><br><span class="line">[...]</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.54    0.00    4.03    8.24    0.09   87.10</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">xvdap1            0.00     0.05   30.83    0.18   638.33     0.93    41.22     0.06    1.84    1.83    3.64   0.39   1.21</span><br><span class="line">xvdb            958.18  1333.83 2045.30  499.38 60965.27 63721.67    98.00     3.97    1.56    0.31    6.67   0.24  60.47</span><br><span class="line">xvdc            957.63  1333.78 2054.55  499.38 61018.87 63722.13    97.69     4.21    1.65    0.33    7.08   0.24  61.65</span><br><span class="line">md0               0.00     0.00 4383.73 1991.63 121984.13 127443.80    78.25     0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line"></span><br><span class="line">termc$ uptime</span><br><span class="line"> 22:15:50 up 154 days, 23:20,  5 users,  load average: 1.25, 1.19, 1.05</span><br><span class="line">[...]</span><br><span class="line">termc$ uptime</span><br><span class="line"> 22:17:14 up 154 days, 23:21,  5 users,  load average: 1.19, 1.17, 1.06</span><br></pre></td></tr></table></figure><p>最后是 60 秒内的 off-CPU 火焰图：</p><object type="image/svg+xml" data="/img/posts/perf-cpu/out.offcputime_unint08.svg"></object><p>uptime 显示倒数一分钟时系统负载为 1.25，最后一分钟的平均负载为 1.19。</p><p>让我们来尝试分解：</p><ul><li>0.33 来自 tar 的 CPU 时间(pidstat)</li><li>41164/60000=0.69 来自 tar 的不可中断磁盘读（火焰图）</li><li>(3684+3102)/60000=0.11 来自内核的不可中断磁盘I/O - 刷新磁盘（火焰图的最左两个高峰）</li><li>0.04 来自其它任务（iostat 统计出总的 user+system 时间 - tar 的 CPU 时间）</li></ul><p>代入指数平滑算法：<code>(0.33+0.69+0.11+0.04)*0.62 + 1.25*0.38 = 1.17*0.62 + 1.25*0.38 = 1.2</code>。非常接近 uptime 测得的 1.19。</p><p>这个系统只有一个主要线程 tar，和其它一些辅助和内核线程，Linux 报告 平均负载 1.19 是合理的。如果只测量<strong>CPU 平均负载</strong>，那就是<code>0.33+0.04=0.37</code>，并没有反馈出系统压力真正的来源。</p><h2 id="让-Linux-平均负载有意义"><a href="#让-Linux-平均负载有意义" class="headerlink" title="让 Linux 平均负载有意义"></a>让 Linux 平均负载有意义</h2><ul><li>在 Linux 系统上，平均负载是<strong>系统平均负载</strong>，统计的对象多种多样：运行状态的线程和因为某些原因等待运行的线程（CPU、磁盘、不可中断锁）。优点是能对整个系统做度量，方便使用者从整体把握性能状态。</li><li>在其它操作系统上，平均负载是<strong>CPU 平均负载</strong>，测量的是可运行线程数量。优点是易于理解，看到指标就知道问题在哪。</li></ul><h2 id="什么是“好”或“坏”的平均负载"><a href="#什么是“好”或“坏”的平均负载" class="headerlink" title="什么是“好”或“坏”的平均负载"></a>什么是“好”或“坏”的平均负载</h2><ul><li>平均负载对系统监控有参考意义：当数值超过某一绝对值时，应用延迟必定很高，性能会出现瓶颈，但这个绝对值不具备通用性。</li><li>平均负载是一段时间内（&gt; 1min）的平均值，同样 1 的平均负载即可能是持续稳定的负载，也可能是一个突发的高负载。</li><li>其它操作系统中的 CPU 平均负载可以按这个公式归一化：<code>CPU 平均负载/CPU 个数</code>。</li><li>不同应用场景对系统延迟的容忍度不同。比如双核 CPU 邮件服务器的归一化值约为 11-16，但邮件协议不是即时通信协议，实时性不高，用户不会抱怨。（而其它应用用户所能容忍的归一化值不会高于 2）</li><li>在 Linux 中，平均负载包含<code>TASK_UNINTERRUPTIBLE</code>，所以不能使用归一化的值。</li></ul><h2 id="更好的指标"><a href="#更好的指标" class="headerlink" title="更好的指标"></a>更好的指标</h2><p>在 Linux 系统上，光靠平均负载不能定位问题，这里介绍介绍一些其它指标。</p><ul><li>查看每个 CPU 的利用率，<code>mpstat -P ALL 1</code></li><li>查看每个进程的 CPU 利用率，<code>top</code>, <code>pidstat 1</code></li><li>查看每个线程的调度延迟，<code>/proc/PID/schedstats</code>,<code>delaystats</code>, <code>perf sched</code></li><li>查看 CPU 调度队列的长度，<code>vmstat 1</code>的<code>r</code>列</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在 1993 年，一位 Linux 工程师发现原先的平均负载斌不直观，随即将定义从“CPU 平均负载”永远地改成了“系统平均负载”。新算法把不可中断任务也纳入其中，以便反映出对磁盘资源的需求。算法仍然使用指数平滑法估计 1, 5 和 15 分钟内的负载，通过这三个值可以判断负载升高还是降低。</p><p>随着 Linux 内核的发展，不可中断的代码路径不断丰富，现在还包含了不可中断锁原语等。但 93 年的算法不需要改变，因为系统负载含义丰富了，多出来的代码路径正好能覆盖这些负载。</p><p>本文删减了作者的原文，一些定位系统负载问题的方法可以翻阅上两篇文章。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>Saltzer, J., and J. Gintell. “<a href="http://web.mit.edu/Saltzer/www/publications/instrumentation.html" target="_blank" rel="noopener">The Instrumentation of Multics</a>,” CACM, August 1970 (explains exponentials).</li><li>Multics <a href="http://web.mit.edu/multics-history/source/Multics/doc/privileged/system_performance_graph.info" target="_blank" rel="noopener">system_performance_graph</a> command reference (mentions the 1 minute average).</li><li><a href="https://github.com/PDP-10/tenex" target="_blank" rel="noopener">TENEX</a> source code (load average code is in SCHED.MAC).</li><li><a href="https://tools.ietf.org/html/rfc546" target="_blank" rel="noopener">RFC 546</a> “TENEX Load Averages for July 1973” (explains measuring CPU demand).</li><li>Bobrow, D., et al. “TENEX: A Paged Time Sharing System for the PDP-10,” Communications of the ACM, March 1972 (explains the load average triplet).</li><li>Gunther, N. “UNIX Load Average Part 1: How It Works” <a href="http://www.teamquest.com/import/pdfs/whitepaper/ldavg1.pdf" target="_blank" rel="noopener">PDF</a> (explains the exponential calculations).</li><li>Linus’s email about <a href="http://www.linuxmisc.com/30-linux-announce/4543def681c7f27b.htm" target="_blank" rel="noopener">Linux 0.99 patchlevel 14</a>.</li><li>The load average change email is on <a href="http://oldlinux.org/Linux.old/mail-archive/" target="_blank" rel="noopener">oldlinux.org</a> (in alan-old-funet-lists/kernel.1993.gz, and not in the linux directories, which I searched first).</li><li>The Linux kernel/sched.c source before and after the load average change: <a href="http://kernelhistory.sourcentral.org/linux-0.99.13/?f=/linux-0.99.13/S/449.html%23L332" target="_blank" rel="noopener">0.99.13</a>, <a href="http://kernelhistory.sourcentral.org/linux-0.99.14/?f=/linux-0.99.14/S/323.html%23L412" target="_blank" rel="noopener">0.99.14</a>.</li><li>Tarballs for Linux 0.99 releases are on <a href="https://www.kernel.org/pub/linux/kernel/Historic/v0.99/" target="_blank" rel="noopener">kernel.org</a>.</li><li>The current Linux load average code: <a href="https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c" target="_blank" rel="noopener">loadavg.c</a>, <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched/loadavg.h" target="_blank" rel="noopener">loadavg.h</a></li><li>The bcc analysis tools includes my <a href="http://www.brendangregg.com/blog/2016-01-20/ebpf-offcpu-flame-graph.html" target="_blank" rel="noopener">offcputime</a>, used for tracing TASK_UNINTERRUPTIBLE.</li><li><a href="http://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener">Flame Graphs</a> were used for visualizing uninterruptible paths.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的文章已经详细讨论了平均负载的含义，并尝试解释其合理性，现在我们来看一下大佬 Brendan Gregg 对该指标的看法。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="测试" scheme="http://www.lyyyuna.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Linux 性能分析" scheme="http://www.lyyyuna.com/tags/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能分析 - 上下文切换</title>
    <link href="http://www.lyyyuna.com/2020/06/18/perftest-analysis-cpu2/"/>
    <id>http://www.lyyyuna.com/2020/06/18/perftest-analysis-cpu2/</id>
    <published>2020-06-18T08:30:38.000Z</published>
    <updated>2020-06-21T09:27:13.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="/2020/05/29/perftest-analysis-cpu1/">上一篇文章</a>中提到，处于可运行状态的进程越多，平均负载也越高。</p><p>有人可能会有疑问，这种计算方法合理吗？同样是 100% 的 CPU 使用率，有 10 个可运行进程的系统的平均负载，是有 1 个可运行进程系统的负载的 10 倍？本文就试图从 CPU 上下文切换的角度来解释这一指标的合理性。</p><h1 id="上下文切换定义"><a href="#上下文切换定义" class="headerlink" title="上下文切换定义"></a>上下文切换定义</h1><h2 id="CPU-上下文切换"><a href="#CPU-上下文切换" class="headerlink" title="CPU 上下文切换"></a>CPU 上下文切换</h2><p>虽然系统的 CPU 个数有限，但能支持同时运行个任务。当然这种同时只是宏观上的假象，如果从微观角度观察，会发现系统在不停轮流切换任务，使得每个任务都能获得运行的机会。</p><p>CPU 是状态 + 存储的模型，其符合图灵机这种理想设备：</p><ol><li>内存</li><li>PC 指针指向下一条待运行的指令（状态）</li><li>计算规则</li><li>其他辅助计算的寄存器（状态）</li></ol><p>多任务的每个任务都有自己的状态。当任务 1 切出，任务 2 切入时，CPU 的状态也要切换成任务 2 上一次切出时的状态，这样任务 2 才能继续运行。这些状态即是 CPU 上下文，CPU 上下文切换即保存和恢复 PC 和辅助计算的寄存器。</p><h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><p>CPU 中的寄存器似乎一只手就数的过来，切换的成本非常小，为什么会造成系统负载显著升高呢？Linux 操作系统中的任务有进程和线程，切换的主要成本来自于进程/线程的上下文切换。</p><p>第一点，现代处理器有很多个运行等级。比如在 x86 的保护模式中，有四种特权等级。Linux 使用 Ring 0 和 Ring 3：</p><p><img src="/img/posts/perf-cpu/450px-Priv_rings.svg.png" alt="x86 保护模式下特权等级"></p><ol><li>Ring 0 是内核空间，具有最高权限，可访问所有硬件资源</li><li>Ring 3 是用户空间，权限最低，无法直接访问硬件资源</li></ol><p>用户态权限有限，无法直接操作所有寄存器，进程的切换只能由内核态来管理和调度，所以必然发生用户态 <-> 内核态的频繁转换。而每个特权等级运行的代码不同，所以在切换用户态 <-> 内核态时，内核/用户空间本身的 CPU 上下文也需要互相切换。</-></-></p><p>第二点，进程本身的数据结构庞大。Linux 中使用数据结构 <code>task_struct</code> 来描述进程所有的资源，其主要成员有进程状态、内核栈信息、进程使用状态、PID、优先级、锁、时间片、队列、信号量、内存管理信息、文件列表等等与进程管理、调度密切相关的信息。当切换进程运行，这些数据结构也需要保存和恢复。</p><p>第三点，虚拟内存。内核为每个进程提供了一个假象：进程都是独占地使用内存，这种独占是无法感知也无法使用其它进程的内存。</p><p>虚拟内存和实际的物理内存之间映射不是一个地址一个地址的映射，而是通过页表机制来实现。一页通常是 4096KB，这样的映射关系即为页表数据，为了减少页表数据的大小，会采用多级页表，比如 Linux 为了让进程支持 256T 内存，采用了四级页表。页表机制会带来额外的问题，页表本身也是存在内存里的，四级页表最坏情况下需要 5 次内存 IO 才能获取一个真正的内存数据。</p><p>为了让操作系统更快地操作虚拟内存，x86 处理器专门提供了 TLB(Translation Lookaside Buffer) 来管理虚拟内存到物理内存的映射关系。它可以理解为一个专用缓存，特点就是快，但缺点是存储的数据少，缓存有可能不命中。当系统发生进程切换，从进程 A 切换到进程 B，TLB 也必须刷新，那在刷新后，进程 B 必然会出现 TLB 不命中的情况，导致虚拟内存访问变慢。</p><p>由以上三点可见，进程上下文切换开销巨大，根据 <a href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html" target="_blank" rel="noopener">Tsuna</a>的测试报告，这一过程会持续数千纳秒。如果进程切换频繁，系统真正运行进程的时间便不够了。</p><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>在 Linux 的实现中，系统调度的基本单位其实是线程，进程是线程的集合，同一个进程的线程看到的虚拟内存是共享的，所以：</p><ol><li>如果切换的两个线程分属不同的进程，因为资源不共享，其切换成本等同于进程上下文切换。</li><li>如果切换的两个线程属于同一个进程，因为虚拟内存是共享的，刷新 TLB 没有必要，切换成本也就少。</li></ol><h2 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h2><p>为了快速响应硬件事件，Linux 中发生中断也会打断进程的正常执行，这时候就会发生中断上下文切换。</p><p>中断程序执行于内核空间，与任何进程无关，故用户态进程程序切换到中断处理程序时，没有虚拟内存切换的成本，保持 TLB 不变即可。</p><h2 id="上下文切换的时机"><a href="#上下文切换的时机" class="headerlink" title="上下文切换的时机"></a>上下文切换的时机</h2><p>切换分两种，自愿和非自愿：</p><ol><li>自愿上下文切换(voluntary context switches)。比如当前进程所需资源未满足时，便会挂起等待。又比如调用睡眠函数 sleep 这样的方法将自己主动挂起。</li><li>非自愿上下文切换(non voluntary context switches)。操作系统为保证调度的公平性，会将时间分片，轮流分给每个进程。进程若在自己的时间片内未执行完，便会被系统强制切出 CPU。Linux 系统还支持带优先级的进程，高优先级进程可以打断低优先级进程。</li></ol><p>有一点需要强调，虽然用<code>ps aux</code>能看到数百个进程，但并非意味着 Linux 需要在这数百个进程上切换。它们大部分处于睡眠状态，操作系统只会对处于可运行态的进程间作上下文切换。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>vmstat 命令帮助文档虽然说是 Report virtual memory statistics，但其实它还能统计 CPU/中断/IO/缺页等使用情况。</p><p>以下是该命令每隔 1 秒输出一次统计数据，输出 10 次（第一次的输出不可信）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ vmstat 1 10</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0    524 2010216 1195432 10930004    0    0     0    50    1    2  4  2 92  3  0</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>我们需要关心的是：</p><ol><li>r，可运行进程的个数（运行和就绪的进程）</li><li>b，不可中断进程的个数</li><li>in，每秒中断次数，包括时钟</li><li>cs，每秒 CPU 上下文切换次数</li><li>us，执行用户代码的时间</li><li>sy，执行内核代码的时间</li></ol><p>vmstat 命令还不够，<a href="/2020/05/29/perftest-analysis-cpu1/">上一篇文章</a>中介绍的 pidstat 可以看到进程上下文切换的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ pidstat -w 5</span><br><span class="line">Linux 4.15.0-96-generic (work) 06/20/2020 _x86_64_(2 CPU)</span><br><span class="line"></span><br><span class="line">11:46:00 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">11:46:05 PM     0         1      1.00      0.00  systemd</span><br><span class="line">11:46:05 PM     0         7     12.38      0.00  ksoftirqd/0</span><br><span class="line">11:46:05 PM     0         8    132.93      0.00  rcu_sched</span><br><span class="line">11:46:05 PM     0        11      0.20      0.00  watchdog/0</span><br><span class="line">11:46:05 PM     0        14      0.20      0.00  watchdog/1</span><br><span class="line">11:46:05 PM     0        16     12.97      0.00  ksoftirqd/1</span><br><span class="line">11:46:05 PM     0       207     25.15      0.00  usb-storage</span><br><span class="line">11:46:05 PM     0       209      7.98      0.00  kworker/0:1H</span><br><span class="line">11:46:05 PM     0       330      2.00      0.00  jbd2/sda2-8</span><br><span class="line">11:46:05 PM     0       333      0.40      0.00  kworker/1:1H</span><br><span class="line">11:46:05 PM     0       436      2.00      1.00  systemd-udevd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>cswch/s，每秒自愿上下文切换次数</li><li>nvcswch/s，每秒非自愿上下文切换次数</li></ol><p>如果要看到线程上下文切换的信息，还需要加上 -t 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ pidstat -w 5 -t</span><br><span class="line">Linux 4.15.0-96-generic (work) 06/20/2020 _x86_64_(2 CPU)</span><br><span class="line"></span><br><span class="line">11:50:28 PM   UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">11:50:33 PM     0      4588         -      0.20      0.20  pili-themisd</span><br><span class="line">11:50:33 PM     0         -      4588      0.20      0.20  |__pili-themisd</span><br><span class="line">11:50:33 PM     0         -      4589     13.44      0.20  |__pili-themisd</span><br><span class="line">11:50:33 PM     0         -      4590      1.98      0.00  |__pili-themisd</span><br><span class="line">11:50:33 PM     0         -      4594      3.75      0.00  |__pili-themisd</span><br><span class="line">11:50:33 PM     0         -      4596      4.55      1.19  |__pili-themisd</span><br><span class="line">11:50:33 PM     0         -      4650      3.95      0.40  |__pili-themisd</span><br><span class="line">11:50:33 PM     0         -      4674      2.96      0.40  |__pili-themisd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="进程和线程的实验"><a href="#进程和线程的实验" class="headerlink" title="进程和线程的实验"></a>进程和线程的实验</h2><h3 id="stress-进程切换实验"><a href="#stress-进程切换实验" class="headerlink" title="stress 进程切换实验"></a>stress 进程切换实验</h3><p>我们回到最开始的问题，为什么同样是 100% 的 CPU 使用率，有 10 个可运行进程的系统的平均负载，是有 1 个可运行进程系统的负载的 10 倍？</p><p>首先看一下 100% CPU，1 个可运行进程的上下文切换次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ stress -c 1 -t 600</span><br><span class="line">stress: info: [6800] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line">➜  ~ vmstat 1 20</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 294216 274960 2234876    0    0     0    24 2714 7362 54  1 45  0  0</span><br><span class="line"> 2  0      0 294208 274960 2234876    0    0     0    68 2327 6601 59  2 39  1  0</span><br><span class="line"> 2  0      0 294216 274960 2234880    0    0     0   116 1555 4465 53  2 45  0  1</span><br><span class="line"></span><br><span class="line">➜  ~ pidstat -w 1</span><br><span class="line">Average:      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">Average:        0      9258      0.00     64.39  stress</span><br></pre></td></tr></table></figure><p>首先看一下 100% CPU，10 个可运行进程的上下文切换次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ stress -c 10 -t 600</span><br><span class="line">stress: info: [7024] dispatching hogs: 10 cpu, 0 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line">➜  ~ vmstat 1 20</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">10  0      0 294972 274976 2234964    0    0     0    28 2097 5976 99  2  0  0  0</span><br><span class="line">13  0      0 294900 274976 2234976    0    0     0   176 2256 6545 98  2  0  0  0</span><br><span class="line">10  0      0 295040 274976 2234976    0    0     0    28 2254 6835 99  1  0  0  1</span><br><span class="line"></span><br><span class="line">➜  ~ pidstat -w 1</span><br><span class="line">Average:      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">Average:        0      7025      0.00    160.97  stress</span><br><span class="line">Average:        0      7026      0.00    125.14  stress</span><br><span class="line">Average:        0      7027      0.00    136.82  stress</span><br><span class="line">Average:        0      7028      0.00    162.62  stress</span><br><span class="line">Average:        0      7029      0.00    121.83  stress</span><br><span class="line">Average:        0      7030      0.00    170.89  stress</span><br><span class="line">Average:        0      7031      0.00    114.99  stress</span><br><span class="line">Average:        0      7032      0.00    130.54  stress</span><br><span class="line">Average:        0      7033      0.00    165.38  stress</span><br><span class="line">Average:        0      7034      0.00    163.51  stress</span><br></pre></td></tr></table></figure><p>光看 CPU 上下文切换次数似乎差不多，但进程被动上下文切换次数明显上升。我们之前了解到，CPU 切换的成本较小，进程的切换成本最高，这就是系统负载升高的原因。</p><h3 id="sysbench-线程切换实验"><a href="#sysbench-线程切换实验" class="headerlink" title="sysbench 线程切换实验"></a>sysbench 线程切换实验</h3><p>stress 命令只能模拟多进程的系统压力，模拟多线程需要 sysbench 工具。</p><p>运行以下命令模拟 10 个线程竞争：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sysbench --threads=10 --max-time=300 threads run</span><br><span class="line"></span><br><span class="line">➜  ~ uptime</span><br><span class="line"> 08:41:12 up 69 days,  5:33,  2 users,  load average: 6.32, 6.32, 6.73</span><br><span class="line"></span><br><span class="line">➜  ~ vmstat 1 20</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 8  0      0 292580 275072 2237844    0    0     0    28 15202 1234282 30 69  2  0  0</span><br><span class="line"> 8  0      0 292332 275072 2237848    0    0     0   224 18851 1221323 31 68  1  0  1</span><br><span class="line"> 8  0      0 292280 275072 2237848    0    0     0    28 16822 1177891 32 66  2  0  0</span><br><span class="line"></span><br><span class="line">➜  ~ pidstat -w -t 1 (需要加上 -t，否则不会统计线程的切换信息)</span><br><span class="line">Average:        0         -     11743  19613.96  96288.49  |__sysbench</span><br><span class="line">Average:        0         -     11744  20440.57  93726.42  |__sysbench</span><br><span class="line">Average:        0         -     11745  20680.38  99453.02  |__sysbench</span><br><span class="line">Average:        0         -     11746  19855.47  89219.06  |__sysbench</span><br><span class="line">Average:        0         -     11747  18738.49  97730.38  |__sysbench</span><br><span class="line">Average:        0         -     11748  14536.04  99870.75  |__sysbench</span><br><span class="line">Average:        0         -     11749  15928.11 103604.72  |__sysbench</span><br><span class="line">Average:        0         -     11750  18082.26  94775.66  |__sysbench</span><br><span class="line">Average:        0         -     11751  20995.66  89222.64  |__sysbench</span><br><span class="line">Average:        0         -     11752  20588.30  94581.89  |__sysbench</span><br></pre></td></tr></table></figure><p>在多线程下，每秒 CPU 上下文切换次数达到了近 120 万，任务的自愿和非自愿切换同时升高。当然系统负载自然也就高了。</p><h3 id="两者的不同"><a href="#两者的不同" class="headerlink" title="两者的不同"></a>两者的不同</h3><p>同样是调度 10 个任务，stress 和 sysbench 为什么切换次数区别如此之大？可以从两方面解释：</p><p>第一、同一个进程的线程间切换成本小，切换的频率可以升高。</p><p>第二、sysbench 和 stress 模拟压力的方式不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sysbench threads help</span><br><span class="line">sysbench 1.0.11 (using system LuaJIT 2.1.0-beta3)</span><br><span class="line"></span><br><span class="line">threads options:</span><br><span class="line">  --thread-yields=N number of yields to do per request [1000]</span><br><span class="line">  --thread-locks=N  number of locks per thread [8]</span><br><span class="line"></span><br><span class="line">➜  ~ stress --help</span><br><span class="line">`stress&apos; imposes certain types of compute stress on your system</span><br><span class="line"></span><br><span class="line">Usage: stress [OPTION [ARG]] ...</span><br><span class="line"> -c, --cpu N        spawn N workers spinning on sqrt()</span><br></pre></td></tr></table></figure><ol><li>sysbench 用线程同步方式 (lock) 和主动让出 CPU (yield) 来产生系统压力，属于自愿上下文切换，统计数据中自愿切换的次数非 0。</li><li>stress 用 CPU 密集型操作 (求根 sqrt()) 来产生系统压力，属于非自愿上下文切换，统计数据中自愿切换的次数为 0。</li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在 CPU 跑满，系统平均负载均很高的情况下，需要具体情况具体分析：</p><ol><li>自愿上下文切换变多，说明被调度任务在等待资源，有可能发生了 IO 或任务间同步情况</li><li>非自愿上下文切换变多，说明被调度的任务被强制打断，任务在争抢使用 CPU</li><li>如果上下文切换次数离奇的高，说明有可能是多线程场景</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;/2020/05/29/perftest-analysis-cpu1/&quot;&gt;上一篇文章&lt;/a&gt;中提到，处于可运行状态的进程越
      
    
    </summary>
    
      <category term="测试" scheme="http://www.lyyyuna.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Linux 性能分析" scheme="http://www.lyyyuna.com/tags/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能分析 - 如何理解 CPU 平均负载</title>
    <link href="http://www.lyyyuna.com/2020/05/29/perftest-analysis-cpu1/"/>
    <id>http://www.lyyyuna.com/2020/05/29/perftest-analysis-cpu1/</id>
    <published>2020-05-29T08:36:38.000Z</published>
    <updated>2020-12-31T15:00:01.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="平均负载的定义"><a href="#平均负载的定义" class="headerlink" title="平均负载的定义"></a>平均负载的定义</h2><p><code>uptime</code>是最简单的性能分析命令之一，它的输出非常简单，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 16:08:29 up 42 days,  5:11,  2 users,  load average: 0.33, 0.22, 0.22</span><br></pre></td></tr></table></figure><p>前面几列易于理解，分别是当前时间，系统已运行时间，登录的用户数。可是最后的平均负载是什么？查看<code>uptime</code>帮助文档对其的定义：</p><blockquote><p>System load averages is the average number of processes that are either in a runnable or uninterruptable state. A  process in a runnable state is either using the CPU or waiting to use the CPU. A process in uninterruptable state is waiting for some I/O access, eg waiting for disk. The averages are taken over the three time intervals. Load averages are not normalized for the number of CPUs in a system, so a load average of 1 means a single CPU system is loaded all the time while on a 4 CPU system it means it was idle 75% of the time.</p></blockquote><p>大概翻译过来就是：</p><blockquote><p>系统的平均负载是指处于可运行和不可中断状态的进程平均数量。所谓可运行状态是指正在使用或等待使用 CPU，而不可中断状态是指进程正执行某种 I/O 操作，比如读写磁盘。平均负载会计算 1 分钟、5 分钟和 15 分钟内的该指标。不过需要注意的是，该数据没有针对 CPU 个数作归一化处理，所以平均负载 1 在单核系统上意味满负载运行，而在 4 核系统上意味着只使用了 25% 的负载。</p></blockquote><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><h3 id="操作系统进程的基本状态"><a href="#操作系统进程的基本状态" class="headerlink" title="操作系统进程的基本状态"></a>操作系统进程的基本状态</h3><p>在操作系统的概念中，进程会不断改变其运行状态，其必须有以下三种基本状态：</p><ol><li>就绪：进程所需要的资源都已经获得，但是还没有分配到 CPU 来运行</li><li>运行：进程分配到 CPU 在运行</li><li>阻塞：进程的某些资源还没有满足，比如缓冲区申请未分配，等待 I/O 完成</li></ol><h3 id="Linux-进程的基本状态"><a href="#Linux-进程的基本状态" class="headerlink" title="Linux 进程的基本状态"></a>Linux 进程的基本状态</h3><p>相比于标准的操作系统概念，Linux 中对于状态有自己的划分：</p><ol><li>D 不可中断睡眠，最常见的是正在访问硬件设备，若中断会导致磁盘数据和进程数据不一致</li><li>R 运行和就绪，对，Linux 上这两个状态是被统计在一起的</li><li>S 可中断睡眠，比如进程正在等待信号唤醒</li><li>T 停止，是处于调试状态的进程</li><li>Z 僵尸进程，即父进程未等待子进程退出</li></ol><h2 id="理解定义"><a href="#理解定义" class="headerlink" title="理解定义"></a>理解定义</h2><p>由上述 Linux 的进程定义，所谓可运行和不可中断状态就是活跃的进程，即正在使用 CPU/等待 CPU/等待 IO 的进程，而平均负载可理解为单位时间内活跃进程的数量。</p><p>如果每个核上都正好跑着一个进程，则说明 CPU 被充分的利用。那么平均负载为 4 在一个四核处理器上就是 CPU 刚好被完全占用，而在单核处理器上，意味着有 3 个进程得不到 CPU，只能干等。</p><h3 id="平均负载与-CPU-利用率"><a href="#平均负载与-CPU-利用率" class="headerlink" title="平均负载与 CPU 利用率"></a>平均负载与 CPU 利用率</h3><p>在未看过本文之前，你很可能将平均负载和 CPU 利用率划上等号，事实上，这是两个独立的概念。</p><ul><li>对于 CPU 密集型进程，因为大量利用了 CPU，故而平均负载升高</li><li>对于 I/O 密集型进程，虽然 CPU 利用率不高，但是大量进程都阻塞住，使得活跃进程数量增加，所以平均负载也会升高</li><li>对于有大量等待调度的进程，这些进程都处于就绪态，平均负载也高。而且由于上下文切换，进程数量多，切换的机会也多，这无形中也增加了负载</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>我们就上文提到的三个场景，分别做实验来模拟。</p><p>我们实验所用的系统是 ubuntu 18，机器配置为 2 CPU/16 GB。</p><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><p>工欲善其事，必先利其器。有很多现成的工具可以模拟负载，监控和分析系统性能。</p><ol><li><code>stress</code>可以用来对系统施加指定类型的系统压力，它并不是一个基准测试工具</li><li><code>mpstat</code>是一个多核的 CPU 性能分析工具，可以统计每个 CPU 的性能</li><li><code>pidstat</code>是一个多进程性能分析工具，可以统计每个进程的性能</li></ol><p>实验开始时首先查看一下系统的负载情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 15:23:16 up 51 days,  4:26,  1 user,  load average: 0.15, 0.30, 0.31</span><br></pre></td></tr></table></figure><p>确认一下系统的是否是 2 核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/cpuinfo | grep processor</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="CPU-密集型"><a href="#CPU-密集型" class="headerlink" title="CPU 密集型"></a>CPU 密集型</h3><p>我们利用<code>stress</code>模拟一个 CPU 跑满的场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stress --cpu 1 --timeout 600</span><br></pre></td></tr></table></figure><p>过两分钟后查看<code>uptime</code>查看平均负载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 15:41:09 up 51 days,  4:44,  2 users,  load average: 1.18, 0.77, 0.49</span><br></pre></td></tr></table></figure><p>可以看到系统负载越升越高，1 分钟内的平均负载高于 5 分钟内平均负载。</p><p>使用<code>mpstat</code>查看 CPU 利用率的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ALL 表示输出所有 CPU 的情况，5 表示每隔 5s 输出一次</span><br><span class="line">$ mpstat -P ALL 5</span><br><span class="line">03:42:26 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">03:42:31 PM  all   51.96    0.00    1.01    0.81    0.00    0.10    0.00    0.00    0.00   46.12</span><br><span class="line">03:42:31 PM    0    3.44    0.00    2.02    1.62    0.00    0.20    0.00    0.00    0.00   92.71</span><br><span class="line">03:42:31 PM    1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br></pre></td></tr></table></figure><p>可以看到其中一个 CPU 利用率飙到了 100%，这个是平均负载升高的直接原因。</p><p>使用<code>pidstat</code>查看具体是哪个进程占用了 CPU：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 5 表示每隔 5s 输出一次</span><br><span class="line">$ pidstat -u 5</span><br><span class="line">Linux 4.15.0-96-generic (work) 06/07/2020 _x86_64_(2 CPU)</span><br><span class="line"></span><br><span class="line">03:46:19 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">03:46:24 PM     0     10766    0.20    0.20    0.00    0.60    0.40     0  redis-server</span><br><span class="line">03:46:24 PM  1000     27225   99.80    0.00    0.00    0.00   99.80     1  stress</span><br><span class="line">03:46:24 PM  1000     27583    0.00    0.20    0.00    0.00    0.20     0  pidstat</span><br></pre></td></tr></table></figure><p>虽然输出有很多行，但我们很容易就发现是<code>stress</code>这个进程使用了 100% 的 CPU。</p><h3 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h3><p>我们还是使用<code>stress</code>模拟 I/O 压力</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stress -i 1 --timeout 600</span><br></pre></td></tr></table></figure><p>过两分钟后查看<code>uptime</code>查看平均负载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 15:53:43 up 51 days,  4:57,  2 users,  load average: 1.09, 0.94, 0.85</span><br></pre></td></tr></table></figure><p>平均负载果然升高了。</p><p>同时我们看一下 CPU 利用率的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">03:54:43 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">03:54:48 PM  all    2.57    0.00    3.81   29.35    0.00    1.75    0.00    0.00    0.00   62.51</span><br><span class="line">03:54:48 PM    0    2.49    0.00    3.53   45.95    0.00    3.33    0.00    0.00    0.00   44.70</span><br><span class="line">03:54:48 PM    1    2.86    0.00    4.09   12.88    0.00    0.20    0.00    0.00    0.00   79.96</span><br></pre></td></tr></table></figure><p>可以看到两个 CPU 都没有被占满。但是<code>%iowait</code>这一项和上一小节有明显的差异，<code>%iowait</code>即是反映 I/O 压力的情况。</p><p>我们接着用<code>pidstat</code>查看具体是哪个进程导致的<code>%iowait</code>升高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -u 5</span><br><span class="line">Linux 4.15.0-96-generic (work) 06/07/2020 _x86_64_(2 CPU)</span><br><span class="line"></span><br><span class="line">03:59:31 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">03:59:36 PM     0         7    0.00    0.20    0.00    0.00    0.20     0  ksoftirqd/0</span><br><span class="line">03:59:36 PM     0         8    0.00    0.20    0.00    0.20    0.20     0  rcu_sched</span><br><span class="line">03:59:36 PM     0       209    0.00    1.20    0.00    0.00    1.20     0  kworker/0:1H</span><br><span class="line">03:59:36 PM   112      2047    0.20    0.20    0.00    0.00    0.40     1  beam.smp</span><br><span class="line">03:59:36 PM     0      9976    0.00    0.20    0.00    0.00    0.20     1  supervisord</span><br><span class="line">03:59:36 PM     0      9981    0.40    0.00    0.00    0.00    0.40     1  mongod</span><br><span class="line">03:59:36 PM     0     10071    0.40    0.00    0.00    0.00    0.40     1  mongod</span><br><span class="line">03:59:36 PM     0     10072    0.40    0.00    0.00    0.00    0.40     0  mongod</span><br><span class="line">03:59:36 PM     0     10073    0.40    0.20    0.00    0.00    0.60     0  mongod</span><br><span class="line">03:59:36 PM     0     10765    0.20    0.00    0.00    0.00    0.20     1  redis-server</span><br><span class="line">03:59:36 PM     0     10766    0.20    0.20    0.00    0.60    0.40     0  redis-server</span><br><span class="line">03:59:36 PM     0     10821    0.20    0.00    0.00    0.00    0.20     1  redis-server</span><br><span class="line">03:59:36 PM  1000     27741    0.00    7.19    0.00    1.40    7.19     0  stress</span><br></pre></td></tr></table></figure><p>可以看到<code>%wait</code>这一项高的还是<code>stress</code>进程。</p><h3 id="大量等待调度的进程"><a href="#大量等待调度的进程" class="headerlink" title="大量等待调度的进程"></a>大量等待调度的进程</h3><p><code>stress</code>可以模拟出处于运行态的进程，以下模拟出 10 个待调度的进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stress -c 10 --timeout 600</span><br></pre></td></tr></table></figure><p>过两分钟后查看<code>uptime</code>查看平均负载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"> 16:09:20 up 51 days,  5:12,  2 users,  load average: 9.38, 4.54, 2.35</span><br></pre></td></tr></table></figure><p>平均负载又升高了，而且远高于以上两个实验，这也是当然的，根据平均负载的定义，这里有 10 个处于可运行的进程，那么平均负载的值肯定会接近 10。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -u 5</span><br><span class="line">Linux 4.15.0-96-generic (work) 06/07/2020 _x86_64_(2 CPU)</span><br><span class="line"></span><br><span class="line">04:11:59 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">04:12:04 PM     0         8    0.00    0.20    0.00    0.20    0.20     0  rcu_sched</span><br><span class="line">04:12:04 PM     0      9976    0.20    0.00    0.00    0.00    0.20     1  supervisord</span><br><span class="line">04:12:04 PM     0      9981    0.60    0.00    0.00    0.00    0.60     1  mongod</span><br><span class="line">04:12:04 PM     0     10071    0.20    0.00    0.00    0.00    0.20     1  mongod</span><br><span class="line">04:12:04 PM     0     10072    0.20    0.00    0.00    0.00    0.20     0  mongod</span><br><span class="line">04:12:04 PM     0     10073    0.20    0.00    0.00    0.00    0.20     0  mongod</span><br><span class="line">04:12:04 PM     0     10260    0.40    0.20    0.00    0.00    0.60     1  mongod</span><br><span class="line">04:12:04 PM     0     10261    0.40    0.00    0.00    0.00    0.40     1  mongod</span><br><span class="line">04:12:04 PM     0     10262    0.20    0.00    0.00    0.00    0.20     1  mongod</span><br><span class="line">04:12:04 PM     0     10763    0.20    0.00    0.00    0.20    0.20     1  redis-server</span><br><span class="line">04:12:04 PM     0     10764    0.20    0.00    0.00    0.20    0.20     1  redis-server</span><br><span class="line">04:12:04 PM     0     10766    0.20    0.20    0.00    0.80    0.40     0  redis-server</span><br><span class="line">04:12:04 PM     0     10820    0.20    0.00    0.00    0.00    0.20     1  redis-server</span><br><span class="line">04:12:04 PM  1000     28242   19.48    0.00    0.00   80.12   19.48     0  stress</span><br><span class="line">04:12:04 PM  1000     28243   19.28    0.00    0.00   80.12   19.28     1  stress</span><br><span class="line">04:12:04 PM  1000     28244   19.28    0.00    0.00   80.12   19.28     0  stress</span><br><span class="line">04:12:04 PM  1000     28245   19.28    0.00    0.00   79.72   19.28     1  stress</span><br><span class="line">04:12:04 PM  1000     28246   19.48    0.00    0.00   80.12   19.48     0  stress</span><br><span class="line">04:12:04 PM  1000     28247   19.28    0.00    0.00   79.92   19.28     0  stress</span><br><span class="line">04:12:04 PM  1000     28248   19.48    0.00    0.00   79.92   19.48     1  stress</span><br><span class="line">04:12:04 PM  1000     28249   19.48    0.00    0.00   80.52   19.48     1  stress</span><br><span class="line">04:12:04 PM  1000     28250   19.48    0.00    0.00   80.12   19.48     1  stress</span><br><span class="line">04:12:04 PM  1000     28251   19.48    0.00    0.00   80.52   19.48     0  stress</span><br></pre></td></tr></table></figure><p>可以看到有 10 个<code>stress</code>进程在抢 2 个 CPU。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过本文我们了解到：平均负载与 CPU 利用率没有必然联系。而当发现负载升高后，需要综合使用<code>uptime</code>, <code>mpstat</code>, <code>pidstat</code>等工具来分析是上述哪三个场景，从而找到负载升高的来源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;平均负载的定义&quot;&gt;&lt;a href=&quot;#平均负载的定义&quot; class=&quot;headerlink&quot; title=&quot;平均负载的定义&quot;&gt;&lt;/a&gt;平均负载的定义&lt;/h2&gt;&lt;p&gt;&lt;code&gt;uptime&lt;/code&gt;是最简单的性能分析命令之一，它的输出非常简单，比如：&lt;/p&gt;

      
    
    </summary>
    
      <category term="测试" scheme="http://www.lyyyuna.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Linux 性能分析" scheme="http://www.lyyyuna.com/tags/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Golang 并发模式 - Context</title>
    <link href="http://www.lyyyuna.com/2020/05/25/go-concurrency-pattern-context/"/>
    <id>http://www.lyyyuna.com/2020/05/25/go-concurrency-pattern-context/</id>
    <published>2020-05-25T14:19:02.000Z</published>
    <updated>2020-06-07T04:46:30.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译+删选+理解自 <a href="https://blog.golang.org/context" target="_blank" rel="noopener">Go Concurrency Patterns: Context</a></p><p>在使用 Go 编写的服务器程序中，每个请求都由一个 goroutine 来处理，通常这些请求又会启动额外的 goroutines 来访问后台数据库或者调用 RPC 服务。这些与同一个请求相关的 goroutines，常常需要访问同一个特定的资源，比如用户标识，认证 token 等等。当请求取消或者超时时，所有相关的 goroutines 都应该快速退出，这样系统才能回收不用的资源。</p><p>为此，Google 公司开发了<a href="https://golang.org/pkg/context" target="_blank" rel="noopener">context</a>包。该库可以跨越 API 边界，给所有 goroutines 传递请求相关的值、取消信号和超时时间。这篇文章会介绍如何使用<a href="https://golang.org/pkg/context" target="_blank" rel="noopener">context</a>库，并给出一个完整的例子。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><code>context</code>包的核心是<code>Context</code>结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this Context is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    Err() error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Done</code>方法返回一个 channel，它会给<code>Context</code>上所有的函数发送取消信号，当 channel 关闭时，这些函数应该终止剩余流程立即返回。<code>Err</code>方法返回的错误指出了<code>Context</code>为什么取消。<a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">Pipelines and Cancelation</a>中讨论了<code>Done</code>的具体用法。</p><p>由于接收和发送信号的通常不是同一个函数，<code>Context</code>并没有提供<code>Cancel</code>方法，基于相同的理由，<code>Done</code>channel 只负责接收。尤其当父操作开启 goroutines 执行子操作时，子操作肯定不能取消父操作。作为替代，<code>WithCancel</code>函数可以用来取消<code>Context</code>。</p><p><code>Context</code>对 goroutines 来说是并发安全的，你可以将单个<code>Context</code>传递给任意数量的 goroutines，然后取消该<code>Context</code>给这些 goroutines 同时发送信号。</p><p><code>Deadline</code>方法用于判断函数究竟要不要运行，比如截止时间将近时，运行也就没必要了。代码可依此为 I/O 操作设置超时时间。</p><p><code>Value</code>方法则为<code>Context</code>存储了请求所有的数据，访问这些数据必须是并发安全的。</p><h2 id="Context-派生"><a href="#Context-派生" class="headerlink" title="Context 派生"></a>Context 派生</h2><p>使用<code>Context</code>包提供的方法可以从已有的<code>Context</code>值派生出新值。这些派生出的值逻辑上构成了一棵树：当根<code>Context</code>取消，其派生出的子<code>Context</code>也会跟着取消。</p><p><code>Background</code>是所有<code>Context</code>树的根，它永远不会被取消：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Background returns an empty Context. It is never canceled, has no deadline,</span></span><br><span class="line"><span class="comment">// and has no values. Background is typically used in main, init, and tests,</span></span><br><span class="line"><span class="comment">// and as the top-level Context for incoming requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p><code>WithCancel</code>和<code>WithTimeout</code>函数返回的派生<code>Context</code>值，可以先于父值取消。当请求的回调函数返回后，与请求相关的<code>Context</code>即可被取消。当有多个备份后台程序同时提供服务时，<code>WithCancel</code>可用于去除多余的请求。<code>WithTimeout</code>则可用于为请求设置超时时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithCancel returns a copy of parent whose Done channel is closed as soon as</span></span><br><span class="line"><span class="comment">// parent.Done is closed or cancel is called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A CancelFunc cancels a Context.</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WithTimeout returns a copy of parent whose Done channel is closed as soon as</span></span><br><span class="line"><span class="comment">// parent.Done is closed, cancel is called, or timeout elapses. The new</span></span><br><span class="line"><span class="comment">// Context's Deadline is the sooner of now+timeout and the parent's deadline, if</span></span><br><span class="line"><span class="comment">// any. If the timer is still running, the cancel function releases its</span></span><br><span class="line"><span class="comment">// resources.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p><code>WithValue</code>则在<code>Context</code>上存储了请求相关的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithValue returns a copy of parent whose Value method returns val for key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><h2 id="例子：谷歌网页搜索"><a href="#例子：谷歌网页搜索" class="headerlink" title="例子：谷歌网页搜索"></a>例子：谷歌网页搜索</h2><p>本例子提供一个 HTTP 服务器，接收类似<code>/search?q=golang&amp;timeout=1s</code>的 GET 请求，并把查询参数值”golang”转推到<a href="https://developers.google.com/web-search/docs/" target="_blank" rel="noopener">谷歌网页搜索API</a>。参数<code>timeout</code>告诉服务器如果谷歌 API 超时就取消请求。</p><p>代码分为三个包：</p><ul><li><a href="https://blog.golang.org/context/server/server.go" target="_blank" rel="noopener">server</a>提供 main 函数，处理<code>/search</code>来的请求。</li><li><a href="https://blog.golang.org/context/userip/userip.go" target="_blank" rel="noopener">userip</a>提供的函数将用户 IP 地址绑定到一个<code>Context</code>值上。 </li><li><a href="https://blog.golang.org/context/google/google.go" target="_blank" rel="noopener">google</a>提供 Search 函数将请求转发到谷歌。</li></ul><h2 id="server-程序"><a href="#server-程序" class="headerlink" title="server 程序"></a>server 程序</h2><p><a href="https://blog.golang.org/context/server/server.go" target="_blank" rel="noopener">server</a>中，请求回调创建了一个名为<code>ctx</code>的<code>Context</code>值，当回调退出时，延迟函数<code>defer cancel()</code>即执行取消操作。如果请求的 URL 带有 timeout 参数，那超时后<code>Context</code>会自动取消：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSearch</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ctx is the Context for this handler. Calling cancel closes the</span></span><br><span class="line">    <span class="comment">// ctx.Done channel, which is the cancellation signal for requests</span></span><br><span class="line">    <span class="comment">// started by this handler.</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        ctx    context.Context</span><br><span class="line">        cancel context.CancelFunc</span><br><span class="line">    )</span><br><span class="line">    timeout, err := time.ParseDuration(req.FormValue(<span class="string">"timeout"</span>))</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// The request has a timeout, so create a context that is</span></span><br><span class="line">        <span class="comment">// canceled automatically when the timeout expires.</span></span><br><span class="line">        ctx, cancel = context.WithTimeout(context.Background(), timeout)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx, cancel = context.WithCancel(context.Background())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// Cancel ctx as soon as handleSearch returns.</span></span><br></pre></td></tr></table></figure><p>回调函数从请求中获取参数信息，并调用<code>userip</code>包获取客户端 IP 地址。由于后台服务中会使用到客户端 IP 地址，故需要将此存储于<code>ctx</code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check the search query.</span></span><br><span class="line">query := req.FormValue(<span class="string">"q"</span>)</span><br><span class="line"><span class="keyword">if</span> query == <span class="string">""</span> &#123;</span><br><span class="line">    http.Error(w, <span class="string">"no query"</span>, http.StatusBadRequest)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the user IP in ctx for use by code in other packages.</span></span><br><span class="line">userIP, err := userip.FromRequest(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ctx = userip.NewContext(ctx, userIP)</span><br></pre></td></tr></table></figure><p>传入<code>ctx</code>和<code>query</code>参数调用<code>google.Search</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run the Google search and print the results.</span></span><br><span class="line">start := time.Now()</span><br><span class="line">results, err := google.Search(ctx, query)</span><br><span class="line">elapsed := time.Since(start)</span><br></pre></td></tr></table></figure><p>如果搜索成功，会渲染出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := resultsTemplate.Execute(w, <span class="keyword">struct</span> &#123;</span><br><span class="line">    Results          google.Results</span><br><span class="line">    Timeout, Elapsed time.Duration</span><br><span class="line">&#125;&#123;</span><br><span class="line">    Results: results,</span><br><span class="line">    Timeout: timeout,</span><br><span class="line">    Elapsed: elapsed,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="userip-包"><a href="#userip-包" class="headerlink" title="userip 包"></a>userip 包</h2><p><a href="https://blog.golang.org/context/userip/userip.go" target="_blank" rel="noopener">userip</a>包提供了解析用户 IP 地址函数的包，同时会将 IP 地址存储于一个<code>Context</code>值中。<code>Context</code>提供了键值对存储，键值都是<code>interface{}</code>类型，键必须可比较，值必须是并发安全。<code>userip</code>包屏蔽了实现上的细节，并以强类型方式访问<code>Context</code>值。</p><p>为了避免键冲突，<code>userip</code>包首先定义一个非导出类型<code>key</code>，然后用该类型定义的值作为<code>Context</code>的键：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The key type is unexported to prevent collisions with context keys defined in</span></span><br><span class="line"><span class="comment">// other packages.</span></span><br><span class="line"><span class="keyword">type</span> key <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// userIPkey is the context key for the user IP address.  Its value of zero is</span></span><br><span class="line"><span class="comment">// arbitrary.  If this package defined other context keys, they would have</span></span><br><span class="line"><span class="comment">// different integer values.</span></span><br><span class="line"><span class="keyword">const</span> userIPKey key = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>FromRequest</code>从<code>http.Request</code>解析出客户端 IP 地址<code>userIP</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromRequest</span><span class="params">(req *http.Request)</span> <span class="params">(net.IP, error)</span></span> &#123;</span><br><span class="line">    ip, _, err := net.SplitHostPort(req.RemoteAddr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"userip: %q is not IP:port"</span>, req.RemoteAddr)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>NewContext</code>将<code>userIP</code>存储于新建的<code>Context</code>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(ctx context.Context, userIP net.IP)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.WithValue(ctx, userIPKey, userIP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FromContext</code>则相反，从<code>Context</code>取出 IP 地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromContext</span><span class="params">(ctx context.Context)</span> <span class="params">(net.IP, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ctx.Value returns nil if ctx has no value for the key;</span></span><br><span class="line">    <span class="comment">// the net.IP type assertion returns ok=false for nil.</span></span><br><span class="line">    userIP, ok := ctx.Value(userIPKey).(net.IP)</span><br><span class="line">    <span class="keyword">return</span> userIP, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="google-包"><a href="#google-包" class="headerlink" title="google 包"></a>google 包</h2><p><code>google.Search</code>函数对谷歌 API 发起 HTTP 请求，并解析 JSON 结果。该函数同时接收一个<code>Context</code>参数<code>ctx</code>，如果请求处理时，<code>ctx.Done</code>关闭了，则立即退出。</p><p>谷歌 API 会将搜索内容和用户 IP 地址<code>userIP</code>作为请求参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>)</span> <span class="params">(Results, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Prepare the Google Search API request.</span></span><br><span class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"https://ajax.googleapis.com/ajax/services/search/web?v=1.0"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    q := req.URL.Query()</span><br><span class="line">    q.Set(<span class="string">"q"</span>, query)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If ctx is carrying the user IP address, forward it to the server.</span></span><br><span class="line">    <span class="comment">// Google APIs use the user IP to distinguish server-initiated requests</span></span><br><span class="line">    <span class="comment">// from end-user requests.</span></span><br><span class="line">    <span class="keyword">if</span> userIP, ok := userip.FromContext(ctx); ok &#123;</span><br><span class="line">        q.Set(<span class="string">"userip"</span>, userIP.String())</span><br><span class="line">    &#125;</span><br><span class="line">    req.URL.RawQuery = q.Encode()</span><br></pre></td></tr></table></figure><p><code>Search</code>使用了辅助函数<code>httpDo</code>来发起和取消 HTTP 请求，辅助函数参数有一个是处理 HTTP 响应的闭包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> results Results</span><br><span class="line">err = httpDo(ctx, req, <span class="function"><span class="keyword">func</span><span class="params">(resp *http.Response, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the JSON search result.</span></span><br><span class="line">    <span class="comment">// https://developers.google.com/web-search/docs/#fonje</span></span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">        ResponseData <span class="keyword">struct</span> &#123;</span><br><span class="line">            Results []<span class="keyword">struct</span> &#123;</span><br><span class="line">                TitleNoFormatting <span class="keyword">string</span></span><br><span class="line">                URL               <span class="keyword">string</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, res := <span class="keyword">range</span> data.ResponseData.Results &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, Result&#123;Title: res.TitleNoFormatting, URL: res.URL&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// httpDo waits for the closure we provided to return, so it's safe to</span></span><br><span class="line"><span class="comment">// read results here.</span></span><br><span class="line"><span class="keyword">return</span> results, err</span><br></pre></td></tr></table></figure><p><code>httpDo</code>函数会在新的 goroutine 中处理 HTTP 请求和响应，同时如果<code>ctx.Done</code>提前关闭，函数会直接退出。</p><h2 id="为-Context-作代码适配"><a href="#为-Context-作代码适配" class="headerlink" title="为 Context 作代码适配"></a>为 Context 作代码适配</h2><p>许多服务器框架已经存储了请求相关值，我们可以实现<code>Context</code>接口的所有方法，来为<code>Context</code>参数适配这些现有框架。而框架的使用者在调用代码时则需要多传入一个<code>Context</code>。</p><p>参考实现：</p><ol><li><a href="https://blog.golang.org/context/gorilla/gorilla.go" target="_blank" rel="noopener">gorilla.go</a>适配了 Gorilla 的<a href="http://www.gorillatoolkit.org/pkg/context" target="_blank" rel="noopener">github.com/gorilla/context</a></li><li><a href="https://blog.golang.org/context/tomb/tomb.go" target="_blank" rel="noopener">tomb.go</a>适配了<a href="https://godoc.org/gopkg.in/tomb.v2" target="_blank" rel="noopener">Tomb</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文翻译+删选+理解自 &lt;a href=&quot;https://blog.golang.org/context&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://www.lyyyuna.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 的版本管理原则</title>
    <link href="http://www.lyyyuna.com/2020/02/22/go-the-principles-versioning-in-go/"/>
    <id>http://www.lyyyuna.com/2020/02/22/go-the-principles-versioning-in-go/</id>
    <published>2020-02-22T08:20:02.000Z</published>
    <updated>2020-02-24T08:45:45.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译+删选+理解自 <a href="https://research.swtch.com/vgo-principles" target="_blank" rel="noopener">The Principles of Versioning in Go</a></p><h2 id="为什么需要版本？"><a href="#为什么需要版本？" class="headerlink" title="为什么需要版本？"></a>为什么需要版本？</h2><p>让我们先看下传统基于<code>GOPATH</code>的<code>go get</code>是如何导致版本管理失败的。</p><p>假设有一个全新安装的 Go 环境，我们需要写一个程序导入<code>D</code>，因此运行<code>go get D</code>。记住现在是基于<code>GOPATH</code>的<code>go get</code>，不是 <code>go mod</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get D</span><br></pre></td></tr></table></figure><p><img src="/img/posts/version-in-go/vgo-why-1@1.5x.png" alt></p><p>该命令会寻找并下载最新版本的<code>D 1.0</code>，并假设现在能成功构建。</p><p>几个月后我们需要一个新的库<code>C</code>，我们接着运行<code>go get C</code>，该库的版本为 1.8。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get C</span><br></pre></td></tr></table></figure><p><img src="/img/posts/version-in-go/vgo-why-2@1.5x.png" alt></p><p><code>C</code>导入<code>D</code>，但是<code>go get</code>发现当前环境内已经下载过<code>D</code>库了，所以 Go 会重复使用该库。不幸的是，本地的<code>D</code>版本是 1.0，而<code>C</code>对<code>D</code>有版本依赖，必须是 1.4 以上（有可能 1.4 有一些 bugfix 或者新 feature）。</p><p>显而易见这里<code>C</code>会构建失败。我们再次运行<code>go get -u C</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u C</span><br></pre></td></tr></table></figure><p><img src="/img/posts/version-in-go/vgo-why-3@2x.png" alt></p><p>不幸的是，（假设）一小时前<code>D</code>的作者发布了<code>D 1.6</code>，该版本又引入了一个缺陷。因为<code>go get -u</code>一直使用最新的依赖，所以使用 1.6 的<code>C</code>又构建失败了。</p><p>由这个例子可以看出，基于<code>GOPATH</code>的<code>go get</code>缺乏版本管理，会导致两种问题，要么版本过低，要么版本过高。我们需要一种机制，<code>C</code>和<code>D</code>的作者能够一起开发和测试。</p><p>自从<code>goinstall/go get</code>推出之后，Go 程序员就对版本管理有着强烈的诉求，过去几年间，很多第三方的工具被开发出来。然而，这些工具对版本控制的细节有着不同的实现和理解，这会导致不同的库若使用不同的工具，库之间仍然无法协同工作。</p><h2 id="软件工程中的版本"><a href="#软件工程中的版本" class="headerlink" title="软件工程中的版本"></a>软件工程中的版本</h2><p>过去两年间（2019），官方试图在<code>go</code>命令中引入<code>Go moduless</code>的概念来支持版本管理。<code>Go moduless</code>带来新的库导入语法——即语义化导入版本(Semantic import versioning)，而在选择版本时，使用了新的算法——即最小版本选择算法。</p><p>你可能会问：为什么不使用其他语言的现成经验？Java 有<code>Maven</code>，Node 有<code>NPM</code>，Ruby 有<code>Bundler</code>，Rust 有<code>Cargo</code>，他们解决版本依赖的思路不好么？</p><p>你可能还会问：Go 团队在 2018 早些时候引入了一个试验性的工具<code>Dep</code>，该工具实现上与<code>Bundler</code>和<code>Cargo</code>一致，现在为啥又变卦了？</p><p>答案是我们从使用<code>Bundler</code>/<code>Cargo</code>/<code>Dep</code>的经验中发现，它们所谓处理依赖的方法，只会使项目越来越复杂，<code>go modules</code>决定另辟蹊径。</p><h2 id="三原则"><a href="#三原则" class="headerlink" title="三原则"></a>三原则</h2><p>回到一个很基础的问题：什么是软件工程？软件工程和编程有什么区别？原作者 Russ Cox 使用了这个定义：</p><blockquote><p>Software engineering is what happens to programming<br>when you add time and other programmers.</p></blockquote><p>为了简化软件工程，<code>Dep</code>和<code>Go moduless</code>在原则上有三个显著的改变，它们是兼容性、可重复性和可合作性。本文余下部分会详细阐述这三个指导思想。</p><h3 id="原则-1：兼容性"><a href="#原则-1：兼容性" class="headerlink" title="原则 #1：兼容性"></a>原则 #1：兼容性</h3><p>第一原则是兼容性，或者称之为稳定性，程序中<strong>名字</strong>的意义不能随着时间改变。一年前一个名字的含义和今年、后年应该完全一致。</p><p>例如，程序员经常会对标准库<code>string.Split</code>的细节困扰。我们期望在<code>&quot;hello world&quot;</code>调用后产生两个字符串<code>&quot;hello&quot;</code>和<code>&quot;world</code>。但是如果函数输入有前、后或着重复的空格，输出结果也会包含空字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example: strings.Split(x, &quot; &quot;)</span><br><span class="line"></span><br><span class="line">&quot;hello world&quot;  =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello  world&quot; =&gt; &#123;&quot;hello&quot;, &quot;&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot; hello world&quot; =&gt; &#123;&quot;&quot;, &quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello world &quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;, &quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p>假设我们决定改变这一行为，去除所有空字符串，可以么？</p><p><strong>不</strong></p><p>因为我们已经在旧版<code>string.Split</code>的文档和实现上达成一致。有无数的程序依赖于这一行为，改变它会破话兼容性原则。</p><p>对于新的行为，正确的做法是给一个新的名字。事实上也是如此，我们没有重新定义<code>strings.Split</code>，几年前，标准库引入了<code>strings.Fields</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example: strings.Fields(x)</span><br><span class="line"></span><br><span class="line">&quot;hello world&quot;  =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello  world&quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot; hello world&quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello world &quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br></pre></td></tr></table></figure><p>遵守兼容性原则可以大大简化软件工程。当程序员理解程序时，你无需把时间纳入考量范围内，2015 年使用的<code>strings.Split</code>和今年使用的<code>strings.Split</code>是一样的。工具也是如此，比如重构工具可以随意地将<code>strings.Split</code>在不同包内移动而不用担心函数含义随着时间发生改变。</p><p>实际上，Go 1 最重要的特性就是其语言不变性。这一特性在官方文档中得到明确，<a href="golang.org/doc/go1compat">golang.org/doc/go1compat</a>：</p><blockquote><p>It is intended that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. Go programs that work today should continue to work even as future “point” releases of Go 1 arise (Go 1.1, Go 1.2, etc.).</p></blockquote><p>所有 Go 1.x 版本的程序在后续版本仍能继续编译，并且正确运行，行为保持不变。今天写了一个 Go 程序，未来它仍能正常工作。Go 官方同样也对标准库中的函数作出了承诺。</p><p>兼容性和版本有啥管理？当今最火的版本管理方法——<a href="https://semver.org/" target="_blank" rel="noopener">语义化版本</a>是鼓励不兼容的，这意味着你可以通过语义化版本号，更轻易地作出不兼容的改变。</p><p>如何理解？</p><p>语义化版本有着<code>vMAJOR.MINOR.PATCH</code>的形式。如果两个版本有着系统的主版本号，那么后一个版本应该向前兼容前一个版本。如果主版本号不同，那他俩就是不兼容的。该方法鼓励包的作者，如果你想作出不兼容的行为，那改变主版本号吧！</p><p>对于 Go 程序来说，光改变主版本号还不够，两个主版本号如果名字一模一样，阅读代码还是会造成困扰。</p><p>看起来，情况变得更加糟糕。</p><p>假设包<code>B</code>期望使用 V1 版本的<code>string.Split</code>，而<code>C</code>期望使用 V2 版本的<code>string.Split</code>。如果<code>B</code>和<code>C</code>是分别构建的，那 OK。</p><p><img src="/img/posts/version-in-go/vgo-why-4@2x.png" alt></p><p>但如果有一个包<code>A</code>同时导入了包<code>B</code>和<code>C</code>呢？那该如何选择<code>string.Split</code>的版本？</p><p><img src="/img/posts/version-in-go/vgo-why-5@2x.png" alt></p><p>针对<code>Go modules</code>的设计思想，官方意识到兼容性是最基础的原则，是必须支持、鼓励和遵循的。Go 的 FAQ 中写到：</p><blockquote><p>Packages intended for public use should try to maintain backwards compatibility as they evolve. The Go 1 compatibility guidelines are a good reference here: don’t remove exported names, encourage tagged composite literals, and so on. If different functionality is required, add a new name instead of changing an old one. If a complete break is required, create a new package with a new import path.</p></blockquote><p>大致意思是如果新旧两个包导入路径相同，那它们就应该被当作是兼容的。</p><p>这和语义化版本有什么关系呢？兼容性原则要求不同主版本号之间不需要有兼容性上的联系，所以，很自然地要求我们使用不同的导入路径。而<code>Go modules</code>中的做法是把主版本号放入导入路径，我们称之为语义化导入版本(Semantic import versioning)。</p><p><img src="/img/posts/version-in-go/impver@2x.png" alt></p><p>在这个例子中，<code>my/thing/v2</code>表示使用版本 2。如果是版本 1，那就是<code>my/thing</code>，没有显式在路径指定版本号，所以路径成为了主版本号的一部分，以此类推，版本 3 的导入路径为<code>my/thing/v3</code>。</p><p>如果<code>strings</code>包是我们开发者自己的模块，我们不想增加新的函数<code>Fields</code>而是重新定义<code>Split</code>，那么可以创建两个模块<code>strings</code>(主版本号 1)和<code>strings/v2</code>(主版本号 2)，这样可以同时存在两个不同的<code>Split</code>。</p><p><img src="/img/posts/version-in-go/vgo-why-6@2x.png" alt></p><p>依据此路径规则，<code>A</code>、<code>B</code>和<code>C</code>都能构建成功，整个程序都能正常运行。开发者和各种工具都能明白它们是不同的包，就像<code>crypto/rand</code>和<code>math/rand</code>是不同的一样显而易见。</p><p>让我们回到那个不可构建的程序。把<code>strings</code>抽象成包<code>D</code>，，这时候若不使用<em>语义化导入版本方法</em>，这样就遇到了经典的“钻石依赖问题”：<code>B</code>和<code>C</code>单独都能构建，但放在一起就不行。如果尝试构建程序<code>A</code>，那该如何选择版本<code>D</code>呢？</p><p><img src="/img/posts/version-in-go/vgo-why-7@2x.png" alt></p><p>语义化导入版本切断了“钻石依赖”。因为<code>D</code>的版本 2.0 有不一样的导入路径，<code>D/v2</code>。</p><p><img src="/img/posts/version-in-go/vgo-why-8@2x.png" alt></p><h3 id="原则-2：可重复性"><a href="#原则-2：可重复性" class="headerlink" title="原则 #2：可重复性"></a>原则 #2：可重复性</h3><p>第二原则是程序构建必须具有可重复性，一个指定版本包的构建结果不应随时间改变。在该原则下，今天我编译代码的结果和其他程序员明年编译的结果是匹配的。<strong>大部分包管理系统并不保证一点</strong>。</p><p>在第一小节我们也看到了，基于<code>GOPATH</code>的<code>go get</code>用的不是最新就是最旧的<code>D</code>。你可能认为，“<code>go get</code>当然会犯错误：它对版本一无所知”。但其实其他一些包管理工具也会犯同样的错误，这里以<code>Dep</code>为例。（<code>Cargo</code>和<code>Bundler</code>也类似）</p><p><code>Dep</code>要求每一个包包含一个<code>manifest</code>来存放元数据，记录下对所有依赖的要求。当<code>Dep</code>下载了<code>C</code>，它读入<code>C</code>的元数据，知道了<code>C</code>需要<code>D 1.4</code>之后的版本。然后<code>Dep</code>下载了最新版本的<code>D</code>来满足这一限制。</p><p>假设在昨天，<code>D</code>最新版本是 1.5：</p><p><img src="/img/posts/version-in-go/vgo-why-9@2x.png" alt></p><p>而今天，<code>D</code>更新为了 1.6：</p><p><img src="/img/posts/version-in-go/vgo-why-10@2x.png" alt></p><p>可以看出，该决策方法是不可重复的，会随时间发生改变。</p><p>当然，<code>Dep</code>的开发者意识到了这一点，它们引入了第二个元数据文件——lock 文件。如果<code>C</code>本身是一个完整的程序，当 Go 调用<code>package main</code>的时候，lock 文件会记录下<code>C</code>使用依赖的确切版本，而当需要重复构建时，lock 文件内所记录的依赖具有更高的优先级。也就是说，lock 文件同样能保证重复性原则。</p><p>但 lock 文件只是针对整体程序而言——<code>package main</code>。如果<code>C</code>被别的更大程序所使用，lock 文件就无效了，库<code>C</code>的构建仍会随着时间的改变而改变。</p><p>而<code>Go modules</code>的算法非常简单，那就是“最小版本选择算法”——每一个包指定其依赖的最低版本号。比如假设<code>B 1.3</code>要求最低<code>D 1.3</code>，<code>C 1.8</code>要求最低<code>D 1.4</code>。<code>Go modules</code>不会选择最新的版本，而是选择最小能满足要求的版本，这样，构建的结果是可重复的。</p><p><img src="/img/posts/version-in-go/vgo-why-12@2x.png" alt></p><p>如果构建的不同部分有不同最低版本要求，<code>go</code>命令会使用最近的那个版本。如图所示，<code>A</code>构建时发现同时有<code>D 1.3</code>和<code>D 1.4</code>的依赖，由于 1.4 大于 1.3，所以构建时会选择<code>D 1.4</code>。<code>D 1.5</code>或者<code>D 1.6</code>存在与否并不会影响该决策。</p><p>在没有 lock 文件的情况下，该算法依然保证了程序和库的可重复性构建。</p><h3 id="原则-3：可合作性"><a href="#原则-3：可合作性" class="headerlink" title="原则 #3：可合作性"></a>原则 #3：可合作性</h3><p>第三原则是可合作性。为了维护 Go 包的生态，我们追求的是一个统一的连贯的系统。相反，我们想避免的是生态分裂，变成一组一组互相之间不可合作的包。</p><p>若开发者们不合作，无论我们使用的工具有多么精巧，技巧多么高超，整个 Go 开源生态一定会走向分裂。这里隐含的意思是，为了修复不兼容性，必须要合作，我们不应排斥合作。</p><p>还是拿库<code>C 1.8</code>举例子，它要求最低版本<code>D 1.4</code>。由于可重复性原则，<code>C 1.8</code>构建会使用<code>D 1.4</code>。如果<code>C 1.8</code>是被其他更大的程序所依赖，且该程序要求<code>D 1.5</code>，那根据最小版本选择算法，会选择<code>D 1.5</code>。这时候构建仍是正确的。</p><p>现在问题来了，<code>D</code> 的作者发布了 1.6 版本，但该版本有问题，<code>C 1.8</code>无法与该版本构建。</p><p><img src="/img/posts/version-in-go/vgo-why-13@2x.png" alt></p><p>解决的方法是<code>C</code>和<code>D</code>的作者合作来发布 fix。解决方法多种多样。</p><p><code>C</code> 可以推出 1.9 版本，规避掉<code>D 1.6</code>中的 bug。</p><p><img src="/img/posts/version-in-go/vgo-why-15@2x.png" alt></p><p><code>D</code> 也可以推出 1.7 版本，修复其存在的 bug。同时，根据兼容性原则，<code>C 1.9</code>可以指定其要求最低<code>D 1.7</code>。</p><p><img src="/img/posts/version-in-go/vgo-why-14@2x.png" alt></p><p>再来复盘一下刚才的故事，最新版本的<code>C</code>和<code>D</code>突然不能一起工作了，这打破了 Go 包的生态，两库的作者必须合作来修复 bug。这种合作对生态是良性的。而正由于<code>Go modules</code>采用的包选择算法/可重复性，那些没有显式指定<code>D 1.6</code>的库都不会被影响。这给了<code>C</code>和<code>D</code>的作者充分的时间来给出最终解决方案。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上是 Go 版本管理的三原则，也是<code>Go modules</code>区别于<code>Dep</code>，<code>Bundler</code>和<code>Cargo</code>的根本原因。</p><ul><li>兼容性，程序中所使用的名字不随时间改变。</li><li>可重复性，指定版本的包构建结果不随时间改变。</li><li>可合作性，为了维护 Go 包的生态，互相必须易于合作。</li></ul><p>三原则来自于对年复一年软件工程的思考，它们互相巩固，是一个良性的循环：兼容性原则使用的版本选择算法带来了可重复性。而可重复性保证除非开发者显式指定，否则构建不会使用最新的、或是有问题的库，这给了我们时间来修复问题。而这种合作性又能保证兼容性。</p><p><code>Go 1.13</code>中，<code>Go modules</code>已经可用于生成环境，很多公司，包括 Google 已经接纳了它。<code>Go 1.14</code>和<code>Go 1.15</code>会带来更多方便开发者的特性，它的最终目标是彻底移除<code>GOPATH</code>。</p><p>具体<code>Go modules</code>的使用方法，可以参考这个系列博客<a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">Using Go Modules</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文翻译+删选+理解自 &lt;a href=&quot;https://research.swtch.com/vgo-principles&quot; target
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://www.lyyyuna.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 中的函数稳定性</title>
    <link href="http://www.lyyyuna.com/2018/07/06/postgres-function-volatile/"/>
    <id>http://www.lyyyuna.com/2018/07/06/postgres-function-volatile/</id>
    <published>2018-07-06T08:36:38.000Z</published>
    <updated>2018-07-06T06:43:12.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>PostgreSQL 中函数有三个稳定性状态可选：</p><ol><li>immutable，函数不可以修改数据库的数据,并且在任何情况下调用，只要输入参数一致，返回结果都一致。</li><li>stable，函数不可以修改数据库的数据，同一个QUERY中，如果需要返回该函数的结果，那么将合并多次运算为一次这个函数。</li><li>volatile，函数可以修改数据库的数据，输入同样的参数可以返回不同的结果，同一个QUERY中，如果需要返回该函数的结果，那么每一行都会运算一遍这个函数。</li></ol><p>函数的稳定性会影响执行计划。在索引比较的时候，被比较的值只会运算一次，所以 volatile 不能被执行计划选择作为索引的比较条件。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="查看函数的稳定性"><a href="#查看函数的稳定性" class="headerlink" title="查看函数的稳定性"></a>查看函数的稳定性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ddei=# select proname, provolatile from pg_proc where proname in (&apos;now&apos;, &apos;clock_timestamp&apos;);</span><br><span class="line">     proname     | provolatile </span><br><span class="line">-----------------+-------------</span><br><span class="line"> now             | s</span><br><span class="line"> clock_timestamp | v</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><p>其中 clock_timestamp 是 voatile, now 是 stable。</p><h3 id="测试插入语句"><a href="#测试插入语句" class="headerlink" title="测试插入语句"></a>测试插入语句</h3><p>创建一个测试表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ddei=# create table test(id int, time1 timestamp, time2 timestamp);</span><br><span class="line">CREATE TABLE</span><br><span class="line">ddei=# insert into test select generate_series(1,1000),clock_timestamp(), now();</span><br><span class="line">INSERT 0 1000</span><br></pre></td></tr></table></figure><p>插入语句，对于 stable 函数 <code>now()</code> 应该只执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ddei=# select count(*),count(distinct time1),count(distinct time2) from test;</span><br><span class="line"> count | count | count </span><br><span class="line">-------+-------+-------</span><br><span class="line">  1000 |  1000 |     1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><h3 id="测试对索引的影响"><a href="#测试对索引的影响" class="headerlink" title="测试对索引的影响"></a>测试对索引的影响</h3><p>在测试表上创建索引，并查看执行计划：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ddei=# create index test_idx on test(time1);</span><br><span class="line">CREATE INDEX</span><br><span class="line">ddei=# </span><br><span class="line">ddei=# explain select * from test where time1&gt;now();</span><br><span class="line">                              QUERY PLAN                              </span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> Index Scan using test_idx on test  (cost=0.00..4.27 rows=1 width=20)</span><br><span class="line">   Index Cond: (time1 &gt; now())</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">ddei=# explain select * from test where time1&gt;clock_timestamp();</span><br><span class="line">                       QUERY PLAN                       </span><br><span class="line">--------------------------------------------------------</span><br><span class="line"> Seq Scan on test  (cost=0.00..22.00 rows=333 width=20)</span><br><span class="line">   Filter: (time1 &gt; clock_timestamp())</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><p>对于 volatile 的函数 clock_timestamp 在 where 条件中，不走索引。而 stable 函数 now 在 where 条件中，会走索引。</p><h2 id="修改函数稳定性"><a href="#修改函数稳定性" class="headerlink" title="修改函数稳定性"></a>修改函数稳定性</h2><p>使用以下语句可修改函数稳定性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ddei=# alter function clock_timestamp() strict stable;</span><br><span class="line">ALTER FUNCTION</span><br></pre></td></tr></table></figure><p>再次测试 clock_timestamp 的索引情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ddei=# explain select * from test where time1&gt;clock_timestamp();</span><br><span class="line">                              QUERY PLAN                              </span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> Index Scan using test_idx on test  (cost=0.00..4.27 rows=1 width=20)</span><br><span class="line">   Index Cond: (time1 &gt; clock_timestamp())</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></p><p>这次 clock_timestamp 在 where 条件中走了索引。</p><p>不过不要随意修改系统自带函数的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;PostgreSQL 中函数有三个稳定性状态可选：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;immutable，函数不可以修改数据库的数据,并且在任何情况
      
    
    </summary>
    
      <category term="数据库" scheme="http://www.lyyyuna.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="PostgreSQL" scheme="http://www.lyyyuna.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>atop 简单使用</title>
    <link href="http://www.lyyyuna.com/2018/07/04/perftest-atop/"/>
    <id>http://www.lyyyuna.com/2018/07/04/perftest-atop/</id>
    <published>2018-07-04T08:36:38.000Z</published>
    <updated>2018-07-04T09:40:31.710Z</updated>
    
    <content type="html"><![CDATA[<p>atop 是一个系统性能监控工具，可以在系统级别监控 CPU、内存、硬盘和网络的使用情况。</p><p>atop 不仅可以以交互式的方式运行，还可以一一定的频率，将性能数据写入日志中。所以当服务器出现问题之后，便可分析 atop 日志文件来判断是否有进程异常退出、内存和 CPU 方面的异常。</p><h2 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h2><h4 id="PRC-Process-level-totals"><a href="#PRC-Process-level-totals" class="headerlink" title="PRC - Process level totals"></a>PRC - Process level totals</h4><ol><li>sys, 内核态下运行时间</li><li>user, 用户态下运行时间</li><li>#proc, 当前所有的进程数量</li><li>#trun, 处于 running 状态下线程数量</li><li>#zombie，僵尸进程的数量</li><li>#exit，采样周期内退出的进程数量</li></ol><h4 id="CPU-CPU-utilization"><a href="#CPU-CPU-utilization" class="headerlink" title="CPU - CPU utilization"></a>CPU - CPU utilization</h4><p>展示所有 CPU 的使用情况。在多处理器的系统中，会展示每一个独立内核的使用情况。</p><ol><li>sys、usr, CPU 被用于处理进程时，进程在内核态、用户态所占CPU的时间比例</li><li>irq, CPU 被用于处理中断的时间比例</li><li>idle, CPU 处在完全空闲状态的时间比例</li><li>wait, CPU 处在“进程等待磁盘IO 导致 CPU 空闲”状态的时间比例</li></ol><h4 id="CPL-CPU-load-information"><a href="#CPL-CPU-load-information" class="headerlink" title="CPL - CPU load information"></a>CPL - CPU load information</h4><p>展示 CPU 的负载情况。</p><ol><li>avg1、avg5和avg15：过去1分钟、5分钟和15分钟内运行队列中的平均进程数量</li><li>csw，指示上下文交换次数</li><li>intr，指示中断发生次数</li></ol><h4 id="MEM-Memory-occupation"><a href="#MEM-Memory-occupation" class="headerlink" title="MEM - Memory occupation"></a>MEM - Memory occupation</h4><ol><li>tot，物理内存总量</li><li>free，空闲内存大小</li><li>cache，页缓存的内存大小</li><li>buff，文件系统缓存的内存大小</li><li>slab，系统内核分配的内存大小</li><li>dirty，页缓存中脏内存的大小</li></ol><h4 id="SWP-Swap-occupation-and-overcommit-info"><a href="#SWP-Swap-occupation-and-overcommit-info" class="headerlink" title="SWP - Swap occupation and overcommit info"></a>SWP - Swap occupation and overcommit info</h4><ol><li>tot，交换区总量</li><li>free，示空闲交换空间大小</li></ol><h4 id="PAG-Paging-frequency"><a href="#PAG-Paging-frequency" class="headerlink" title="PAG - Paging frequency"></a>PAG - Paging frequency</h4><ol><li>swin，换入的页内存数目</li><li>swout， 换出的页内存数目</li></ol><h4 id="DSK-LVM-Disk-utilization-Logical-volumn"><a href="#DSK-LVM-Disk-utilization-Logical-volumn" class="headerlink" title="DSK/LVM - Disk utilization/Logical volumn"></a>DSK/LVM - Disk utilization/Logical volumn</h4><ol><li>busy，磁盘忙时比例</li><li>read，读请求数量</li><li>write，写请求数量</li><li>KiB/r，每次读的千字节数</li><li>Kib/w，每次写的千字节数</li><li>MBr/s，每秒读入兆字节带宽</li><li>MBw/s，每秒写入兆字节带宽</li><li>avio，每次传输所需要的毫秒</li></ol><h4 id="NET-Network-utilization-TCP-IP"><a href="#NET-Network-utilization-TCP-IP" class="headerlink" title="NET - Network utilization (TCP/IP)"></a>NET - Network utilization (TCP/IP)</h4><p>第一行是传输层信息，第二行是 IP 层信息，后面几行是各网卡的信息。</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol><li>g, 通用输出</li><li>m, 展示与内存有关的输出</li><li>d, 展示与硬盘使用有关的输出</li><li>c, 展示每个进程是由哪个命令行启动的</li><li>p, 展示进程相关的活动信息</li><li>C, 按照 CPU 使用排序</li><li>M, 按照内存使用排序</li><li>P, 按下后，即可输入正则表达式来搜索对应进程</li><li>t, 向前一个采样间隔，在分析 atop 日志时使用</li><li>T, 向后一个采样间隔，在分析 atop 日志时使用</li><li>v, 输出更详细的进程信息，包括进程的启动时间，进程号，用户和所在组，当前状态。</li></ol><h2 id="atop日志"><a href="#atop日志" class="headerlink" title="atop日志"></a>atop日志</h2><p>每个时间点采样页面组合起来就形成了一个atop日志文件，我们可以使用”atop -r XXX”命令对日志文件进行查看。</p><p>通常日志文件位于 <code>/var/log/</code>，采样间隔为 10min。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;atop 是一个系统性能监控工具，可以在系统级别监控 CPU、内存、硬盘和网络的使用情况。&lt;/p&gt;
&lt;p&gt;atop 不仅可以以交互式的方式运行，还可以一一定的频率，将性能数据写入日志中。所以当服务器出现问题之后，便可分析 atop 日志文件来判断是否有进程异常退出、内存和 
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Python 实现一个 ORM</title>
    <link href="http://www.lyyyuna.com/2018/04/28/python-orm1/"/>
    <id>http://www.lyyyuna.com/2018/04/28/python-orm1/</id>
    <published>2018-04-28T03:33:31.000Z</published>
    <updated>2018-04-28T03:12:50.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文实现一个非常简单的 ORM 初稿：</p><ol><li>完成 Python 类（模型）与数据库表的映射</li><li>完成类实例与表每行记录的映射</li><li>完成实例操作与增删改查的 SQL 语句的映射</li></ol><p>这个初稿不涉及数据库的真正操作，只是在 <code>user.save()</code> 的时候打印类似 <code>insert into user ...</code> 的 SQL 语句。本文所有代码基于 Python2。</p><h2 id="ORM-为什么需要元类"><a href="#ORM-为什么需要元类" class="headerlink" title="ORM 为什么需要元类"></a>ORM 为什么需要元类</h2><p>假设有如下的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line">    student_id = IntegerField(<span class="string">'studentid'</span>, primaryKey=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>回想 Django 的 ORM，每个模型都继承了一个 <code>Model</code> 类，我们也如法炮制。而所谓类与表的映射，就是在 Python 虚拟机启动后，自动寻找类属性，并将 <code>__table__</code> 转化为表名， <code>student_id</code> 转化为列名。这种需求类似于运行时自省，而普通类的 <code>__new__</code> <code>__init__</code> 都是实例化类时被调用，在这两个方法上做文章没有用处。</p><p>这时候就该用元类 <code>metaclass</code> 了。</p><p>在 <a href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/">Python2.7 源码 - 整数对象</a> 中已经有过介绍，元类 <code>metaclass</code> 是类的类。除了整数这种内置类型，用户自定义类型也有元类的概念。</p><ul><li>内置类定义在 C 源码中，故虚拟机运行后，就立即存在。</li><li>而用 <code>class</code> 语法定义的类，则需要根据元类 <code>metaclass</code> 来创建。</li><li>内置类也有元类，最终两者在虚拟机中拥有相同的结构。</li></ul><p>元类 <code>metaclass</code> 实例化的结果就是我们的普通类，由虚拟机启动时自动执行。在元类实例化的过程中，便可以扫描类定义属性，实现类与表的映射。自定义类默认继承自 <code>object</code>，获得的元类为 <code>type</code>。</p><p>Python2.x 中，用以下语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = Meta</span><br></pre></td></tr></table></figure><p>可以将类 <code>C</code> 对应的元类替换为 <code>Meta</code>。这么一看，只要设计自己的元类，并在模型中添加进去就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = Meta</span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line">    student_id = IntegerField(<span class="string">'studentid'</span>, primaryKey=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>但这么做，会在产品业务代码中暴露太多复杂的概念。我们可以设计一个公共的父类，并修改此父类的元类，这样所有继承的子类都能获得新的元类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelType</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = ModelType</span><br><span class="line"></span><br><span class="line"><span class="comment"># Application</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'Teacher_table'</span></span><br></pre></td></tr></table></figure><p>现在当 <code>User</code> <code>Teacher</code> 类在虚拟机中创建时，其行为就由 <code>ModelType</code> 控制。</p><p><code>ModelType</code> 需实现 <code>__new__</code> 函数，接受 <code>name, bases, attrs</code> 三个参数，<code>attrs</code> 是类属性构成的字典。该 <code>__new__</code> 函数最终需返回 <code>type.__new__(cls, name, bases, attrs)</code> 的结果，即类在虚拟机中的表示。</p><p>其中，<code>attrs</code> 字典由 Python 虚拟机创建类时填入。</p><h2 id="扫描表名"><a href="#扫描表名" class="headerlink" title="扫描表名"></a>扫描表名</h2><p>由上可知，可在元类的 <code>__new__</code> 函数中获取 <code>__table__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelType</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        tablename = attrs.get(<span class="string">'__table__'</span>, <span class="literal">None</span>) <span class="keyword">or</span> name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Get table name'</span>, tablename</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = ModelType</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get table name Model</span><br><span class="line">Get table name User_table</span><br></pre></td></tr></table></figure><p>为什么会输出两行？因为父类 <code>Model</code> 也会被元类 <code>ModelType</code> 扫描，所以应将父类自身排除出扫描：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'Model'</span>:</span><br><span class="line">            <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line">        tablename = attrs.get(<span class="string">'__table__'</span>, <span class="literal">None</span>) <span class="keyword">or</span> name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Get table name'</span>, tablename</span><br></pre></td></tr></table></figure><p>这次输出没有 <code>Model</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get table name User_table</span><br></pre></td></tr></table></figure><h2 id="扫描字段"><a href="#扫描字段" class="headerlink" title="扫描字段"></a>扫描字段</h2><p>字段的扫描是类似的，我们先完成字段类型的定义，让所有字段继承自 <code>Field</code> 类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, sqlType, primaryKey, default)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sqlType = sqlType</span><br><span class="line">        self.primaryKey = primaryKey</span><br><span class="line">        self.default = default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s, %s:%s&gt;'</span> % (self.__class__, self.sqlType, self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, sqlType=<span class="string">'character varying(100)'</span>, primaryKey=False, default=<span class="string">''</span>)</span>:</span></span><br><span class="line">        super(StringField, self).__init__(name, sqlType, primaryKey, default)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, sqlType=<span class="string">'integer'</span>, primaryKey=False, default=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super(IntegerField, self).__init__(name, sqlType, primaryKey, default)</span><br></pre></td></tr></table></figure><p>由于所有表字段类有一个相同的父类，所以可以通过 <code>isinstance(v, Field)</code> 识别一个类属性是否属于表字段。以下代码在类属性 <code>attrs</code> 中遍历，找出字段并存储在 <code>mappings</code> 字典和 <code>fields</code> 列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mappings = &#123;&#125;</span><br><span class="line">fields = []</span><br><span class="line">primary = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.iteritems():</span><br><span class="line">    <span class="keyword">if</span> isinstance(v, Field):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Found one field'</span>, k</span><br><span class="line">        mappings[k] = v</span><br><span class="line">        <span class="keyword">if</span> v.primaryKey == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> primary == <span class="literal">None</span>:</span><br><span class="line">                primary = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">"Duplicate primary key: %s"</span>, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fields.append(k)</span><br><span class="line"><span class="keyword">if</span> primary == <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">"No primary key given."</span>)</span><br></pre></td></tr></table></figure><p>将上述代码应用于 <code>User</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line">    student_id = IntegerField(<span class="string">'studentid'</span>, primaryKey=<span class="literal">True</span>)</span><br><span class="line">    name = StringField(<span class="string">'username'</span>)</span><br><span class="line">    age = IntegerField(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get table name User_table</span><br><span class="line">Found one field age</span><br><span class="line">Found one field name</span><br><span class="line">Found one field student_id</span><br></pre></td></tr></table></figure><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>在类中需要移除所有的字段属性 <code>attrs.pop(k)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">    attrs.pop(k)</span><br></pre></td></tr></table></figure><p>因为业务代码不需要类属性，每个实例需要访问的是实例属性。比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2 = User(student_id=<span class="number">3</span>, name=<span class="string">'blue'</span>, age=<span class="number">123</span>)</span><br><span class="line">print(u2.name)</span><br></pre></td></tr></table></figure><p>这里，让父类 <code>Model</code> 继承 <code>dict</code> 类，并添加 <code>__getattr__</code> 和 <code>__setattr__</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict)</span>:</span></span><br><span class="line">    __metaclass__ = ModelMeta</span><br><span class="line">    __table__ = <span class="string">'Should not show'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        super(Model, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Dict' object has no attribute '%s'"</span> % key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br></pre></td></tr></table></figure><p>访问 <code>u2.name</code> 便等价于 <code>u2[name]</code>，而 <code>User</code> 间接继承自字典，<code>User(student_id=3, name=&#39;blue&#39;, age=123)</code>初始化后，便能访问字典元素<code>u2[name]</code>。</p><h2 id="与-SQL-语句的映射"><a href="#与-SQL-语句的映射" class="headerlink" title="与 SQL 语句的映射"></a>与 SQL 语句的映射</h2><p>我们可以在元类 <code>ModelMeta</code> 中预先定义一些 SQL 语句的模板，并存储在类属性 <code>attrs</code> 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">attrs[<span class="string">'__select__'</span>] = <span class="string">"select '%s', %s from '%s'"</span> % (primary, <span class="string">','</span>.join(escaped_fields), tablename)</span><br><span class="line">attrs[<span class="string">'__insert__'</span>] = <span class="string">"insert into '%s' (%s, '%s') values (%s)"</span> % (tablename, <span class="string">','</span>.join(escaped_fields), primary, create_args_string(len(escaped_fields)+<span class="number">1</span>))</span><br><span class="line">attrs[<span class="string">'__update__'</span>] = <span class="string">"update '%s' set %s where '%s' =?"</span> % (tablename, <span class="string">','</span>.join(map(<span class="keyword">lambda</span> x: <span class="string">"'%s'=?"</span> % (mappings.get(x).name), fields)), primary)</span><br><span class="line">attrs[<span class="string">'__delete__'</span>] = <span class="string">"delete from '%s' where '%s' = ?"</span> % (tablename, primary)</span><br></pre></td></tr></table></figure><p>接着在 <code>Model</code> 中添加 <code>select</code> 和 <code>save</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(cls, id)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s where '%s' = %s;"</span> % (cls.__select__, cls.__primarykey__, id)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self, k)</span>:</span></span><br><span class="line">    value = getattr(self, k, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        field = self.__mappings__[k]</span><br><span class="line">        <span class="keyword">if</span> field.default <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            value = field.default</span><br><span class="line">            setattr(self, k, value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">    args = map(self.getValue, self.__fields__)</span><br><span class="line">    args.append(self.getValue(self.__primarykey__))</span><br><span class="line">    <span class="keyword">print</span> self.__insert__, args</span><br></pre></td></tr></table></figure><p>这两个方法对应于 SQL 中的 <code>SELECT</code> 和 <code>INSERT</code> 语句。逻辑也比较简单，从之前存储在 <code>mappings</code> 和 <code>fields</code> 的字段名，再结合实例属性，拼接出 SQL 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'Test select sql command:'</span></span><br><span class="line">User.select(id=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Test insert sql command:'</span></span><br><span class="line">u2 = User(student_id=<span class="number">3</span>, name=<span class="string">'blue'</span>, age=<span class="number">123</span>)</span><br><span class="line">u2.save()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test <span class="keyword">select</span> <span class="keyword">sql</span> command:</span><br><span class="line"><span class="keyword">select</span> <span class="string">'student_id'</span>, <span class="string">'age'</span>,<span class="string">'name'</span> <span class="keyword">from</span> <span class="string">'User_table'</span> <span class="keyword">where</span> <span class="string">'student_id'</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Test <span class="keyword">insert</span> <span class="keyword">sql</span> command:</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'User_table'</span> (<span class="string">'age'</span>,<span class="string">'name'</span>, <span class="string">'student_id'</span>) <span class="keyword">values</span> (?, ?, ?) [<span class="number">123</span>, <span class="string">'blue'</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，一个简单的 ORM 原型就完成了。详细代码可见：<a href="https://github.com/lyyyuna/script_collection/tree/master/orm_draft" target="_blank" rel="noopener">https://github.com/lyyyuna/script_collection/tree/master/orm_draft</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文实现一个非常简单的 ORM 初稿：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成 Python 类（模型）与数据库表的映射&lt;/li&gt;
&lt;li&gt;完成类实
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>实现基于 HTTPS 代理的中间人攻击</title>
    <link href="http://www.lyyyuna.com/2018/03/16/http-proxy-https/"/>
    <id>http://www.lyyyuna.com/2018/03/16/http-proxy-https/</id>
    <published>2018-03-16T11:44:50.000Z</published>
    <updated>2018-03-17T04:11:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在给产品做 Web 安全测试时，经常会使用代理工具来收集 URL 及相关请求参数。</p><p>在我之前的文章介绍了 <a href="http://www.lyyyuna.com/2016/01/16/http-proxy-get1/">使用 Python 实现一个简单的 HTTP 代理</a>。但这留下一个问题，如何处理 HTTPS 流量？</p><h2 id="HTTP-隧道代理原理"><a href="#HTTP-隧道代理原理" class="headerlink" title="HTTP 隧道代理原理"></a>HTTP 隧道代理原理</h2><p>RFC 为这类代理给出了规范，<a href="https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01" target="_blank" rel="noopener">Tunneling TCP based protocols through Web proxy servers</a>。简单来讲就是通过 Web 代理服务器用隧道方式传输基于 TCP 的协议。HTTP 协议正文部分为客户端发送的原始 TCP 流量，代理发送给远端服务器后，将接收到的 TCP 流量原封不动返回给浏览器。</p><p>下面这张图片来自于《HTTP 权威指南》，展示了 HTTP 隧道代理的原理。<br><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/connect.png" alt="HTTP 隧道"></p><p>浏览器首先发起 CONNECT 请求：</p><pre><code>CONNECT example.com:443 HTTP/1.1</code></pre><p>代理收到这样的请求后，依据 host 地址与服务器建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：</p><pre><code>HTTP/1.1 200 Connection Established</code></pre><p>该报文不需要正文。浏览器一旦收到这个响应报文，就可认为与服务器的 TCP 连接已打通，后续可直接透传。</p><h2 id="HTTPS-流量中间人攻击"><a href="#HTTPS-流量中间人攻击" class="headerlink" title="HTTPS 流量中间人攻击"></a>HTTPS 流量中间人攻击</h2><p>我们很容易想到，HTTPS 代理本质上就是隧道透传，代理服务器只是透传 TCP 流量，与 GET/POST 代理有本质区别。隧道透传是安全的，代理没有私钥来解密 TLS 流量。</p><p>这带来一个问题，现在 HTTPS 越来越普遍，测试时不会特意关掉 TLS，做安全测试也就拿不到 URL 及请求参数。那怎么做呢？</p><p>首先是来看正常的隧道代理示意图：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/tls1.png" alt="TLS 示意图 1"></p><p>在如图红色的透传流量中，插入我们的<strong>中间人</strong>：</p><ol><li>用一个 TLS 服务器伪装成远端的真正的服务器，接下浏览器的 TLS 流量，解析成明文。</li><li>用明文作为原始数据，模拟 TLS 客户端向远端服务器转发。</li></ol><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/tls2.png" alt="TLS 示意图 2"></p><p>由于中间人拿到了明文，也就能够继续收集 URL 及相关请求参数。</p><h3 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h3><p>大家知道，HTTP 是需要证书的。浏览器会验证服务器发来的证书是否合法。证书若是由合法的 CA 签发，则称为合法的证书。现代浏览器在安装时都会附带全世界所有合法的 CA 证书。由 CA 证书可验证远端服务器的证书是否是合法 CA 签发的。</p><p>在 TLS 示意图 2 中，浏览器会验证假 TLS 服务器的证书：</p><ol><li>第一验证是否是合法 CA 签发。</li><li>第二验证该证书 CN 属性是否是所请求的域名。即若浏览器打开 <code>www.example.com</code>，则返回的证书 CN 属性必须是 <code>www.example.com</code>。</li></ol><p>对于第一点，合法 CA 是不可能为我们签证书的，否则就是重大安全事件了。我们只能自制 CA，并将自制 CA 导入浏览器信任链。</p><p>对于第二点，需要自制 CA 实时为域名 <code>www.example.com</code> 签一个假的证书。</p><h2 id="Go-实现"><a href="#Go-实现" class="headerlink" title="Go 实现"></a>Go 实现</h2><p>不同于之前 <a href="http://www.lyyyuna.com/2016/01/16/http-proxy-get1/">Python 实现的 HTTP 代理</a>，这次的 HTTPS 中间人代理用 Go 实现。源码见 <a href="https://github.com/lyyyuna/mitm" target="_blank" rel="noopener">https://github.com/lyyyuna/mitm</a></p><p>首先是启动一个 http server。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mitmproxy.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gomitmproxy</span><span class="params">(conf *config.Cfg, ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">tlsConfig := config.NewTLSConfig(<span class="string">"gomitmproxy-ca-pk.pem"</span>, <span class="string">"gomitmproxy-ca-cert.pem"</span>, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">handler := InitConfig(conf, tlsConfig)</span><br><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">Addr:         <span class="string">":"</span> + *conf.Port,</span><br><span class="line">ReadTimeout:  <span class="number">1</span> * time.Hour,</span><br><span class="line">WriteTimeout: <span class="number">1</span> * time.Hour,</span><br><span class="line">Handler:      handler,</span><br><span class="line">    &#125;</span><br><span class="line">............</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handler</code> 是一个实现了 <code>ServeHTTP</code> 接口的 <code>Handler</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *HandlerWrapper)</span> <span class="title">ServeHTTP</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> req.Method == <span class="string">"CONNECT"</span> &#123;</span><br><span class="line">handler.https = <span class="literal">true</span></span><br><span class="line">handler.InterceptHTTPS(resp, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler.https = <span class="literal">false</span></span><br><span class="line">handler.DumpHTTPAndHTTPS(resp, req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据请求不同分为两大类。普通 GET/POST 请求，由于是明文，可直接进行抓包。而 CONNECT 请求，则走 <code>InterceptHTTPS</code>。我们默认走 CONNECT 隧道的都是 HTTPS 流量，其他 TCP 应用层协议则不予考虑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *HandlerWrapper)</span> <span class="title">InterceptHTTPS</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">addr := req.Host</span><br><span class="line">host := strings.Split(addr, <span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 1, 为每个域名签发证书</span></span><br><span class="line">cert, err := handler.FakeCertForName(host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatalln(<span class="string">"Could not get mitm cert for name: %s\nerror: %s"</span>, host, err)</span><br><span class="line">respBadGateway(resp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 2，拿到原始 TCP 连接</span></span><br><span class="line">connIn, _, err := resp.(http.Hijacker).Hijack()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatalln(<span class="string">"Unable to access underlying connection from client: %s"</span>, err)</span><br><span class="line">respBadGateway(resp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tlsConfig := copyTlsConfig(handler.tlsConfig.ServerTLSConfig)</span><br><span class="line">    tlsConfig.Certificates = []tls.Certificate&#123;*cert&#125;</span><br><span class="line">    <span class="comment">// step 3，将 TCP 连接转化为 TLS 连接</span></span><br><span class="line">tlsConnIn := tls.Server(connIn, tlsConfig)</span><br><span class="line">listener := &amp;mitmListener&#123;tlsConnIn&#125;</span><br><span class="line">httpshandler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(resp2 http.ResponseWriter, req2 *http.Request)</span></span> &#123;</span><br><span class="line">req2.URL.Scheme = <span class="string">"https"</span></span><br><span class="line">req2.URL.Host = req2.Host</span><br><span class="line">handler.DumpHTTPAndHTTPS(resp2, req2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// step 4，启动一个伪装的 TLS 服务器</span></span><br><span class="line">err = http.Serve(listener, httpshandler)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">logger.Printf(<span class="string">"Error serving mitm'ed connection: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">connIn.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP/1.1 200 Connection Established\r\n\r\n"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一步通过 <code>FakeCertForName</code> 为浏览器请求的域名签发证书。签发所使用的 CA 为 <code>gomitmproxy-ca-pk.pem</code>, <code>gomitmproxy-ca-cert.pem</code>。</li><li>第二步通过 <code>http.Hijacker</code> 拿到原始的 TCP 连接。</li><li>第三步通过 <code>tlsConnIn := tls.Server(connIn, tlsConfig)</code>，将 TCP 连接转换为 TLS 连接。该 TLS 连接已配置有 CA 签发的证书。所谓的 TLS 连接，即 Go 应用程序可直接在该连接上拿到原始明文。</li><li>第四步通过 <code>http.Serve(listener, httpshandler)</code> 响应这个 TLS 连接。响应的回调函数所看到的都是明文，即可进行 HTTP 抓包。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上述过程即为 Burp Suite, ZAP 和 fiddler 等进行 HTTPS 抓包的原理。</p><p>我自制 HTTPS 中间人代理，主要是想结合 Sqlmap 做一个自动化 SQL 注入系统。由于目前所在 QA 团队并不具备 SQL 注入测试的经验，最大化的自动化所有过程就成了我的目标。目前还有 csrf token 未解决，主要是 csrf 实现千差万别，没有通用解决方法。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在给产品做 Web 安全测试时，经常会使用代理工具来收集 URL 及相关请求参数。&lt;/p&gt;
&lt;p&gt;在我之前的文章介绍了 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="网络" scheme="http://www.lyyyuna.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http proxy" scheme="http://www.lyyyuna.com/tags/http-proxy/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 简单对象创建的字节码分析</title>
    <link href="http://www.lyyyuna.com/2018/01/13/python-internal6-simple-object-create/"/>
    <id>http://www.lyyyuna.com/2018/01/13/python-internal6-simple-object-create/</id>
    <published>2018-01-13T08:20:02.000Z</published>
    <updated>2018-01-13T14:19:05.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 源码编译后，有常量表，符号表。一个作用域运行时会对应一个运行时栈。</p><p>大部分字节码就是基于常量表、符号表和运行时栈，运算后得到所需结果。</p><p>本篇就来分析简单对象创建的字节码。以下面这段代码为分析样本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">s = <span class="string">'python'</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line">l = []</span><br></pre></td></tr></table></figure><p>对生成的 pyc 文件解析，可得如下的结构，其中包括字节码反编译的结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">magic 03f30d0a</span><br><span class="line">moddate 836a595a (Sat Jan 13 10:10:11 2018)</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">argcount</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">argcount</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">nlocals</span>&gt;</span> 0<span class="tag">&lt;/<span class="name">nlocals</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">stacksize</span>&gt;</span> 1<span class="tag">&lt;/<span class="name">stacksize</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">flags</span>&gt;</span> 0040<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">codeobject</span>&gt;</span> 6400005a00006401005a01006900005a02006700005a030064020053<span class="tag">&lt;/<span class="name">codeobject</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dis</span>&gt;</span></span><br><span class="line">  1           0 LOAD_CONST               0 (1)</span><br><span class="line">              3 STORE_NAME               0 (i)</span><br><span class="line"></span><br><span class="line">  2           6 LOAD_CONST               1 ('python')</span><br><span class="line">              9 STORE_NAME               1 (s)</span><br><span class="line"></span><br><span class="line">  3          12 BUILD_MAP                0</span><br><span class="line">             15 STORE_NAME               2 (d)</span><br><span class="line"></span><br><span class="line">  4          18 BUILD_LIST               0</span><br><span class="line">             21 STORE_NAME               3 (l)</span><br><span class="line">             24 LOAD_CONST               2 (None)</span><br><span class="line">             27 RETURN_VALUE</span><br><span class="line">   <span class="tag">&lt;/<span class="name">dis</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">names</span>&gt;</span> ('i', 's', 'd', 'l')<span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">varnames</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">varnames</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">freevars</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">freevars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cellvars</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">cellvars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filename</span>&gt;</span> '.\\test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span> '<span class="tag">&lt;<span class="name">module</span>&gt;</span>'<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">firstlineno</span>&gt;</span> 1<span class="tag">&lt;/<span class="name">firstlineno</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">      1</span><br><span class="line">      'python'</span><br><span class="line">      None</span><br><span class="line">   <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">lnotab</span>&gt;</span> 060106010601<span class="tag">&lt;/<span class="name">lnotab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们清楚的看到 <code>consts</code> 常量表，<code>names</code> 符号表，这些表中的元素都是有明确顺序的。</p><h2 id="整数赋值"><a href="#整数赋值" class="headerlink" title="整数赋值"></a>整数赋值</h2><p>第一条语句 <code>i = 1</code>。对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 LOAD_CONST               0 (1)</span><br><span class="line">3 STORE_NAME               0 (i)</span><br></pre></td></tr></table></figure><p><code>LOAD_CONST</code> 对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET(LOAD_CONST)</span><br><span class="line">&#123;</span><br><span class="line">    x = GETITEM(consts, oparg); <span class="comment">// 从常量表 oparg 位置处取出对象</span></span><br><span class="line">    Py_INCREF(x);</span><br><span class="line">    PUSH(x); <span class="comment">// 压入堆栈</span></span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，这里参数为 0。表示从常量表第 0 个位置取出整数，并将该数压入运行时栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+----------+</span><br><span class="line">| stack | f_locals |</span><br><span class="line">+-------+----------+</span><br><span class="line">| 1     |          |</span><br><span class="line">|       |          |</span><br><span class="line">|       |          |</span><br><span class="line">+-------+----------+</span><br></pre></td></tr></table></figure><p>左侧为运行时栈，右侧为当前作用域内的局部变量。</p><p><code>STORE_NAME</code> 所对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TARGET(STORE_NAME)</span><br><span class="line">&#123;</span><br><span class="line">    w = GETITEM(names, oparg); <span class="comment">// 从符号表 oparg 位置处取出符号名</span></span><br><span class="line">    v = POP(); <span class="comment">// 弹出运行时栈的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> ((x = f-&gt;f_locals) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_CheckExact(x))</span><br><span class="line">            err = PyDict_SetItem(x, w, v); <span class="comment">// 将符号名作为键，栈顶元素作为值，放入字典中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = PyObject_SetItem(x, w, v);</span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>) DISPATCH();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = PyObject_Repr(w);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    PyErr_Format(PyExc_SystemError,</span><br><span class="line">                    <span class="string">"no locals found when storing %s"</span>,</span><br><span class="line">                    PyString_AS_STRING(t));</span><br><span class="line">    Py_DECREF(t);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，参数为 0。表示从符号表第 0 个位置处取出符号名，即 <code>i</code>。然后弹出运行时栈的栈顶元素，并将符号名作为键，栈顶元素作为值，放入字典中 <code>f_locals</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+------------+</span><br><span class="line">| stack | f_locals   |</span><br><span class="line">+-------+------------+</span><br><span class="line">|       | i, &lt;int 1&gt; |</span><br><span class="line">|       |            |</span><br><span class="line">|       |            |</span><br><span class="line">+-------+------------+</span><br></pre></td></tr></table></figure><h2 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h2><p>语句 <code>s = &#39;python&#39;</code> 所对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 LOAD_CONST               1 (&apos;python&apos;)</span><br><span class="line">9 STORE_NAME               1 (s)</span><br></pre></td></tr></table></figure><p>和整数赋值的字节码完全相同，只是参数不同。这里不再做重复分析，赋值后，运行时栈变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       |                   |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="字典赋值"><a href="#字典赋值" class="headerlink" title="字典赋值"></a>字典赋值</h2><p>语句 <code>d = {}</code> 对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 BUILD_MAP                0</span><br><span class="line">15 STORE_NAME               2 (d)</span><br></pre></td></tr></table></figure><p><code>BUILD_MAP</code> 所对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line">TARGET(BUILD_MAP)</span><br><span class="line">&#123;</span><br><span class="line">    x = _PyDict_NewPresized((Py_ssize_t)oparg);</span><br><span class="line">    PUSH(x);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) DISPATCH();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dictobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyDict_NewPresized(Py_ssize_t minused)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *op = PyDict_New();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minused&gt;<span class="number">5</span> &amp;&amp; op != <span class="literal">NULL</span> &amp;&amp; dictresize((PyDictObject *)op, minused) == <span class="number">-1</span>) &#123;</span><br><span class="line">        Py_DECREF(op);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，参数为 0。而深入 <code>_PyDict_NewPresized</code> 可以看到，若参数小于 5，实际上创建的是默认大小的字典。创建完毕后，会将该字典对象压入运行时栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------+</span><br><span class="line">| stack  | f_locals          |</span><br><span class="line">+--------+-------------------+</span><br><span class="line">| &lt;dict&gt; | i, &lt;int 1&gt;        |</span><br><span class="line">|        | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|        |                   |</span><br><span class="line">+--------+-------------------+</span><br></pre></td></tr></table></figure><p>最后 <code>STORE_NAME</code> 将该对象与符号 <code>d</code> 绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       | d, &lt;dict&gt;         |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="列表赋值"><a href="#列表赋值" class="headerlink" title="列表赋值"></a>列表赋值</h2><p>语句 <code>l = []</code> 对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18 BUILD_LIST               0</span><br><span class="line">21 STORE_NAME               3 (l)</span><br></pre></td></tr></table></figure><p><code>BUILD_LIST</code> 对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_LIST)</span><br><span class="line">&#123;</span><br><span class="line">    x =  PyList_New(oparg); <span class="comment">// 创建空列表</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; --oparg &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            w = POP(); <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">            PyList_SET_ITEM(x, oparg, w); <span class="comment">// 将弹出的元素放入列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        PUSH(x); <span class="comment">// 将列表对象放入栈中</span></span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码首先创建一个列表，列表依据参数值预先分配空间。这里不对列表做深入分析，只指出，这里的空间大小不是存放元素所占用的空间，而是 <code>PyObject *</code> 指针。</p><p>列表建完后，便会不停从运行时栈中弹出元素，然后将元素放入列表中。这里是空列表，所以 <code>BUILD_LIST</code> 运行时，栈为空，该字节码的参数也为 0。</p><p>我们换一个非空列表来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1           0 LOAD_CONST               0 (1)</span><br><span class="line">            3 LOAD_CONST               1 (2)</span><br><span class="line">            6 LOAD_CONST               2 (3)</span><br><span class="line">            9 BUILD_LIST               3</span><br><span class="line">           12 STORE_NAME               0 (l)</span><br><span class="line">           15 LOAD_CONST               3 (None)</span><br><span class="line">           18 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>BUILD_LIST</code> 之前会将三个对象压入运行时栈中。</p><p>回到本文最初的 Python 程序，4 条语句运行完后， <code>f_locals</code> 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       | d, &lt;dict&gt;         |</span><br><span class="line">|       | l, &lt;list&gt;         |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>在最后，我们还看到两行字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24 LOAD_CONST               2 (None)</span><br><span class="line">27 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>它们好像与我们的四条赋值语句没有任何关系。原来，Python 在执行了一段 CodeBlock 后，一定要返回一些值，既然如此，那就随便返回一个 <code>None</code> 好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Python 源码编译后，有常量表，符号表。一个作用域运行时会对应一个运行时栈。&lt;/p&gt;
&lt;p&gt;大部分字节码就是基于常量表、符号表和运行时栈
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - pyc 的结构</title>
    <link href="http://www.lyyyuna.com/2018/01/06/python-internal5-pyc/"/>
    <id>http://www.lyyyuna.com/2018/01/06/python-internal5-pyc/</id>
    <published>2018-01-06T08:20:02.000Z</published>
    <updated>2018-01-06T13:10:46.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 是一门解释性语言，源码执行需要经过：编译-字节码-虚拟机的步骤。本文就介绍一下 <code>.py</code> 文件编译后的 <code>.pyc</code> 文件结构。直接运行的代码不会生成 <code>.pyc</code>，而 Python 的 import 机制会触发 <code>.pyc</code> 文件的生成。</p><h2 id="magic-number-和修改时间"><a href="#magic-number-和修改时间" class="headerlink" title="magic number 和修改时间"></a>magic number 和修改时间</h2><p>我们在导入模块的源码中，能找到 <code>.pyc</code> 文件的蛛丝马迹：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Python/import.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">write_compiled_module(PyCodeObject *co, <span class="keyword">char</span> *cpathname, struct stat *srcstat, <span class="keyword">time_t</span> mtime)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    <span class="comment">/* First write a 0 for mtime */</span></span><br><span class="line">    PyMarshal_WriteLongToFile(<span class="number">0L</span>, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>.pyc</code> 文件包含三个主要内容：magic number，修改时间，和一个 <code>PyCodeObject</code> 对象。</p><p>magic number 和 Python 版本有关，magic number 不同能够防止低版本误执行高版本编译后的字节码。修改时间能让编译器决定是否重新编译源文件。</p><p>我们来读取 <code>.pyc</code> 的前八字节来验证一下我们的分析，<code>func0.py</code> 是测试脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## func0.py</span></span><br><span class="line">    f = open(fname, <span class="string">'rb'</span>)</span><br><span class="line">    magic = f.read(<span class="number">4</span>)</span><br><span class="line">    moddate = f.read(<span class="number">4</span>)</span><br><span class="line">    modtime = time.asctime(time.localtime(struct.unpack(<span class="string">'I'</span>, moddate)[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'magic number: %s'</span> % (magic.encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'moddate %s (%s)'</span> % (moddate.encode(<span class="string">'hex'</span>), modtime)</span><br></pre></td></tr></table></figure><p>被测试源文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a)</span>:</span></span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><p>使用以下强制编译成 <code>.pyc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m py_compile test.py</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python func0.py test.pyc</span><br><span class="line">magic number: 03f30d0a</span><br><span class="line">moddate 5e9a4b5a (Tue Jan  2 22:42:38 2018)</span><br></pre></td></tr></table></figure><h2 id="PyCodeObject-对象"><a href="#PyCodeObject-对象" class="headerlink" title="PyCodeObject 对象"></a>PyCodeObject 对象</h2><p><code>PyCodeObject</code> 是一段代码块编译的直接结果。换句话说，一个作用域，对应一个代码，最终对应一个编译后的 <code>PyCodeObject</code>。<br>首先看一下 <code>PyCodeObject</code> 的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">int</span> co_argcount;<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="keyword">int</span> co_nlocals;<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="keyword">int</span> co_stacksize;<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="keyword">int</span> co_flags;<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    PyObject *co_code;<span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;<span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars;<span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">    <span class="comment">/* The rest doesn't count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;<span class="comment">/* string (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;<span class="comment">/* string (name, for reference) */</span></span><br><span class="line">    <span class="keyword">int</span> co_firstlineno;<span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_lnotab;<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span></span><br><span class="line"><span class="comment">   Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure><p>一段程序不可能只有一个作用域，嵌套的子作用域存在于 <code>co_consts</code> 之中。</p><p>我们写个简单的脚本，展现这种嵌套的结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># func0.py</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_code</span><span class="params">(code, indent=<span class="string">''</span>)</span>:</span></span><br><span class="line">    old_indent = indent  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;code&gt;"</span> % indent  </span><br><span class="line">    indent += <span class="string">'   '</span>  </span><br><span class="line">    show_hex(<span class="string">"bytecode"</span>, code.co_code, indent=indent)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;filename&gt; %r&lt;/filename&gt;"</span> % (indent, code.co_filename)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;consts&gt;"</span> % indent  </span><br><span class="line">    <span class="keyword">for</span> const <span class="keyword">in</span> code.co_consts:  </span><br><span class="line">        <span class="keyword">if</span> type(const) == types.CodeType:  </span><br><span class="line">            show_code(const, indent+<span class="string">'   '</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">"   %s%r"</span> % (indent, const)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;/consts&gt;"</span> % indent  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;/code&gt;"</span> % old_indent</span><br></pre></td></tr></table></figure><p>被测试的源文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a)</span>:</span></span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure></p><p>测试步骤：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exs $ python func0.py test.pyc</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bytecode</span>&gt;</span> 6400008400005a000064010053<span class="tag">&lt;/<span class="name">bytecode</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filename</span>&gt;</span> 'test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bytecode</span>&gt;</span> 6401007d00007c0000474864000053<span class="tag">&lt;/<span class="name">bytecode</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">filename</span>&gt;</span> 'test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">            None</span><br><span class="line">         <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line">      None</span><br><span class="line">   <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，函数 <code>add</code> 作为全局作用域的中一个子作用域，在编译结果中，是以常量形式存在于全局作用域的 <code>PyCodeObject</code> 中。</p><h2 id="查看字节码"><a href="#查看字节码" class="headerlink" title="查看字节码"></a>查看字节码</h2><p>Python 提供了 <code>dis</code> 模块，其中的 <code>disassemble()</code> 函数可以反编译 <code>PyCodeObject</code> 对象，以可读的形式展现出来。<br>我们修改 <code>func0.py</code>，将字节码对应的指令打印出来，增加下述代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">show_hex(<span class="string">"bytecode"</span>, code.co_code, indent=indent)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s&lt;dis&gt;"</span> % indent  </span><br><span class="line">dis.disassemble(code)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s&lt;/dis&gt;"</span> % indent  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ python func0.py test.pyc</span><br><span class="line">&lt;code&gt;</span><br><span class="line">   &lt;bytecode&gt; 6400008400005a000064010053&lt;/bytecode&gt;</span><br><span class="line">   &lt;dis&gt;</span><br><span class="line">  3           0 LOAD_CONST               0 (&lt;code object add at 0x109aa1c30, file &quot;test.py&quot;, line 3&gt;)</span><br><span class="line">              3 MAKE_FUNCTION            0</span><br><span class="line">              6 STORE_NAME               0 (add)</span><br><span class="line">              9 LOAD_CONST               1 (None)</span><br><span class="line">             12 RETURN_VALUE</span><br><span class="line">   &lt;/dis&gt;</span><br><span class="line">   &lt;filename&gt; &apos;test.py&apos;&lt;/filename&gt;</span><br><span class="line">   &lt;consts&gt;</span><br><span class="line">      &lt;code&gt;</span><br><span class="line">         &lt;bytecode&gt; 6401007d00007c0000474864000053&lt;/bytecode&gt;</span><br><span class="line">         &lt;dis&gt;</span><br><span class="line">  4           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 STORE_FAST               0 (a)</span><br><span class="line"></span><br><span class="line">  5           6 LOAD_FAST                0 (a)</span><br><span class="line">              9 PRINT_ITEM</span><br><span class="line">             10 PRINT_NEWLINE</span><br><span class="line">             11 LOAD_CONST               0 (None)</span><br><span class="line">             14 RETURN_VALUE</span><br><span class="line">         &lt;/dis&gt;</span><br><span class="line">         &lt;filename&gt; &apos;test.py&apos;&lt;/filename&gt;</span><br><span class="line">         &lt;consts&gt;</span><br><span class="line">            None</span><br><span class="line">            1</span><br><span class="line">         &lt;/consts&gt;</span><br><span class="line">      &lt;/code&gt;</span><br><span class="line">      None</span><br><span class="line">   &lt;/consts&gt;</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Python 是一门解释性语言，源码执行需要经过：编译-字节码-虚拟机的步骤。本文就介绍一下 &lt;code&gt;.py&lt;/code&gt; 文件编译后的
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.x 源码 - 编译调试之旅</title>
    <link href="http://www.lyyyuna.com/2018/01/01/python-internal4-lldb/"/>
    <id>http://www.lyyyuna.com/2018/01/01/python-internal4-lldb/</id>
    <published>2018-01-01T08:20:02.000Z</published>
    <updated>2018-01-01T08:03:23.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h2><ol><li>从 GitHub 上下载源码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/python/cpython</span><br><span class="line">$ cd cpython</span><br></pre></td></tr></table></figure><ol start="2"><li>编译之前打开 <code>--with-pydebug</code> 选项</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --with-pydebug</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>编译完成之后，会在当前目录看到一个二进制文件 <code>python</code>。如果你使用的是 macOS，文件名为 <code>python.exe</code>，此文后续在命令行中请用 <code>python.exe</code> 代替 <code>python</code>。</p><h2 id="用-GDB-调试"><a href="#用-GDB-调试" class="headerlink" title="用 GDB 调试"></a>用 GDB 调试</h2><p>我们将使用 <code>gdb</code> 来追踪 <code>python</code> 的行为。</p><p>本小结也是一个 <code>gdb</code> 入门教程。</p><h3 id="GDB-快捷键"><a href="#GDB-快捷键" class="headerlink" title="GDB 快捷键"></a>GDB 快捷键</h3><ul><li>r (run)，运行程序</li><li>b (break)，设置断点</li><li>s (step)，单步运行</li><li>c (continue)，继续运行程序，在断点处会停止运行</li><li>l (list)，列出当前程序的源代码</li><li>ctrl+x，打开 tui 模式</li><li>ctrl+p，往上</li><li>ctrl+n，往下</li></ul><h3 id="GDB-介绍"><a href="#GDB-介绍" class="headerlink" title="GDB 介绍"></a>GDB 介绍</h3><p>在编译目录敲入命令 <code>gdb python</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">GNU gdb (GDB) 7.12</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-pc-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from python...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>在最后一行我们看到 <code>Reading symbols from python...done.</code>，说明现在我们可以通过 <code>gdb</code> 来调试 python 了。</p><p>现在程序还没有运行，调试器在程序最前端停止下来。</p><p>每一个 C 程序都从 <code>main()</code> 函数开始运行，所以我们在 <code>main()</code> 上打一个断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p><code>gdb</code> 会在 <code>Programs/python.c, line 20</code> 处打上断点。从这条信息可以看出，<code>Python</code> 的入口点为 <code>Programs/python.c:20</code>。另外，如果你事先已知晓源码，可以直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b Programs/python.c:20</span><br><span class="line">Breakpoint 3 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>运行 <code>python</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>我们停在了之前设置的断点处，使用 <code>list</code> 列出源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">15&#125;</span><br><span class="line">16#else</span><br><span class="line">17</span><br><span class="line">18int</span><br><span class="line">19main(int argc, char **argv)</span><br><span class="line">20&#123;</span><br><span class="line">21    wchar_t **argv_copy;</span><br><span class="line">22    /* We need a second copy, as Python might modify the first one. */</span><br><span class="line">23    wchar_t **argv_copy2;</span><br><span class="line">24    int i, res;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>或者使用 <code>ctrl+x</code> 调出 <code>tui</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   ┌──./Programs/python.c─────────────────────────────────────────────────────────┐</span><br><span class="line">   │15      &#125;                                                                     │</span><br><span class="line">   │16      #else                                                                 │</span><br><span class="line">   │17                                                                            │</span><br><span class="line">   │18      int                                                                   │</span><br><span class="line">   │19      main(int argc, char **argv)                                           │</span><br><span class="line">B+&gt;│20      &#123;                                                                     │</span><br><span class="line">   │21          wchar_t **argv_copy;                                              │</span><br><span class="line">   │22          /* We need a second copy, as Python might modify the first one. */│</span><br><span class="line">   │23          wchar_t **argv_copy2;                                             │</span><br><span class="line">   │24          int i, res;                                                       │</span><br><span class="line">   │25          char *oldloc;                                                     │</span><br><span class="line">   │26                                                                            │</span><br><span class="line">   └──────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">multi-thre Thread 0x7ffff7f9de In: main                         L20   PC: 0x41d1d6 </span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>在 <code>tui</code> 模式，也可以看到我们停在了源代码的第 20 行。</p><p>继续运行 <code>continue</code>，将进入 <code>python</code> 的交互式解释器环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">   │29                                                                                                                                                                                                                                      │</span><br><span class="line">   │30          argv_copy = (wchar_t **)PyMem_RawMalloc(sizeof(wchar_t*) * (argc+1));                                                                                                                                                       │</span><br><span class="line">   │31          argv_copy2 = (wchar_t **)PyMem_RawMalloc(sizeof(wchar_t*) * (argc+1));                                                                                                                                                      │</span><br><span class="line">   │32          if (!argv_copy || !argv_copy2) &#123;                                                                                                                                                                                            │</span><br><span class="line">   └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">multi-thre Thread 0x7ffff7f9de In: main                                                                                                                                                                                   L20   PC: 0x41d1d6 </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Python 3.7.0a0 (default, Feb 22 2017, 22:10:22) </span><br><span class="line">[GCC 6.3.1 20170109] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="调试语法分析器"><a href="#调试语法分析器" class="headerlink" title="调试语法分析器"></a>调试语法分析器</h2><h3 id="调试语法分析器-1"><a href="#调试语法分析器-1" class="headerlink" title="调试语法分析器"></a>调试语法分析器</h3><p>创建一个简单的 python 脚本 <code>test.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>打开 gdb，设置参数，运行 python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) set args test.py</span><br><span class="line">// 或者</span><br><span class="line">$ gdb --args python test.py</span><br></pre></td></tr></table></figure><p>并在 <code>main</code> 函数上打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h4 id="Program-python-c"><a href="#Program-python-c" class="headerlink" title="Program/python.c"></a>Program/python.c</h4><p>如果你仔细查看 <code>Program/python.c</code> 的源码，会发现 <code>main()</code> 做了很多事情，核心是调用 <code>Py_Main(argc, argv_copy)</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">argv_copy2[argc] = argv_copy[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">setlocale(LC_ALL, oldloc);</span><br><span class="line">PyMem_RawFree(oldloc);</span><br><span class="line"></span><br><span class="line">res = Py_Main(argc, argv_copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Force again malloc() allocator to release memory blocks allocated</span></span><br><span class="line"><span class="comment">   before Py_Main() */</span></span><br><span class="line">(<span class="keyword">void</span>)_PyMem_SetupAllocators(<span class="string">"malloc"</span>);</span><br></pre></td></tr></table></figure><h4 id="Modules-main-c"><a href="#Modules-main-c" class="headerlink" title="Modules/main.c"></a>Modules/main.c</h4><p>简单来说，<code>Py_Main</code> 会做如下：</p><ol><li>初始化哈希随机：391</li><li>重置 Warning 选项：394，395</li><li>通过 <code>_PyOS_GetOpt()</code> 解析命令行选项：397</li><li>通过 <code>Py_Initialize()</code> 初始化 python：693</li><li>导入 <code>readline</code> 模块：723</li><li>依次执行：<ol><li><code>run_command()</code></li><li><code>RunModule()</code></li><li><code>RunInteractiveHook()</code></li><li><code>RunMainFromImporter()</code></li><li><code>run_file()</code></li><li><code>PyRun_AnyFileFlags()</code></li></ol></li></ol><p>将断点打在 <code>run_file</code>，第 793 行，可以用 <code>p filename</code> 查看当前文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b Modules/main.c:793</span><br><span class="line">(gdb) c</span><br><span class="line">(gdb) p filename</span><br><span class="line">$1 = 0x931050 L&quot;test.py</span><br><span class="line">(gdb) s</span><br></pre></td></tr></table></figure><p><code>run_file</code> 只是一个装饰器，该装饰器会调用 <code>Python/pythonrun.c</code> 中的 <code>PyRun_InteractiveLoopFlags()</code> 或 <code>PyRun_PyRun_SimpleFileExFlags</code>。从名字上就可以看出一个会进入交互式环境，另一个就是带参数的 python 调用。这里，我们带上了参数 <code>test.py</code>，所以会运行 <code>PyRun_PyRun_SimpleFileExFlags</code>。</p><h4 id="Python-pythonrun-c"><a href="#Python-pythonrun-c" class="headerlink" title="Python/pythonrun.c"></a>Python/pythonrun.c</h4><p><code>PyRun_SimpleFileExFlags()</code> 首先会用 <code>maybe_pyc_file()</code> 检查所传文件是否是 <code>.pyc</code> 格式。</p><p>在我们的例子中，由于是 <code>.py</code> 文件，所以接着会调用 <code>PyRun_FileExFlags()</code>。最后调用 <code>PyParser_ASTFromFileObject()</code> 来建立抽象语法树（AST）。</p><p>抽象语法树需调用 <code>Parser/parsetok.c</code> 中的 <code>PyParser_ParseFileObject()</code> 创建节点，再用 <code>PyAST_FromNodeObject()</code> 函数从节点构建 AST 树。</p><h4 id="Parser-parsetok-c"><a href="#Parser-parsetok-c" class="headerlink" title="Parser/parsetok.c"></a>Parser/parsetok.c</h4><p><code>PyParser_ParseFileObject()</code> 会从 <code>PyTokenizer_FromFile()</code> 中获取所有的 toekn，将这些 token 传入 <code>parsetok()</code> 创建节点。</p><p>最有趣的部分是其中包含一个无限循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = PyTokenizer_Get(tok, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure><p>该函数是 <code>tok_get()</code> 的装饰器，它会返回预定义于 <code>token.h</code> 中的 token 类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/token.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDMARKER0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDENT5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEDENT6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPAR7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RPAR8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSQB9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RARROW          51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELLIPSIS        52</span></span><br><span class="line"><span class="comment">/* Don't forget to update the table _PyParser_TokenNames in tokenizer.c! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AWAIT54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASYNC55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERRORTOKEN56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TOKENS57</span></span><br></pre></td></tr></table></figure><p>在 for 循环的第一轮，我们在 gdb 中打印上述代码中的 <code>type</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p type</span><br><span class="line">$1 = 1</span><br></pre></td></tr></table></figure><p>根据头文件中的宏，值 1 对应 <code>NAME</code>，说明该 token 为一个变量名。</p><p>在第 236 行，<code>str[lbbben] = &#39;\0&#39;</code> 会储存 token 所对应的字符串，即 <code>a</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p str</span><br><span class="line">$2 = 0x7ffff6eb5a18 &quot;a&quot;</span><br></pre></td></tr></table></figure><p>看起来很有道理，因为我们的源码为 <code>a = 100</code>，第一个 token 字符串应对应于 <code>a</code>，类型为 <code>NAME</code>。</p><p>解析器接下来会调用 <code>PyParser_AddToken()</code>，这会将 token 加入语法树中。</p><h3 id="语法生成"><a href="#语法生成" class="headerlink" title="语法生成"></a>语法生成</h3><p>语法的文本表示在 <code>Grammar/Grammar</code> 中，这是用 <code>yacc</code> 写的，我建议直接忽略。而语法的数字表示在 <code>Python/graminit.c</code> 中，其中包含了 DFA 数组。</p><p>修改 <code>test.py</code> 的内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>打开 gdb，在 <code>PyParser_AddToken()</code> 上打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) b PyParser_AddToken</span><br><span class="line">(gdb) r test.py</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, PyParser_AddToken (ps=ps@entry=0x9cf4f0, type=type@entry=1, str=str@entry=0x7ffff6eb5a18 &quot;class&quot;, lineno=1, col_offset=0, expected_ret=expected_ret@entry=0x7fffffffdc34) at Parser/parser.c:229</span><br><span class="line">229&#123;</span><br></pre></td></tr></table></figure><p>为了看到 DFA 的状态变化，在 <code>dfa *d = ps-&gt;p_stack.s_top-&gt;s_dfa</code> 下一行打上断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 244</span><br><span class="line">Breakpoint 2 at 0x5b5933: file Parser/parser.c, line 244.</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 2, PyParser_AddToken (ps=ps@entry=0x9cf4f0, type=type@entry=1, str=str@entry=0x7ffff6eb5a18 &quot;class&quot;, lineno=1, col_offset=0, expected_ret=expected_ret@entry=0x7fffffffdc34) at Parser/parser.c:244</span><br><span class="line">244        state *s = &amp;d-&gt;d_state[ps-&gt;p_stack.s_top-&gt;s_state];</span><br></pre></td></tr></table></figure><p>然后打印出 <code>d</code> 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *d</span><br><span class="line">$6 = &#123;d_type = 269, d_name = 0x606340 &quot;stmt&quot;, d_initial = 0, d_nstates = 2, d_state = 0x8a6a40 &lt;states_13&gt;, d_first = 0x60658c &quot;&quot;&#125;</span><br><span class="line">(gdb) set print pretty</span><br><span class="line">(gdb) p *d</span><br><span class="line">$8 = &#123;</span><br><span class="line">  d_type = 269,</span><br><span class="line">  d_name = 0x606340 &quot;stmt&quot;,</span><br><span class="line">  d_initial = 0,</span><br><span class="line">  d_nstates = 2,</span><br><span class="line">  d_state = 0x8a6a40 &lt;states_13&gt;,</span><br><span class="line">  d_first = 0x60658c &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">(gdb) p d-&gt;d_name</span><br><span class="line">&apos;file_input&apos;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>对比 <code>d_name</code> 的值，发现它出现在 <code>Grammar/Grammar</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Grammar for Python</span><br><span class="line"></span><br><span class="line">single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE</span><br><span class="line">file_input: (NEWLINE | stmt)* ENDMARKER</span><br><span class="line">eval_input: testlist NEWLINE* ENDMARKER</span><br></pre></td></tr></table></figure><p>运行多次，我们会发现 <code>d_name</code> 按如下的顺序变化：<code>file_input</code>, <code>stmt</code>, <code>compound_stmt</code>, <code>classdef</code>, <code>classdef</code>, <code>classdef</code>, <code>classdef</code>, <code>suite</code>, <code>suite</code>, <code>suite</code>, <code>stmt</code>, <code>simple_stmt</code>, <code>small_stmt</code>, <code>pass_stmt</code>, <code>simple_stmt</code>, <code>suite</code>, <code>file_input</code>, <code>file_input</code>。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>查看一下到目前为止的调用栈：</p><ul><li><code>main()</code></li><li><code>Py_Main()</code></li><li><code>run_file()</code></li><li><code>PyRun_AnyFileExFlags()</code></li><li><code>PyRun_SimpleFileExFlags()</code></li><li><code>PyRun_FileExFlags()</code></li><li><code>PyParser_ASTFromFileObject()</code><ul><li><code>PyParser_ParseFileObject()</code><ul><li><code>parsetok()</code></li><li><code>PyParser_AddToken()</code></li></ul></li><li><code>PyAST_FromNodeObject()</code></li></ul></li></ul><h2 id="调试抽象语法树（AST）生成器"><a href="#调试抽象语法树（AST）生成器" class="headerlink" title="调试抽象语法树（AST）生成器"></a>调试抽象语法树（AST）生成器</h2><p>我们从 <code>PyParser_ParseFileObject()</code> 构建了语法树，下一步是生成 AST。</p><p>在此之前，需要介绍一些宏。这些宏定义于 <code>Include/node.h</code> 中，用于从节点结构中查询数据：</p><ul><li><code>CHILD(node *, int)</code>，返回第 n 个节点（从 0 开始）</li><li><code>RCHILD(node *, int)</code>，从右往左返回第 n 个节点，使用负数</li><li><code>NCH(node *)</code>，返回节点总数</li><li><code>STR(node *)</code>，返回节点的字符串表示，比如冒号 token，会返回 <code>:</code></li><li><code>TYPE(node *)</code>，返回节点的类型，类型定义于 <code>Include/graminit.h</code></li><li><code>REQ(node *, TYPE)</code>，判断节点类型是否是 <code>TYPE</code></li><li><code>LINENO(node *)</code>，获取解析规则源码所在的行数，规则定义在 <code>Python/ast.c</code></li></ul><p>在 <code>Python/ast.c</code> 中的 <code>PyAST_FromNodeObject()</code> 将语法树转换为 AST。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCH(n) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ch = CHILD(n, i);</span><br><span class="line">    <span class="keyword">if</span> (TYPE(ch) == NEWLINE)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    REQ(ch, stmt);</span><br><span class="line">    num = num_stmts(ch);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        s = ast_for_stmt(&amp;c, ch);</span><br><span class="line">        <span class="keyword">if</span> (!s)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        asdl_seq_SET(stmts, k++, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ch = CHILD(ch, <span class="number">0</span>);</span><br><span class="line">        REQ(ch, simple_stmt);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">            s = ast_for_stmt(&amp;c, CHILD(ch, j * <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (!s)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            asdl_seq_SET(stmts, k++, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res = Module(stmts, arena);</span><br></pre></td></tr></table></figure><p><code>ast_for_stmt()</code> 是 <code>ast_for_xx</code> 的装饰器，其中 <code>xx</code> 是对应函数处理的语法规则。</p><h2 id="调试符号表生成器"><a href="#调试符号表生成器" class="headerlink" title="调试符号表生成器"></a>调试符号表生成器</h2><p>回到 <code>Python/pythonrun.c</code> 中的 <code>PyRun_FileExFlags()</code>。它会接着将结果 <code>mod</code> 传入 <code>run_mod()</code> 函数中。它完成了重要的两步：第一，生成代码对象（<code>PyAST_CompileObject()</code>），第二，进入解析循环（<code>PyEval_EvalCode()</code>）。</p><p><code>PyAST_CompileObject()</code> 位于 <code>Python/compile.c</code>。它有两个重要的函数：</p><ol><li><code>PySumtable_BuildObject()</code></li><li><code>compiler_mod()</code></li></ol><p><code>Python/symtable.c</code> 中的 <code>PySumtable_BuildObject()</code> 用于生成符号表。</p><p>符号表的结构定义在 <code>Include/symtble.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtable</span> &#123;</span></span><br><span class="line">    PyObject *st_filename;          <span class="comment">/* name of file being compiled,</span></span><br><span class="line"><span class="comment">                                       decoded from the filesystem encoding */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> *<span class="title">st_cur</span>;</span> <span class="comment">/* current symbol table entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> *<span class="title">st_top</span>;</span> <span class="comment">/* symbol table entry for module */</span></span><br><span class="line">    PyObject *st_blocks;            <span class="comment">/* dict: map AST node addresses</span></span><br><span class="line"><span class="comment">                                     *       to symbol table entries */</span></span><br><span class="line">    PyObject *st_stack;             <span class="comment">/* list: stack of namespace info */</span></span><br><span class="line">    PyObject *st_global;            <span class="comment">/* borrowed ref to st_top-&gt;ste_symbols */</span></span><br><span class="line">    <span class="keyword">int</span> st_nblocks;                 <span class="comment">/* number of blocks used. kept for</span></span><br><span class="line"><span class="comment">                                       consistency with the corresponding</span></span><br><span class="line"><span class="comment">                                       compiler structure */</span></span><br><span class="line">    PyObject *st_private;           <span class="comment">/* name of current class or NULL */</span></span><br><span class="line">    PyFutureFeatures *st_future;    <span class="comment">/* module's future features that affect</span></span><br><span class="line"><span class="comment">                                       the symbol table */</span></span><br><span class="line">    <span class="keyword">int</span> recursion_depth;            <span class="comment">/* current recursion depth */</span></span><br><span class="line">    <span class="keyword">int</span> recursion_limit;            <span class="comment">/* recursion limit */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *ste_id;        <span class="comment">/* int: key in ste_table-&gt;st_blocks */</span></span><br><span class="line">    PyObject *ste_symbols;   <span class="comment">/* dict: variable names to flags */</span></span><br><span class="line">    PyObject *ste_name;      <span class="comment">/* string: name of current block */</span></span><br><span class="line">    PyObject *ste_varnames;  <span class="comment">/* list of function parameters */</span></span><br><span class="line">    PyObject *ste_children;  <span class="comment">/* list of child blocks */</span></span><br><span class="line">    PyObject *ste_directives;<span class="comment">/* locations of global and nonlocal statements */</span></span><br><span class="line">    _Py_block_ty ste_type;   <span class="comment">/* module, class, or function */</span></span><br><span class="line">    <span class="keyword">int</span> ste_nested;      <span class="comment">/* true if block is nested */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_free : <span class="number">1</span>;        <span class="comment">/* true if block has free variables */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_child_free : <span class="number">1</span>;  <span class="comment">/* true if a child block has free vars,</span></span><br><span class="line"><span class="comment">                                     including free refs to globals */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_generator : <span class="number">1</span>;   <span class="comment">/* true if namespace is a generator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_coroutine : <span class="number">1</span>;   <span class="comment">/* true if namespace is a coroutine */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_varargs : <span class="number">1</span>;     <span class="comment">/* true if block has varargs */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_varkeywords : <span class="number">1</span>; <span class="comment">/* true if block has varkeywords */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_returns_value : <span class="number">1</span>;  <span class="comment">/* true if namespace uses return with</span></span><br><span class="line"><span class="comment">                                        an argument */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_needs_class_closure : <span class="number">1</span>; <span class="comment">/* for class scopes, true if a</span></span><br><span class="line"><span class="comment">                                            closure over __class__</span></span><br><span class="line"><span class="comment">                                             should be created */</span></span><br><span class="line">    <span class="keyword">int</span> ste_lineno;          <span class="comment">/* first line of block */</span></span><br><span class="line">    <span class="keyword">int</span> ste_col_offset;      <span class="comment">/* offset of first line of block */</span></span><br><span class="line">    <span class="keyword">int</span> ste_opt_lineno;      <span class="comment">/* lineno of last exec or import * */</span></span><br><span class="line">    <span class="keyword">int</span> ste_opt_col_offset;  <span class="comment">/* offset of last exec or import * */</span></span><br><span class="line">    <span class="keyword">int</span> ste_tmpname;         <span class="comment">/* counter for listcomp temp vars */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">symtable</span> *<span class="title">ste_table</span>;</span></span><br><span class="line">&#125; PySTEntryObject;</span><br></pre></td></tr></table></figure><p>可以看出，符号表其实是一个字典结构，每一项是一个符号对应关系。</p><p>在第 281 行的 for 循环打上断点（<code>for (i = 0; i &lt; asdl_seq_LEN(seq); i++)</code>），会来到 <code>symtable_visit_stmt()</code> 函数，该函数生成符号表的每一项。接着打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b symtable_visit_stmt</span><br></pre></td></tr></table></figure><p>就能观察到类似 <code>xx_kind</code> 的表达式，例如 <code>Name_kind</code> 会调用 <code>symtable_add_def()</code> 将一个符号定义加入到符号表中。</p><h2 id="调试编译器和字节码生成器"><a href="#调试编译器和字节码生成器" class="headerlink" title="调试编译器和字节码生成器"></a>调试编译器和字节码生成器</h2><p>回到函数 <code>PyAST_CompileObject()</code> 中，下一步是 <code>compiler_mod()</code>，将抽象语法树转换为上下文无关语法。</p><p>在此处打断点（<code>b compiler_mod</code>）。swtich 分支会把我们带进 <code>Module_kind</code>，里面会调用 <code>compiler_body()</code> 函数，接着单步调试，就会发现一个 for 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &lt; asdl_seq_LEN(stmts); i++)</span><br><span class="line">    VISIT(c, stmt, (stmt)ty)asdl_seq_GET(stmts, i));</span><br></pre></td></tr></table></figure><p>这里，我们在抽象语义描述语言（ASDL）中遍历，调用宏 <code>VISIT</code>，接着调用 <code>compiler_visit_expr(c, nodeZ)</code>。</p><p>以下宏会产生字节码：</p><ul><li><code>ADDOP()</code>，增加一个指定的字节码</li><li><code>ADDOP_I()</code>，增加的字节码是带参数的</li><li><code>ADDOP_O(struct compiler *c, int op, PyObject * type, PyObject *obj)</code>，根据指定 <code>PyObject</code> 在序列中的位置，增加一个字节码，但是不考虑 name mangling。常用于全局、常量或参数的变量名寻找，因为这种变量名的作用域是未知的。</li><li><code>ADDOP_NAME()</code>，和 <code>ADDOP_O</code> 类似，但是会考虑 name mangling。用于属性加载和导入。</li><li><code>ADDOP_JABS()</code>，创建一个绝对跳转</li><li><code>ADDOP_JREL()</code>，创建一个相对跳转</li></ul><p>为了验证是否生成了正确的字节码，可以在 <code>test.py</code> 上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python -m dis test.py</span><br><span class="line">  1           0 LOAD_CONST               0 (100)</span><br><span class="line">              2 STORE_NAME               0 (a)</span><br><span class="line">              4 LOAD_CONST               1 (None)</span><br><span class="line">              6 RETURN_VALUE</span><br></pre></td></tr></table></figure><h2 id="调试解析器循环"><a href="#调试解析器循环" class="headerlink" title="调试解析器循环"></a>调试解析器循环</h2><p>一旦字节码生成，下一步是由解析器运行程序。回到 <code>Python/pythonrun.c</code> 文件中，我们接着会调用函数 <code>PyEval_EvalCode()</code>，这是对 <code>PyEval_EvalCodeEx()/_PyEval_EvalCodeWithName()</code> 的装饰器函数。</p><blockquote><p>和 Python2.7 不一样，<code>PyEval_EvalCodeEx</code> 不会建立函数栈，这一步被移入 <code>_PyEval_EvalCodeWithName</code>。</p></blockquote><p>栈对象的结构定义于 <code>Include/frameobject.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* previous frame, or NULL */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* code segment */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* points after the last local */</span></span><br><span class="line">    <span class="comment">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span></span><br><span class="line"><span class="comment">       Frame evaluation usually NULLs it, but a frame that yields sets it</span></span><br><span class="line"><span class="comment">       to the current stack top. */</span></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* Trace function */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In a generator, we need to be able to swap between the exception</span></span><br><span class="line"><span class="comment">       state inside the generator and the exception state of the calling</span></span><br><span class="line"><span class="comment">       frame (which shouldn't be impacted when the generator "yields"</span></span><br><span class="line"><span class="comment">       from an except handler).</span></span><br><span class="line"><span class="comment">       These three fields exist exactly for that, and are unused for</span></span><br><span class="line"><span class="comment">       non-generator frames. See the save_exc_state and swap_exc_state</span></span><br><span class="line"><span class="comment">       functions in ceval.c for details of their use. */</span></span><br><span class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</span><br><span class="line">    <span class="comment">/* Borrowed reference to a generator, or NULL */</span></span><br><span class="line">    PyObject *f_gen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f_lasti;                <span class="comment">/* Last instruction if called */</span></span><br><span class="line">    <span class="comment">/* Call PyFrame_GetLineNumber() instead of reading this field</span></span><br><span class="line"><span class="comment">       directly.  As of 2.3 f_lineno is only valid when tracing is</span></span><br><span class="line"><span class="comment">       active (i.e. when f_trace is set).  At other times we use</span></span><br><span class="line"><span class="comment">       PyCode_Addr2Line to calculate the line from the current</span></span><br><span class="line"><span class="comment">       bytecode index. */</span></span><br><span class="line">    <span class="keyword">int</span> f_lineno;               <span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="keyword">int</span> f_iblock;               <span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    <span class="keyword">char</span> f_executing;           <span class="comment">/* whether the frame is still executing */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* locals+stack, dynamically sized */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure><p>在 <code>_PyEval_EvalCodeWithName()</code> 中，会用 <code>_PyFrame_New_NoTrack()</code> 创建一个栈对象，这个栈是对 C 程序函数栈的模拟，在最后，会调用 <code>PyEval_EvalFrameEx()</code>。</p><p><code>PyEval_EvalFrameEx()</code> 然后会在 <code>PyThreadState</code> 上调用 <code>eval_frame()/_PyEval_EvalFrameDefault()</code> 函数。这个函数也会被 Python 虚拟机调用。</p><p>跟踪进入 <code>_PyEval_EvalFrameDefault()</code>，我们可以观察到第 1054 行有一个无限循环，在不断产生字节码。</p><h2 id="调试-Python-对象"><a href="#调试-Python-对象" class="headerlink" title="调试 Python 对象"></a>调试 Python 对象</h2><p><code>PyObject</code> 是通用 Python 对象，定义于 <code>Include/object.h</code> 中。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每一种 <code>PyObject</code> 都有着相似的跟踪步骤：</p><ul><li>用 gdb 打开 python</li><li>在对象创建函数上打断点</li><li>用交互式命令环境，创建我们想要的对象</li><li>在断点处，开始一步步跟踪代码</li></ul><p>例如，我们想单步调试 <code>PyBoolObject</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) b bool_newbb</span><br><span class="line">Breakpoint 1 at 0x44812f: file Objects/boolobject.c, line 44.</span><br><span class="line">(gdb) r</span><br><span class="line">[GCC 6.3.1 20170109] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; a = bool(1)</span><br><span class="line"></span><br><span class="line">Breakpoint 1, bool_new (type=0x87a700 &lt;PyBool_Type&gt;, args=(1,), kwds=0x0) at Objects/boolobject.c:44</span><br><span class="line">44&#123;</span><br></pre></td></tr></table></figure><h3 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h3><p>通用 Python 对象定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObjecdt;</span><br></pre></td></tr></table></figure><p>在预处理器展开宏 <code>_PyObject_HEAD_EXTRA</code> 后，它会变成一个双向列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObjecdt;</span><br></pre></td></tr></table></figure><p>该对象包含两个重要元素：引用计数和类型对象。</p><h3 id="PyVarObject"><a href="#PyVarObject" class="headerlink" title="PyVarObject"></a>PyVarObject</h3><p>Python 也有变长对象，定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>几乎和 <code>PyObject</code> 一样，但多了一项用于表示对象的长度信息。</p><h3 id="PyTypeObject"><a href="#PyTypeObject" class="headerlink" title="PyTypeObject"></a>PyTypeObject</h3><p><code>PyTypeObject</code> 是 Python 对象的类型表示。在 Python 中可以如下表达式获取任何对象的类型信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = type(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(t)</span><br><span class="line">[<span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__bool__'</span>, <span class="string">'__ceil__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__divmod__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__float__'</span>, <span class="string">'__floor__'</span>, <span class="string">'__floordiv__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__index__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__int__'</span>, <span class="string">'__invert__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lshift__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__neg__'</span>, <span class="string">'__new__'</span>, <span class="string">'__or__'</span>, <span class="string">'__pos__'</span>, <span class="string">'__pow__'</span>, <span class="string">'__radd__'</span>, <span class="string">'__rand__'</span>, <span class="string">'__rdivmod__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rfloordiv__'</span>, <span class="string">'__rlshift__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__ror__'</span>, <span class="string">'__round__'</span>, <span class="string">'__rpow__'</span>, <span class="string">'__rrshift__'</span>, <span class="string">'__rshift__'</span>, <span class="string">'__rsub__'</span>, <span class="string">'__rtruediv__'</span>, <span class="string">'__rxor__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__sub__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__truediv__'</span>, <span class="string">'__trunc__'</span>, <span class="string">'__xor__'</span>, <span class="string">'bit_length'</span>, <span class="string">'conjugate'</span>, <span class="string">'denominator'</span>, <span class="string">'from_bytes'</span>, <span class="string">'imag'</span>, <span class="string">'numerator'</span>, <span class="string">'real'</span>, <span class="string">'to_bytes'</span>]</span><br></pre></td></tr></table></figure><p>这些方法都定义在 <code>PyTypeObject</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_LIMITED_API</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> <span class="title">PyTypeObject</span>;</span> <span class="comment">/* opaque */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.0 */</span></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.1 */</span></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="comment">/* these must be last and never explicitly initialized */</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>所有的整数对象现在都在 <code>Objects/longobject.c</code> 中实现，定义为 <code>PyLong_Type</code> 类型。<code>PyLong_Type</code> 就是一个 <code>PyTypeObject</code> 对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="PyLongObject"><a href="#PyLongObject" class="headerlink" title="PyLongObject"></a>PyLongObject</h3><p>定义于 <code>Include/longobject.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br></pre></td></tr></table></figure><h3 id="PyBoolObject"><a href="#PyBoolObject" class="headerlink" title="PyBoolObject"></a>PyBoolObject</h3><p><code>PyBoolObject</code> 在 Python 中存储布尔类型，定义于 <code>Include/boolobject.h</code> 中。</p><h3 id="PyFloatObject"><a href="#PyFloatObject" class="headerlink" title="PyFloatObject"></a>PyFloatObject</h3><p>在 <code>Include/floatobject.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure><h3 id="PyListObject"><a href="#PyListObject" class="headerlink" title="PyListObject"></a>PyListObject</h3><p>在 <code>Include/listobject.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item contains space for 'allocated' elements.  The number</span></span><br><span class="line"><span class="comment">     * currently in use is ob_size.</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *     0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *     len(list) == ob_size</span></span><br><span class="line"><span class="comment">     *     ob_item == NULL implies ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Items must normally not be NULL, except during construction when</span></span><br><span class="line"><span class="comment">     * the list is not yet visible outside the function that builds it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;建立环境&quot;&gt;&lt;a href=&quot;#建立环境&quot; class=&quot;headerlink&quot; title=&quot;建立环境&quot;&gt;&lt;/a&gt;建立环境&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从 GitHub 上下载源码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python3.x源码" scheme="http://www.lyyyuna.com/tags/Python3-x%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 字符串对象</title>
    <link href="http://www.lyyyuna.com/2017/12/28/python-internal3-string-object/"/>
    <id>http://www.lyyyuna.com/2017/12/28/python-internal3-string-object/</id>
    <published>2017-12-28T08:20:02.000Z</published>
    <updated>2017-12-29T01:34:37.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-的字符串类型和对象"><a href="#Python-的字符串类型和对象" class="headerlink" title="Python 的字符串类型和对象"></a>Python 的字符串类型和对象</h2><p>有了之前<a href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/">整数对象</a>的铺垫，研究字符串类型及其对象，当然是先看其对应的类型结构体和对象结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyTypeObject PyString_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"str"</span>,</span><br><span class="line">    PyStringObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">char</span>),</span><br><span class="line">    string_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    (printfunc)string_print,                    <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &amp;PyBaseString_Type,                         <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    string_new,                                 <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_shash;</span><br><span class="line">    <span class="keyword">int</span> ob_sstate;</span><br><span class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure><p><code>ob_shash</code> 是该字符串的哈希值，由于 Python 的字典实现大量使用了哈希值，且字典的健多为 <code>PyStringObject</code>，预先计算哈希值并保存下来，可以加速字典的运算。</p><p><code>ob_sstate</code> 和字符串对象的 intern 机制有关。</p><p><code>ob_sval</code> 为什么是长度为 1 的数组？这种定义方法其实符合 C99 标准。<a href="https://en.wikipedia.org/wiki/Flexible_array_member" target="_blank" rel="noopener">Flexible array member</a>规定，若要支持柔性数组，可在结构体末尾放置一个不指定长度的数组。而大多数编译器都支持长度为 1 的定义方法，所以就写成 1 了。如果你单独定义 <code>char buf[]</code>，那必然是会报错的。</p><h2 id="创建一个-PyStringObject"><a href="#创建一个-PyStringObject" class="headerlink" title="创建一个 PyStringObject"></a>创建一个 PyStringObject</h2><p>最底层的生成字符串的函数为 <code>PyString_FromString</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size = <span class="built_in">strlen</span>(str);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">    op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    (<span class="keyword">void</span>)PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">    op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</span><br><span class="line">    Py_MEMCPY(op-&gt;ob_sval, str, size+<span class="number">1</span>);  <span class="comment">// 将原始C字串的值搬运过来</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是根据原始的 C 语言字符串生成对应的 <code>PyStringObject</code>。原始字符串被复制到 <code>ob_sval</code> 中。</p><h2 id="intern-机制"><a href="#intern-机制" class="headerlink" title="intern 机制"></a>intern 机制</h2><p>和整数对象一样，<code>PyStringObject</code> 需要优化才堪实用，于是 Python 的设计者便开发了 intern 机制。</p><p>所谓 intern，即如果两个字符串对象的原始字符串相同，那么其 <code>ob_sval</code> 共享同一份内存。若程序中出现了 100 次 <code>hello, world</code>，那么在内存中只会保存一份。</p><p>intern 机制的核心在于字典 <code>interned</code>。该字典为 Python 的内建数据结构，可以简单等价于 C++ 的 <code>map&lt;T,R&gt;</code>。该字典的健值都为字符串本身 <code>pystring:pystring</code>，所有需 intern 的字符串会缓存到该 <code>interned</code> 字典中，当在程序中再遇到相同的字符串 <code>pystring</code>，便可通过字典在 <code>O(1)</code> 时间内检索出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* share short strings */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *t = (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op = (PyStringObject *)t;</span><br><span class="line">        nullstring = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        PyObject *t = (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op = (PyStringObject *)t;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>PyString_FromString</code> 函数最后，会强制将长度为 0 和 1 的字符串 intern，而这一操作的核心为 <code>PyString_InterInPlace</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PyString_InternInPlace(PyObject **p)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interned = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Clear(); <span class="comment">/* Don't leave an exception */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t = PyDict_GetItem(interned, (PyObject *)s);</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        Py_INCREF(t);</span><br><span class="line">        Py_SETREF(*p, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_REFCNT(s) -= <span class="number">2</span>;</span><br><span class="line">    PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_SETREF(op, op2)                      \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                        \</span><br><span class="line">        PyObject *_py_tmp = (PyObject *)(op);   \</span><br><span class="line">        (op) = (op2);                           \</span><br><span class="line">        Py_DECREF(_py_tmp);                     \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>函数的开始会尝试新建 <code>interned</code> 字典。然后是尝试在 <code>interned</code> 字典中找该字符串 <code>PyDict_GetItem</code>。</p><ul><li>若找到，就需要增加该健值对上的引用计数，并减去 <code>PyStringObject</code> 对象的引用计数。<code>PyStringObject</code> 对象减为 0 后会被回收内存。为啥原对象要被回收？因为后续程序只会通过 <code>interned</code> 字典引用字符串，原对象留着没啥用处了。</li><li>若没找到，会尝试在字典中新建健值对 <code>PyDict_SetItem</code>。新建的健值对需要减去 2 个引用计数。我们的 <code>interned</code> 字典健值都是原字符串，该 <code>PyStringObject</code> 无论如何都至少会有两个引用。健值仅仅是作为 Python 虚拟机内部使用，不应影响所运行程序的内存回收，故需减 2。</li></ul><h2 id="单字符字符串的进一步优化"><a href="#单字符字符串的进一步优化" class="headerlink" title="单字符字符串的进一步优化"></a>单字符字符串的进一步优化</h2><p>在 <code>PyString_FromString</code> 函数中，还看到了 <code>characters</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">    PyObject *t = (PyObject *)op;</span><br><span class="line">    PyString_InternInPlace(&amp;t);</span><br><span class="line">    op = (PyStringObject *)t;</span><br><span class="line">    characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单字节的字符串被缓存到了 <code>characters</code> 数组中。在创建字符串函数时，直接从数组中取出单字节字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        one_strings++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>数组比哈希字典效率更高。</p><h2 id="字符串拼接所做的优化"><a href="#字符串拼接所做的优化" class="headerlink" title="字符串拼接所做的优化"></a>字符串拼接所做的优化</h2><p>字符串虽然是变长对象，但并不是可变对象，创建之后，<code>ob_sval</code> 数组的长度无法再改变。在拼接两个字符串 s1, s2 时，必须重新生成一个 <code>PyStringObject</code> 对象来放置 <code>s1-&gt;ob_sval + s2-&gt;sval</code>。如果要连接 N 个 <code>PyStringObject</code> 对象，那么就必须进行 N-1 次的内存申请及内存搬运的工作。毫无疑问，这将严重影响 Python 的执行效率。</p><p>所以官方推荐的做法是使用 <code>join</code> 函数，该函数一次性分配好所有内存，然后统一搬运。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"-"</span></span><br><span class="line">seq = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">print</span> s.join( seq )</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>何种字符串会 intern？不同的 Python 版本似乎采取了不同的策略，以我 Mac 上 Python 2.7.10 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'foo'</span> <span class="keyword">is</span> <span class="string">'foo'</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'foo!'</span> <span class="keyword">is</span> <span class="string">'foo!'</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>*<span class="number">20</span> <span class="keyword">is</span> <span class="string">'a'</span>*<span class="number">20</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>*<span class="number">21</span> <span class="keyword">is</span> <span class="string">'a'</span>*<span class="number">21</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-的字符串类型和对象&quot;&gt;&lt;a href=&quot;#Python-的字符串类型和对象&quot; class=&quot;headerlink&quot; title=&quot;Python 的字符串类型和对象&quot;&gt;&lt;/a&gt;Python 的字符串类型和对象&lt;/h2&gt;&lt;p&gt;有了之前&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 整数对象</title>
    <link href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/"/>
    <id>http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/</id>
    <published>2017-12-24T08:20:02.000Z</published>
    <updated>2017-12-24T13:23:21.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-的面向对象"><a href="#Python-的面向对象" class="headerlink" title="Python 的面向对象"></a>Python 的面向对象</h2><p>面向对象编程中，对象是数据以及基于这些数据的操作的集合，实际上在计算机中这只是一堆内存逻辑上的集合，无论这段内存是连续的还是分开的。</p><p>Python 是由 C 语言写成，描述一段逻辑上结合的内存，直接用结构体 <code>struct</code> 就可以了。但是 <code>struct</code> 并不是面向对象中类型的概念，对象还需要成员函数。所以还需要另外一个结构体 <code>struct</code> 来描述成员函数的集合。</p><p>上述特点就导致了在 Python 中，实际的类型也是一个对象，这个类型对象的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    cmpfunc tp_compare;</span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="keyword">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.0 */</span></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.1 */</span></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Added in release 2.2 */</span></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="comment">/* these must be last and never explicitly initialized */</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><p>所以在源码中，Python 最基础的对象表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>每一个对象都有一个指针指向自己所属的类型对象，而类型对象则有关于这个对象支持的所有操作的信息。</p><p>仔细看 <code>PyTypeObject</code> 的头部，<code>PyObject_VAR_HEAD</code> 即含有 <code>ob_type</code>，难道还有类型的类型这个概念？是的，这个终极的类型就是元类，即 <code>metaclass</code>。做个简单的实验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br></pre></td></tr></table></figure><p>在 Python 中类型是对象，所以类型对象也有类型，而元类的类型就是自己。</p><h2 id="Python-的整数类型"><a href="#Python-的整数类型" class="headerlink" title="Python 的整数类型"></a>Python 的整数类型</h2><p>整数类型没啥可说的，按照 <code>PyTypeObject</code> 结构去填充信息即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyInt_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyIntObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)int_dealloc,                    <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    (printfunc)int_print,                       <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    (cmpfunc)int_compare,                       <span class="comment">/* tp_compare */</span></span><br><span class="line">    (reprfunc)int_to_decimal_string,            <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;int_as_number,                             <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)int_hash,                         <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)int_to_decimal_string,            <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          <span class="comment">/* tp_flags */</span></span><br><span class="line">    int_doc,                                    <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    int_methods,                                <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    int_getset,                                 <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    int_new,                                    <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="整数对象的内存"><a href="#整数对象的内存" class="headerlink" title="整数对象的内存"></a>整数对象的内存</h2><p>再看一眼 PyObject 对象，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>我们看到了 <code>ob_refcnt</code> 引用计数对象，可以很容易地联想到 Python 虚拟机是以引用计数为基础构建垃圾回收机制。既然如此，那还有没有必要专门讨论整数对象的内存使用,而直接抽象成引用计数归零后释放内存？</p><p>事实上，为了提高虚拟机的性能，整数对象使用了多种技术。</p><h3 id="大整数创建"><a href="#大整数创建" class="headerlink" title="大整数创建"></a>大整数创建</h3><p>在 intobject.c 中定义有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span></span><br><span class="line">    PyIntObject objects[N_INTOBJECTS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><code>block_list</code> 是由一个个 <code>PyIntBlock</code> 串起来的链表，每一个 <code>PyIntBlock</code> 是一个整数数组。<code>free_list</code> 是由空闲的 <code>PyIntObject</code> 组成的链表，空闲是指这块内存虽然被划分为一个 <code>PyIntObject</code>，但并没有被用于表示一个真正的整数，即其所存储的信息是无用的。</p><p>整数创建时，<code>PyObject * PyInt_FromLong(long ival)</code> 会被调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyInt_FromLong(<span class="keyword">long</span> ival)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> PyIntObject *v;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (free_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((free_list = fill_free_list()) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Inline PyObject_New */</span></span><br><span class="line">    v = free_list;</span><br><span class="line">    free_list = (PyIntObject *)Py_TYPE(v);</span><br><span class="line">    (<span class="keyword">void</span>)PyObject_INIT(v, &amp;PyInt_Type);</span><br><span class="line">    v-&gt;ob_ival = ival;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntObject *</span><br><span class="line">fill_free_list(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyIntObject *p, *q;</span><br><span class="line">    <span class="comment">/* Python's object allocator isn't appropriate for large blocks. */</span></span><br><span class="line">    p = (PyIntObject *) PyMem_MALLOC(<span class="keyword">sizeof</span>(PyIntBlock));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyIntObject *) PyErr_NoMemory();</span><br><span class="line">    ((PyIntBlock *)p)-&gt;next = block_list;</span><br><span class="line">    block_list = (PyIntBlock *)p;</span><br><span class="line">    <span class="comment">/* Link the int objects together, from rear to front, then return</span></span><br><span class="line"><span class="comment">       the address of the last int object in the block. */</span></span><br><span class="line">    p = &amp;((PyIntBlock *)p)-&gt;objects[<span class="number">0</span>];</span><br><span class="line">    q = p + N_INTOBJECTS;</span><br><span class="line">    <span class="keyword">while</span> (--q &gt; p)</span><br><span class="line">        Py_TYPE(q) = (struct _typeobject *)(q<span class="number">-1</span>);</span><br><span class="line">    Py_TYPE(q) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p + N_INTOBJECTS - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建整数的时候，会先尝试从 <code>free_list</code> 中取，如果没有空闲的，就会尝试 <code>fill_free_list</code>。这个新的 <code>PyIntBlock</code> 中，每一个 <code>PyIntObject</code> 都借用 <code>ob_type</code> 来连接成链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_TYPE(ob) (((PyObject*)(ob))-&gt;ob_type)</span></span><br></pre></td></tr></table></figure><p>这里只是借用，初看源码的朋友不要被这里搞混了。因为此时这块内存并没有存放整数，它的成员自然可以借来他用。<code>free_list</code> 指向数组的末尾，从后往前链接到数组首部。</p><h3 id="大整数销毁"><a href="#大整数销毁" class="headerlink" title="大整数销毁"></a>大整数销毁</h3><p>当一个整数销毁时，便会进入 <code>int_dealloc</code> 函数内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">int_dealloc(PyIntObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyInt_CheckExact(v)) &#123;</span><br><span class="line">        Py_TYPE(v) = (struct _typeobject *)free_list;</span><br><span class="line">        free_list = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(v)-&gt;tp_free((PyObject *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在正常情况下不会走到 <code>else</code> 分支，意味着所谓的销毁，只是把这个整数的 <code>PyIntObject</code> 重新放回 <code>free_list</code> 链表中，并不会释放这块内存。这岂不会造成内存泄漏？只能说，理论上会。整数对象所占用的内存空间，只和这个程序同时拥有的最多的整数数量有关。</p><p>上述做法也是为了优化性能，虚拟机不再需要频繁的 <code>malloc</code> 和 <code>free</code>。</p><h3 id="小整数"><a href="#小整数" class="headerlink" title="小整数"></a>小整数</h3><p>除了普通的整数外，Python 中还存在着一种小整数对象。在之前的 <code>PyInt_FromLong</code> 函数中，我们略了一部分，现在我们从另一个角度看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyInt_FromLong(<span class="keyword">long</span> ival)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> PyIntObject *v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123;</span><br><span class="line">        v = small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当想创建的整数在 <code>-NSMALLNEGINTS ~ NSMALLPOSINTS</code> 之间时，就会从 <code>small_ints</code> 数组中直接取出。这范围内的整数即为小整数。小整数使用广泛，循环的初始值，终结值，步进值等等，都是数值很小的整数。小整数从 Python 虚拟机运行之初就存在，使用它们既不需要 <code>malloc</code> 和 <code>free</code>，甚至连指针操作 <code>free_list</code> 也不要。效率比大整数更高。</p><p>而小整数的范围可在编译 Python 时指定，默认为 <code>-5 ~ 257</code>。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>改造一下整数打印函数，反映出内存的变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> values[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> refcounts[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/* ARGSUSED */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">int_print(PyIntObject *v, FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">     <span class="comment">/* flags -- not used but required by interface */</span></span><br><span class="line">&#123;</span><br><span class="line">    PyIntObject * intObjectPtr;</span><br><span class="line">    PyIntBlock * p = block_list;</span><br><span class="line">    PyIntBlock * last = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> int_val = v-&gt;ob_ival;</span><br><span class="line">    Py_BEGIN_ALLOW_THREADS</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%ld"</span>, int_val);</span><br><span class="line">    Py_END_ALLOW_THREADS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        last = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    intObjectPtr = last-&gt;objects;</span><br><span class="line">    intObjectPtr += N_INTOBJECTS<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nvalue's address is @%p\n"</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++, --intObjectPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        values[i] = intObjectPtr-&gt;ob_ival;</span><br><span class="line">        refcounts[i] = intObjectPtr-&gt;ob_refcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  value : "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  refcnt : "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, refcounts[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" block_list count : %d\n"</span>, count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" free_list address : %p\n"</span>, free_list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行重新编译后的 python 虚拟机。</p><h3 id="大整数实验"><a href="#大整数实验" class="headerlink" title="大整数实验"></a>大整数实验</h3><p>首先是连续创建两个大整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1111</span></span><br><span class="line">value<span class="string">'s address is @0x100303888</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     587     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038a0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b=2222</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b</span></span><br><span class="line"><span class="string">2222</span></span><br><span class="line"><span class="string">value'</span>s address <span class="keyword">is</span> @<span class="number">0x1003038a0</span></span><br><span class="line">  value : <span class="number">-5</span>    <span class="number">-4</span>      <span class="number">-3</span>      <span class="number">-2</span>      <span class="number">-1</span>      <span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">  refcnt : <span class="number">1</span>    <span class="number">1</span>       <span class="number">1</span>       <span class="number">1</span>       <span class="number">54</span>      <span class="number">389</span>     <span class="number">587</span>     <span class="number">84</span></span><br><span class="line"> block_list count : <span class="number">9</span></span><br><span class="line"> free_list address : <span class="number">0x1003038b8</span></span><br></pre></td></tr></table></figure><p>第一次的 <code>free_list</code>，正好是第二次整数的地址。可以看到小整数都至少有一个引用，有些多于一次是因为 python 虚拟机内部使用的缘故。</p><p>当尝试创建一个相同的大整数时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="number">2222</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">2222</span></span><br><span class="line">value<span class="string">'s address is @0x1003038b8</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     587     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038d0</span></span><br></pre></td></tr></table></figure><p>可以看出，虽然值相同，但并不是同一个内存块。</p><h3 id="小整数实验"><a href="#小整数实验" class="headerlink" title="小整数实验"></a>小整数实验</h3><p>创建两个相同的小整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">1</span></span><br><span class="line">value<span class="string">'s address is @0x100604ce8</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     591     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038d0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; c=1</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; c</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">value'</span>s address <span class="keyword">is</span> @<span class="number">0x100604ce8</span></span><br><span class="line">  value : <span class="number">-5</span>    <span class="number">-4</span>      <span class="number">-3</span>      <span class="number">-2</span>      <span class="number">-1</span>      <span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">  refcnt : <span class="number">1</span>    <span class="number">1</span>       <span class="number">1</span>       <span class="number">1</span>       <span class="number">54</span>      <span class="number">389</span>     <span class="number">592</span>     <span class="number">84</span></span><br><span class="line"> block_list count : <span class="number">9</span></span><br><span class="line"> free_list address : <span class="number">0x100303828</span></span><br></pre></td></tr></table></figure><p>可以看出，整数 1 只是增加了引用计数，内存块是同一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-的面向对象&quot;&gt;&lt;a href=&quot;#Python-的面向对象&quot; class=&quot;headerlink&quot; title=&quot;Python 的面向对象&quot;&gt;&lt;/a&gt;Python 的面向对象&lt;/h2&gt;&lt;p&gt;面向对象编程中，对象是数据以及基于这些数据的操作的集合，实际
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 开始</title>
    <link href="http://www.lyyyuna.com/2017/12/19/python-internal1-begin/"/>
    <id>http://www.lyyyuna.com/2017/12/19/python-internal1-begin/</id>
    <published>2017-12-19T08:20:02.000Z</published>
    <updated>2017-12-19T09:03:27.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p>Python 官网可以下载到<a href="https://www.python.org/downloads/source/" target="_blank" rel="noopener">源码</a>。</p><p>Linux 上编译需要先安装额外模块，例如 Ubuntu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get build-dep python</span><br><span class="line">sudo apt-get install libreadline-dev libsqlite3-dev libbz2-dev libssl-dev libreadline6-dev libsqlite3-dev liblzma-dev libbz2-dev tk8.5-dev blt-dev libgdbm-dev libssl-dev libncurses5-dev zlib1g-dev libncurses5-dev</span><br></pre></td></tr></table></figure><p>Windows 上只需打开 PC/VS9.0/pcbuild.sln，选择最少的模块 python, pythoncore 编译，如果这两个模块编译时报错，只需按照错误提示，钩上所需模块即可。</p><p>Mac 上只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>本系列文章在 Mac 上完成，但环境本身只影响编译，并不影响分析过程，读者选择方便阅读源码的环境即可。</p><h2 id="第一个实验"><a href="#第一个实验" class="headerlink" title="第一个实验"></a>第一个实验</h2><p>Mac 上编译完会生成一个 <code>python.exe</code> 的可执行文件。</p><p>让我们尝试在 Python 源码中修改整数输出的部分，在每一个 int 打印时，输出 <code>hello, world</code>。</p><p>修改 /Objects/intobject.c，添加 <code>fprintf(fp, &quot;hello, world\n&quot;);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">int_print(PyIntObject *v, FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">     <span class="comment">/* flags -- not used but required by interface */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> int_val = v-&gt;ob_ival;</span><br><span class="line">    Py_BEGIN_ALLOW_THREADS</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%ld"</span>, int_val);</span><br><span class="line">    Py_END_ALLOW_THREADS</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是实验结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">hello, world</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(1)</span><br><span class="line">hello, world</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(&apos;eee&apos;)</span><br><span class="line">eee</span><br></pre></td></tr></table></figure><p>改动只影响了整数打印的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码编译&quot;&gt;&lt;a href=&quot;#源码编译&quot; class=&quot;headerlink&quot; title=&quot;源码编译&quot;&gt;&lt;/a&gt;源码编译&lt;/h2&gt;&lt;p&gt;Python 官网可以下载到&lt;a href=&quot;https://www.python.org/downloads/source
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的 descriptor</title>
    <link href="http://www.lyyyuna.com/2017/09/14/python-descriptor/"/>
    <id>http://www.lyyyuna.com/2017/09/14/python-descriptor/</id>
    <published>2017-09-14T08:20:02.000Z</published>
    <updated>2017-11-29T00:19:00.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>通常，一个 descriptor 是具有“绑定行为”的对象属性。所绑定行为可通过 descriptor 协议被自定义的 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 方法重写。如果一个对象的上述三个方法任意一个被重写，则就可被称为 descriptor。</p><p>属性的默认操作是从对象字典中获取、设置和删除一个属性。例如，a.x 有一个查找链，先 <code>a.__dict__[&#39;x&#39;]</code>，若没有则 <code>type(a).__dict__[&#39;x&#39;]</code>，若没有增往上查找父类直到元类。如果查找链中，对象被定义了 descriptor 方法，Python 就会覆盖默认行为。</p><p>Descriptor 是一个强大的工具，虽然开发者不常接触到它，但它其实就是类、属性、函数、方法、静态方法、类方法以及 <code>super()</code> 背后的运行机制。</p><h2 id="Descriptor-协议"><a href="#Descriptor-协议" class="headerlink" title="Descriptor 协议"></a>Descriptor 协议</h2><p>三个方法原型如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">descr.__get__(self, obj, type=None) --&gt; value</span><br><span class="line"></span><br><span class="line">descr.__set__(self, obj, value) --&gt; None</span><br><span class="line"></span><br><span class="line">descr.__delete__(self, obj) --&gt; None</span><br></pre></td></tr></table></figure><p>数据 descriptor 是同时具有 <code>__get__()</code> 和 <code>__set__()</code> 方法的对象，若只有 <code>__get__()</code> 方法，则为非数据 descriptor。如果实例字典中有和数据 descriptor 同名的入口，则数据 descriptor 优先级更高。相反，非数据 descriptor 优先级低。</p><p>让 <code>__set__()</code> 方法抛出异常，就能创建一个只读数据 descriptor。</p><h2 id="调用-descriptor"><a href="#调用-descriptor" class="headerlink" title="调用 descriptor"></a>调用 descriptor</h2><p>descriptor 可以直接通过方法名调用。例如，<code>d.__get__(obj)</code>。</p><p>而通过访问对象属性，自动调用 descriptor 才是更通用的做法。例如，如果 <code>d</code> 定义了方法 <code>__get__()</code>，则 <code>obj.d</code> 会调用 <code>d.__get__(obj)</code>。</p><p>对于对象，<code>b.x</code> 会被转换成 <code>type(b).__dict__[&#39;x&#39;].__get__(b, type(b))</code>。而对于类（是的，类也可以调用），<code>B.x</code> 会被转换成 <code>B.__dict__[&#39;x&#39;].__get__(None, B)</code>。</p><h2 id="Descriptor-例子"><a href="#Descriptor-例子" class="headerlink" title="Descriptor 例子"></a>Descriptor 例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RevealAccess</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""A data descriptor that sets and returns values</span></span><br><span class="line"><span class="string">       normally and prints a message logging their access.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initval=None, name=<span class="string">'var'</span>)</span>:</span></span><br><span class="line">        self.val = initval</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype)</span>:</span></span><br><span class="line">        print(<span class="string">'Retrieving'</span>, self.name)</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, val)</span>:</span></span><br><span class="line">        print(<span class="string">'Updating'</span>, self.name)</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    x = RevealAccess(<span class="number">10</span>, <span class="string">'var "x"'</span>)</span><br><span class="line"><span class="meta">... </span>    y = <span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x = <span class="number">20</span></span><br><span class="line">Updating var <span class="string">"x"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.y</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;通常，一个 descriptor 是具有“绑定行为”的对象属性。所绑定行为可通过 descriptor 协议被自定义的 &lt;code&gt;__ge
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Writing Your Own Windows Debugger - Debug Event</title>
    <link href="http://www.lyyyuna.com/2017/05/01/write-a-windows-debugger-02-debug-event/"/>
    <id>http://www.lyyyuna.com/2017/05/01/write-a-windows-debugger-02-debug-event/</id>
    <published>2017-05-01T13:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<p>We have introduced the debug loop last time, in this post, I will talk about various debug events.</p><h3 id="RIP-EVENT"><a href="#RIP-EVENT" class="headerlink" title="RIP_EVENT"></a>RIP_EVENT</h3><p>I find very few documents about this event, only mentioned with words like <em>system error</em> or <em>internal error</em>. So I decide to print a error message and skip it. As my project is not fully tested, I have never<br>encountered such a situation.</p><h3 id="OUTPUT-DEBUG-STRING-EVENT"><a href="#OUTPUT-DEBUG-STRING-EVENT" class="headerlink" title="OUTPUT_DEBUG_STRING_EVENT"></a>OUTPUT_DEBUG_STRING_EVENT</h3><p>When the debuggee calls the <em>OutpuDebugString</em> function, it will raise this debug event. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OUTPUT_DEBUG_STRING_INFO</span> &#123;</span></span><br><span class="line">  LPSTR lpDebugStringData;</span><br><span class="line">  WORD  fUnicode;</span><br><span class="line">  WORD  nDebugStringLength;</span><br><span class="line">&#125; OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;</span><br></pre></td></tr></table></figure><ul><li>lpDebugStringData, The debugging string in the calling process’s address space.</li><li>fUnicode, The format of the debugging string. If this member is zero, the debugging string is ANSI; if it is nonzero, the string is Unicode.</li><li>nDebugStringLength, The size of the debugging string, in characters. The length includes the string’s terminating null character.</li></ul><p>With ReadProcessMemory function, the debugger can obtain the value of the string:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnOutputDebugString</span><span class="params">(<span class="keyword">const</span> OUTPUT_DEBUG_STRING_INFO* pInfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE* pBuffer = (BYTE*)<span class="built_in">malloc</span>(pInfo-&gt;nDebugStringLength);</span><br><span class="line"></span><br><span class="line">    SIZE_T bytesRead;</span><br><span class="line"></span><br><span class="line">    ReadProcessMemory(</span><br><span class="line">        g_hProcess,</span><br><span class="line">        pInfo-&gt;lpDebugStringData,</span><br><span class="line">        pBuffer, </span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        &amp;bytesRead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> requireLen = MultiByteToWideChar(</span><br><span class="line">        CP_ACP,</span><br><span class="line">        MB_PRECOMPOSED,</span><br><span class="line">        (LPCSTR)pBuffer,</span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    TCHAR* pWideStr = (TCHAR*)<span class="built_in">malloc</span>(requireLen * <span class="keyword">sizeof</span>(TCHAR));</span><br><span class="line"></span><br><span class="line">    MultiByteToWideChar(</span><br><span class="line">        CP_ACP,</span><br><span class="line">        MB_PRECOMPOSED,</span><br><span class="line">        (LPCSTR)pBuffer,</span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        pWideStr,</span><br><span class="line">        requireLen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; TEXT(<span class="string">"Debuggee debug string: "</span>) &lt;&lt; pWideStr &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pWideStr);</span><br><span class="line">    <span class="built_in">free</span>(pBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LOAD-DLL-DEBUG-EVENT"><a href="#LOAD-DLL-DEBUG-EVENT" class="headerlink" title="LOAD_DLL_DEBUG_EVENT"></a>LOAD_DLL_DEBUG_EVENT</h3><p>After the debuggee loads a dll, this debug event will be triggered. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LOAD_DLL_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  HANDLE hFile;</span><br><span class="line">  LPVOID lpBaseOfDll;</span><br><span class="line">  DWORD  dwDebugInfoFileOffset;</span><br><span class="line">  DWORD  nDebugInfoSize;</span><br><span class="line">  LPVOID lpImageName;</span><br><span class="line">  WORD   fUnicode;</span><br><span class="line">&#125; LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>You may want to use the member <em>lpImageName</em> to retrieve the dll file name, however, it doesn’t work. According the explaination on MSDN, this member is pointer to the file name of the associated <em>hFile</em>, it  may, in turn, either be NULL or point to the actual filename. Even it is not NULL, ReadProcessMemory may also return a NULL. As a result, this membor is not reliable.</p><p>It seems that there is no direct Windows API to get the filename from the file handle. Someone has tried <a href="http://blog.csdn.net/bodybo/archive/2006/08/28/1131346.aspx" target="_blank" rel="noopener">this way</a>.</p><h3 id="UNLOAD-DLL-DEBUG-EVENT"><a href="#UNLOAD-DLL-DEBUG-EVENT" class="headerlink" title="UNLOAD_DLL_DEBUG_EVENT"></a>UNLOAD_DLL_DEBUG_EVENT</h3><p>When a dll module is unloaded, this event will be triggered, nothing needs handled, just skip it.</p><h3 id="CREATE-PROCESS-DEBUG-EVENT"><a href="#CREATE-PROCESS-DEBUG-EVENT" class="headerlink" title="CREATE_PROCESS_DEBUG_EVENT"></a>CREATE_PROCESS_DEBUG_EVENT</h3><p>After the process is created, this is the first debug event. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CREATE_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  HANDLE                 hFile;</span><br><span class="line">  HANDLE                 hProcess;</span><br><span class="line">  HANDLE                 hThread;</span><br><span class="line">  LPVOID                 lpBaseOfImage;</span><br><span class="line">  DWORD                  dwDebugInfoFileOffset;</span><br><span class="line">  DWORD                  nDebugInfoSize;</span><br><span class="line">  LPVOID                 lpThreadLocalBase;</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress;</span><br><span class="line">  LPVOID                 lpImageName;</span><br><span class="line">  WORD                   fUnicode;</span><br><span class="line">&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>We can use this structure to get the symbols of the debuggee program.</p><h3 id="EXIT-PROCESS-DEBUG-EVENT"><a href="#EXIT-PROCESS-DEBUG-EVENT" class="headerlink" title="EXIT_PROCESS_DEBUG_EVENT"></a>EXIT_PROCESS_DEBUG_EVENT</h3><p>When debuggee process exits, this event will be triggered. The following structure describe the detail of the event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXIT_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  DWORD dwExitCode;</span><br><span class="line">&#125; EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>What we can do is to print the exit code.</p><h3 id="CREATE-THREAD-DEBUG-EVENT"><a href="#CREATE-THREAD-DEBUG-EVENT" class="headerlink" title="CREATE_THREAD_DEBUG_EVENT"></a>CREATE_THREAD_DEBUG_EVENT</h3><p>It is similar to the process create debug event.</p><h3 id="EXIT-THREAD-DEBUG-EVENT"><a href="#EXIT-THREAD-DEBUG-EVENT" class="headerlink" title="EXIT_THREAD_DEBUG_EVENT"></a>EXIT_THREAD_DEBUG_EVENT</h3><p>It is similar to the process exit debug event.</p><h3 id="EXCEPTION-DEBUG-EVENT"><a href="#EXCEPTION-DEBUG-EVENT" class="headerlink" title="EXCEPTION_DEBUG_EVENT"></a>EXCEPTION_DEBUG_EVENT</h3><p>It is the most important event of our debugger, I will cover it in the next post.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have introduced the debug loop last time, in this post, I will talk about various debug events.&lt;/p&gt;
&lt;h3 id=&quot;RIP-EVENT&quot;&gt;&lt;a href=&quot;#RIP-E
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Windows Debugger" scheme="http://www.lyyyuna.com/tags/Windows-Debugger/"/>
    
  </entry>
  
  <entry>
    <title>Writing Your Own Windows Debugger - Overview</title>
    <link href="http://www.lyyyuna.com/2017/04/27/write-a-windows-debugger-01-overview/"/>
    <id>http://www.lyyyuna.com/2017/04/27/write-a-windows-debugger-01-overview/</id>
    <published>2017-04-27T09:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Debuggers are the apple of the hacker’s eye. We benefit a lot from the debugger, but few of us know the principle of it.</p><p>In the book <em>Gray Hat Python</em> , the author has constructed a simple debugger. However, it is too simple, it is only a machine language level debugger, and can only set basic breakpoints and show CPU register information. We also want to know how to </p><ul><li>Show source code </li><li>Set breakpoint based on lines, not memory address</li><li>Set Step In, Step Out, Step Over</li><li>Show stack trace</li><li>Show global and local variables</li></ul><p>In this Chinese blog <a href="http://www.cnblogs.com/zplutor/archive/2011/03/04/1971279.html" target="_blank" rel="noopener">Zplutor’s</a>, I find a excellent series which has covered most above topics. I decide to write a English blog about it, and I will turn his code into a C++ version.</p><p>Before getting started, let’s make some limitations:</p><ul><li>It is only a user mode debugger.</li><li>It is only a Windows debugger. Although the principle is quite same, but Windows has offered lots of convenient APIs. The implementation will be different on Linux.</li><li>It is only a terminal-based debugger.</li><li>Different from <em>Gray Hat Python</em> , the debugger will be implemented by C++.</li><li>The debuggee program is single thread.</li></ul><p>The modified debugger can be found <a href="https://github.com/lyyyuna/anotherDebugger" target="_blank" rel="noopener">here</a>. It is only tested under Windows 10 + Visual Studio 2013.</p><h2 id="To-Start-the-Debuggee-Program"><a href="#To-Start-the-Debuggee-Program" class="headerlink" title="To Start the Debuggee Program"></a>To Start the Debuggee Program</h2><p>The so-called user mode debugger is to debug the program in user mode. Windows has provided a series of open API for debugging, and they can be devided into three categories:</p><ul><li>API for starting the debuggee program</li><li>API for handling debug event during debug loop</li><li>API for inspecing and modifying debuggee program</li></ul><p>The first thing to do before debugging a program is to start it. On Windows, we use <em>CreateProcess</em> to start to program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO startupinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">startupinfo.cb = <span class="keyword">sizeof</span>(startupinfo);</span><br><span class="line">PROCESS_INFORMATION processinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> creationflags = DEBUG_ONLY_THIS_PROCESS | CREATE_NEW_CONSOLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CreateProcess(</span><br><span class="line">    <span class="string">"L:\\git_up\\anotherDebugger\\anotherDebugger\\Debug\\test.exe"</span>,</span><br><span class="line">    <span class="comment">//path,</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    FALSE,</span><br><span class="line">    creationflags,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;startupinfo,</span><br><span class="line">    &amp;processinfo) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CreateProcess failed: "</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DEBUG_ONLY_THIS_PROCESS means the subprocess of the debuggee will not be debugged. If you need subprocess, use DEBUG_PROCESS.</li><li>CREATE_NEW_CONSOLE means the debuggee’s and debugger’s output will be separated in two consoles.</li><li>If the debugger process exits, the debuggee will also exit.</li></ul><h2 id="Debugger-loop"><a href="#Debugger-loop" class="headerlink" title="Debugger loop"></a>Debugger loop</h2><p>The debugger loop is a bit like Windows GUI message loop, some operations and exceptions will stop the debuggee and send event to the debugger. We always use </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG_EVENT debugEvent;</span><br><span class="line">WaitForDebugEvent(&amp;debugEvent, INFINITE)</span><br></pre></td></tr></table></figure><p>to capture the debug event.</p><p>There are 9 debug event in total:</p><ul><li>CREATE_PROCESS_DEBUG_EVENT. Reports a create-process debugging event. </li><li>CREATE_THREAD_DEBUG_EVENT. Reports a create-thread debugging event.</li><li>EXCEPTION_DEBUG_EVENT. Reports an exception debugging event.</li><li>EXIT_PROCESS_DEBUG_EVENT. Reports an exit-process debugging event.</li><li>EXIT_THREAD_DEBUG_EVENT. Reports an exit-thread debugging event.</li><li>LOAD_DLL_DEBUG_EVENT. Reports a load-dynamic-link-library (DLL) debugging event.</li><li>OUTPUT_DEBUG_STRING_EVENT. Reports an output-debugging-string debugging event.</li><li>RIP_EVENT. Reports a RIP-debugging event (system debugging error).</li><li>UNLOAD_DLL_DEBUG_EVENT. Reports an unload-DLL debugging event. </li></ul><p>If the debug event has been handled correctly, then</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContinueDebugEvent(debuggeeprocessID, debuggeethreadID, DBG_CONTINUE);</span><br></pre></td></tr></table></figure><p>to continue the debuggee process. Let’s combine the above to construct the debug loop:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (WaitForDebugEvent(&amp;debugEvent, INFINITE) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">    debuggeeprocessID = debugEvent.dwProcessId;</span><br><span class="line">    debuggeethreadID = debugEvent.dwThreadId;</span><br><span class="line">    <span class="keyword">if</span> (dispatchDebugEvent(debugEvent) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        ContinueDebugEvent(debuggeeprocessID, debuggeethreadID, FLAG.continueStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dispatchDebugEvent</span><span class="params">(<span class="keyword">const</span> DEBUG_EVENT &amp; debugEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (debugEvent.dwDebugEventCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CREATE_THREAD_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXIT_PROCESS_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXIT_THREAD_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> LOAD_DLL_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UNLOAD_DLL_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OUTPUT_DEBUG_STRING_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RIP_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unknown debug event."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the next part of the series, I intend to give a brief introduction about the 9 debug events.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Debuggers are the apple of the
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Windows Debugger" scheme="http://www.lyyyuna.com/tags/Windows-Debugger/"/>
    
  </entry>
  
</feed>
