<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyyyuna 的小花园</title>
  
  <subtitle>动静中之动</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lyyyuna.com/"/>
  <updated>2020-02-24T08:45:45.765Z</updated>
  <id>http://www.lyyyuna.com/</id>
  
  <author>
    <name>lyyyuna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang 的版本管理原则</title>
    <link href="http://www.lyyyuna.com/2020/02/22/go-the-principles-versioning-in-go/"/>
    <id>http://www.lyyyuna.com/2020/02/22/go-the-principles-versioning-in-go/</id>
    <published>2020-02-22T08:20:02.000Z</published>
    <updated>2020-02-24T08:45:45.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译+删选+理解自 <a href="https://research.swtch.com/vgo-principles" target="_blank" rel="noopener">The Principles of Versioning in Go</a></p><h2 id="为什么需要版本？"><a href="#为什么需要版本？" class="headerlink" title="为什么需要版本？"></a>为什么需要版本？</h2><p>让我们先看下传统基于<code>GOPATH</code>的<code>go get</code>是如何导致版本管理失败的。</p><p>假设有一个全新安装的 Go 环境，我们需要写一个程序导入<code>D</code>，因此运行<code>go get D</code>。记住现在是基于<code>GOPATH</code>的<code>go get</code>，不是 <code>go mod</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get D</span><br></pre></td></tr></table></figure><p><img src="/img/posts/version-in-go/vgo-why-1@1.5x.png" alt=""></p><p>该命令会寻找并下载最新版本的<code>D 1.0</code>，并假设现在能成功构建。</p><p>几个月后我们需要一个新的库<code>C</code>，我们接着运行<code>go get C</code>，该库的版本为 1.8。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get C</span><br></pre></td></tr></table></figure><p><img src="/img/posts/version-in-go/vgo-why-2@1.5x.png" alt=""></p><p><code>C</code>导入<code>D</code>，但是<code>go get</code>发现当前环境内已经下载过<code>D</code>库了，所以 Go 会重复使用该库。不幸的是，本地的<code>D</code>版本是 1.0，而<code>C</code>对<code>D</code>有版本依赖，必须是 1.4 以上（有可能 1.4 有一些 bugfix 或者新 feature）。</p><p>显而易见这里<code>C</code>会构建失败。我们再次运行<code>go get -u C</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u C</span><br></pre></td></tr></table></figure><p><img src="/img/posts/version-in-go/vgo-why-3@2x.png" alt=""></p><p>不幸的是，（假设）一小时前<code>D</code>的作者发布了<code>D 1.6</code>，该版本又引入了一个缺陷。因为<code>go get -u</code>一直使用最新的依赖，所以使用 1.6 的<code>C</code>又构建失败了。</p><p>由这个例子可以看出，基于<code>GOPATH</code>的<code>go get</code>缺乏版本管理，会导致两种问题，要么版本过低，要么版本过高。我们需要一种机制，<code>C</code>和<code>D</code>的作者能够一起开发和测试。</p><p>自从<code>goinstall/go get</code>推出之后，Go 程序员就对版本管理有着强烈的诉求，过去几年间，很多第三方的工具被开发出来。然而，这些工具对版本控制的细节有着不同的实现和理解，这会导致不同的库若使用不同的工具，库之间仍然无法协同工作。</p><h2 id="软件工程中的版本"><a href="#软件工程中的版本" class="headerlink" title="软件工程中的版本"></a>软件工程中的版本</h2><p>过去两年间（2019），官方试图在<code>go</code>命令中引入<code>Go moduless</code>的概念来支持版本管理。<code>Go moduless</code>带来新的库导入语法——即语义化导入版本(Semantic import versioning)，而在选择版本时，使用了新的算法——即最小版本选择算法。</p><p>你可能会问：为什么不使用其他语言的现成经验？Java 有<code>Maven</code>，Node 有<code>NPM</code>，Ruby 有<code>Bundler</code>，Rust 有<code>Cargo</code>，他们解决版本依赖的思路不好么？</p><p>你可能还会问：Go 团队在 2018 早些时候引入了一个试验性的工具<code>Dep</code>，该工具实现上与<code>Bundler</code>和<code>Cargo</code>一致，现在为啥又变卦了？</p><p>答案是我们从使用<code>Bundler</code>/<code>Cargo</code>/<code>Dep</code>的经验中发现，它们所谓处理依赖的方法，只会使项目越来越复杂，<code>go modules</code>决定另辟蹊径。</p><h2 id="三原则"><a href="#三原则" class="headerlink" title="三原则"></a>三原则</h2><p>回到一个很基础的问题：什么是软件工程？软件工程和编程有什么区别？原作者 Russ Cox 使用了这个定义：</p><blockquote><p>Software engineering is what happens to programming<br>when you add time and other programmers.</p></blockquote><p>为了简化软件工程，<code>Dep</code>和<code>Go moduless</code>在原则上有三个显著的改变，它们是兼容性、可重复性和可合作性。本文余下部分会详细阐述这三个指导思想。</p><h3 id="原则-1：兼容性"><a href="#原则-1：兼容性" class="headerlink" title="原则 #1：兼容性"></a>原则 #1：兼容性</h3><p>第一原则是兼容性，或者称之为稳定性，程序中<strong>名字</strong>的意义不能随着时间改变。一年前一个名字的含义和今年、后年应该完全一致。</p><p>例如，程序员经常会对标准库<code>string.Split</code>的细节困扰。我们期望在<code>&quot;hello world&quot;</code>调用后产生两个字符串<code>&quot;hello&quot;</code>和<code>&quot;world</code>。但是如果函数输入有前、后或着重复的空格，输出结果也会包含空字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example: strings.Split(x, &quot; &quot;)</span><br><span class="line"></span><br><span class="line">&quot;hello world&quot;  =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello  world&quot; =&gt; &#123;&quot;hello&quot;, &quot;&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot; hello world&quot; =&gt; &#123;&quot;&quot;, &quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello world &quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;, &quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p>假设我们决定改变这一行为，去除所有空字符串，可以么？</p><p><strong>不</strong></p><p>因为我们已经在旧版<code>string.Split</code>的文档和实现上达成一致。有无数的程序依赖于这一行为，改变它会破话兼容性原则。</p><p>对于新的行为，正确的做法是给一个新的名字。事实上也是如此，我们没有重新定义<code>strings.Split</code>，几年前，标准库引入了<code>strings.Fields</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example: strings.Fields(x)</span><br><span class="line"></span><br><span class="line">&quot;hello world&quot;  =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello  world&quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot; hello world&quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br><span class="line">&quot;hello world &quot; =&gt; &#123;&quot;hello&quot;, &quot;world&quot;&#125;</span><br></pre></td></tr></table></figure><p>遵守兼容性原则可以大大简化软件工程。当程序员理解程序时，你无需把时间纳入考量范围内，2015 年使用的<code>strings.Split</code>和今年使用的<code>strings.Split</code>是一样的。工具也是如此，比如重构工具可以随意地将<code>strings.Split</code>在不同包内移动而不用担心函数含义随着时间发生改变。</p><p>实际上，Go 1 最重要的特性就是其语言不变性。这一特性在官方文档中得到明确，<a href="golang.org/doc/go1compat">golang.org/doc/go1compat</a>：</p><blockquote><p>It is intended that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. Go programs that work today should continue to work even as future “point” releases of Go 1 arise (Go 1.1, Go 1.2, etc.).</p></blockquote><p>所有 Go 1.x 版本的程序在后续版本仍能继续编译，并且正确运行，行为保持不变。今天写了一个 Go 程序，未来它仍能正常工作。Go 官方同样也对标准库中的函数作出了承诺。</p><p>兼容性和版本有啥管理？当今最火的版本管理方法——<a href="https://semver.org/" target="_blank" rel="noopener">语义化版本</a>是鼓励不兼容的，这意味着你可以通过语义化版本号，更轻易地作出不兼容的改变。</p><p>如何理解？</p><p>语义化版本有着<code>vMAJOR.MINOR.PATCH</code>的形式。如果两个版本有着系统的主版本号，那么后一个版本应该向前兼容前一个版本。如果主版本号不同，那他俩就是不兼容的。该方法鼓励包的作者，如果你想作出不兼容的行为，那改变主版本号吧！</p><p>对于 Go 程序来说，光改变主版本号还不够，两个主版本号如果名字一模一样，阅读代码还是会造成困扰。</p><p>看起来，情况变得更加糟糕。</p><p>假设包<code>B</code>期望使用 V1 版本的<code>string.Split</code>，而<code>C</code>期望使用 V2 版本的<code>string.Split</code>。如果<code>B</code>和<code>C</code>是分别构建的，那 OK。</p><p><img src="/img/posts/version-in-go/vgo-why-4@2x.png" alt=""></p><p>但如果有一个包<code>A</code>同时导入了包<code>B</code>和<code>C</code>呢？那该如何选择<code>string.Split</code>的版本？</p><p><img src="/img/posts/version-in-go/vgo-why-5@2x.png" alt=""></p><p>针对<code>Go modules</code>的设计思想，官方意识到兼容性是最基础的原则，是必须支持、鼓励和遵循的。Go 的 FAQ 中写到：</p><blockquote><p>Packages intended for public use should try to maintain backwards compatibility as they evolve. The Go 1 compatibility guidelines are a good reference here: don’t remove exported names, encourage tagged composite literals, and so on. If different functionality is required, add a new name instead of changing an old one. If a complete break is required, create a new package with a new import path.</p></blockquote><p>大致意思是如果新旧两个包导入路径相同，那它们就应该被当作是兼容的。</p><p>这和语义化版本有什么关系呢？兼容性原则要求不同主版本号之间不需要有兼容性上的联系，所以，很自然地要求我们使用不同的导入路径。而<code>Go modules</code>中的做法是把主版本号放入导入路径，我们称之为语义化导入版本(Semantic import versioning)。</p><p><img src="/img/posts/version-in-go/impver@2x.png" alt=""></p><p>在这个例子中，<code>my/thing/v2</code>表示使用版本 2。如果是版本 1，那就是<code>my/thing</code>，没有显式在路径指定版本号，所以路径成为了主版本号的一部分，以此类推，版本 3 的导入路径为<code>my/thing/v3</code>。</p><p>如果<code>strings</code>包是我们开发者自己的模块，我们不想增加新的函数<code>Fields</code>而是重新定义<code>Split</code>，那么可以创建两个模块<code>strings</code>(主版本号 1)和<code>strings/v2</code>(主版本号 2)，这样可以同时存在两个不同的<code>Split</code>。</p><p><img src="/img/posts/version-in-go/vgo-why-6@2x.png" alt=""></p><p>依据此路径规则，<code>A</code>、<code>B</code>和<code>C</code>都能构建成功，整个程序都能正常运行。开发者和各种工具都能明白它们是不同的包，就像<code>crypto/rand</code>和<code>math/rand</code>是不同的一样显而易见。</p><p>让我们回到那个不可构建的程序。把<code>strings</code>抽象成包<code>D</code>，，这时候若不使用<em>语义化导入版本方法</em>，这样就遇到了经典的“钻石依赖问题”：<code>B</code>和<code>C</code>单独都能构建，但放在一起就不行。如果尝试构建程序<code>A</code>，那该如何选择版本<code>D</code>呢？</p><p><img src="/img/posts/version-in-go/vgo-why-7@2x.png" alt=""></p><p>语义化导入版本切断了“钻石依赖”。因为<code>D</code>的版本 2.0 有不一样的导入路径，<code>D/v2</code>。</p><p><img src="/img/posts/version-in-go/vgo-why-8@2x.png" alt=""></p><h3 id="原则-2：可重复性"><a href="#原则-2：可重复性" class="headerlink" title="原则 #2：可重复性"></a>原则 #2：可重复性</h3><p>第二原则是程序构建必须具有可重复性，一个指定版本包的构建结果不应随时间改变。在该原则下，今天我编译代码的结果和其他程序员明年编译的结果是匹配的。<strong>大部分包管理系统并不保证一点</strong>。</p><p>在第一小节我们也看到了，基于<code>GOPATH</code>的<code>go get</code>用的不是最新就是最旧的<code>D</code>。你可能认为，“<code>go get</code>当然会犯错误：它对版本一无所知”。但其实其他一些包管理工具也会犯同样的错误，这里以<code>Dep</code>为例。（<code>Cargo</code>和<code>Bundler</code>也类似）</p><p><code>Dep</code>要求每一个包包含一个<code>manifest</code>来存放元数据，记录下对所有依赖的要求。当<code>Dep</code>下载了<code>C</code>，它读入<code>C</code>的元数据，知道了<code>C</code>需要<code>D 1.4</code>之后的版本。然后<code>Dep</code>下载了最新版本的<code>D</code>来满足这一限制。</p><p>假设在昨天，<code>D</code>最新版本是 1.5：</p><p><img src="/img/posts/version-in-go/vgo-why-9@2x.png" alt=""></p><p>而今天，<code>D</code>更新为了 1.6：</p><p><img src="/img/posts/version-in-go/vgo-why-10@2x.png" alt=""></p><p>可以看出，该决策方法是不可重复的，会随时间发生改变。</p><p>当然，<code>Dep</code>的开发者意识到了这一点，它们引入了第二个元数据文件——lock 文件。如果<code>C</code>本身是一个完整的程序，当 Go 调用<code>package main</code>的时候，lock 文件会记录下<code>C</code>使用依赖的确切版本，而当需要重复构建时，lock 文件内所记录的依赖具有更高的优先级。也就是说，lock 文件同样能保证重复性原则。</p><p>但 lock 文件只是针对整体程序而言——<code>package main</code>。如果<code>C</code>被别的更大程序所使用，lock 文件就无效了，库<code>C</code>的构建仍会随着时间的改变而改变。</p><p>而<code>Go modules</code>的算法非常简单，那就是“最小版本选择算法”——每一个包指定其依赖的最低版本号。比如假设<code>B 1.3</code>要求最低<code>D 1.3</code>，<code>C 1.8</code>要求最低<code>D 1.4</code>。<code>Go modules</code>不会选择最新的版本，而是选择最小能满足要求的版本，这样，构建的结果是可重复的。</p><p><img src="/img/posts/version-in-go/vgo-why-12@2x.png" alt=""></p><p>如果构建的不同部分有不同最低版本要求，<code>go</code>命令会使用最近的那个版本。如图所示，<code>A</code>构建时发现同时有<code>D 1.3</code>和<code>D 1.4</code>的依赖，由于 1.4 大于 1.3，所以构建时会选择<code>D 1.4</code>。<code>D 1.5</code>或者<code>D 1.6</code>存在与否并不会影响该决策。</p><p>在没有 lock 文件的情况下，该算法依然保证了程序和库的可重复性构建。</p><h3 id="原则-3：可合作性"><a href="#原则-3：可合作性" class="headerlink" title="原则 #3：可合作性"></a>原则 #3：可合作性</h3><p>第三原则是可合作性。为了维护 Go 包的生态，我们追求的是一个统一的连贯的系统。相反，我们想避免的是生态分裂，变成一组一组互相之间不可合作的包。</p><p>若开发者们不合作，无论我们使用的工具有多么精巧，技巧多么高超，整个 Go 开源生态一定会走向分裂。这里隐含的意思是，为了修复不兼容性，必须要合作，我们不应排斥合作。</p><p>还是拿库<code>C 1.8</code>举例子，它要求最低版本<code>D 1.4</code>。由于可重复性原则，<code>C 1.8</code>构建会使用<code>D 1.4</code>。如果<code>C 1.8</code>是被其他更大的程序所依赖，且该程序要求<code>D 1.5</code>，那根据最小版本选择算法，会选择<code>D 1.5</code>。这时候构建仍是正确的。</p><p>现在问题来了，<code>D</code> 的作者发布了 1.6 版本，但该版本有问题，<code>C 1.8</code>无法与该版本构建。</p><p><img src="/img/posts/version-in-go/vgo-why-13@2x.png" alt=""></p><p>解决的方法是<code>C</code>和<code>D</code>的作者合作来发布 fix。解决方法多种多样。</p><p><code>C</code> 可以推出 1.9 版本，规避掉<code>D 1.6</code>中的 bug。</p><p><img src="/img/posts/version-in-go/vgo-why-15@2x.png" alt=""></p><p><code>D</code> 也可以推出 1.7 版本，修复其存在的 bug。同时，根据兼容性原则，<code>C 1.9</code>可以指定其要求最低<code>D 1.7</code>。</p><p><img src="/img/posts/version-in-go/vgo-why-14@2x.png" alt=""></p><p>再来复盘一下刚才的故事，最新版本的<code>C</code>和<code>D</code>突然不能一起工作了，这打破了 Go 包的生态，两库的作者必须合作来修复 bug。这种合作对生态是良性的。而正由于<code>Go modules</code>采用的包选择算法/可重复性，那些没有显式指定<code>D 1.6</code>的库都不会被影响。这给了<code>C</code>和<code>D</code>的作者充分的时间来给出最终解决方案。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上是 Go 版本管理的三原则，也是<code>Go modules</code>区别于<code>Dep</code>，<code>Bundler</code>和<code>Cargo</code>的根本原因。</p><ul><li>兼容性，程序中所使用的名字不随时间改变。</li><li>可重复性，指定版本的包构建结果不随时间改变。</li><li>可合作性，为了维护 Go 包的生态，互相必须易于合作。</li></ul><p>三原则来自于对年复一年软件工程的思考，它们互相巩固，是一个良性的循环：兼容性原则使用的版本选择算法带来了可重复性。而可重复性保证除非开发者显式指定，否则构建不会使用最新的、或是有问题的库，这给了我们时间来修复问题。而这种合作性又能保证兼容性。</p><p><code>Go 1.13</code>中，<code>Go modules</code>已经可用于生成环境，很多公司，包括 Google 已经接纳了它。<code>Go 1.14</code>和<code>Go 1.15</code>会带来更多方便开发者的特性，它的最终目标是彻底移除<code>GOPATH</code>。</p><p>具体<code>Go modules</code>的使用方法，可以参考这个系列博客<a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">Using Go Modules</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文翻译+删选+理解自 &lt;a href=&quot;https://research.swtch.com/vgo-principles&quot; target
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go" scheme="http://www.lyyyuna.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 中的函数稳定性</title>
    <link href="http://www.lyyyuna.com/2018/07/06/postgres-function-volatile/"/>
    <id>http://www.lyyyuna.com/2018/07/06/postgres-function-volatile/</id>
    <published>2018-07-06T08:36:38.000Z</published>
    <updated>2018-07-06T06:43:12.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>PostgreSQL 中函数有三个稳定性状态可选：</p><ol><li>immutable，函数不可以修改数据库的数据,并且在任何情况下调用，只要输入参数一致，返回结果都一致。</li><li>stable，函数不可以修改数据库的数据，同一个QUERY中，如果需要返回该函数的结果，那么将合并多次运算为一次这个函数。</li><li>volatile，函数可以修改数据库的数据，输入同样的参数可以返回不同的结果，同一个QUERY中，如果需要返回该函数的结果，那么每一行都会运算一遍这个函数。</li></ol><p>函数的稳定性会影响执行计划。在索引比较的时候，被比较的值只会运算一次，所以 volatile 不能被执行计划选择作为索引的比较条件。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="查看函数的稳定性"><a href="#查看函数的稳定性" class="headerlink" title="查看函数的稳定性"></a>查看函数的稳定性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ddei=# select proname, provolatile from pg_proc where proname in (&apos;now&apos;, &apos;clock_timestamp&apos;);</span><br><span class="line">     proname     | provolatile </span><br><span class="line">-----------------+-------------</span><br><span class="line"> now             | s</span><br><span class="line"> clock_timestamp | v</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><p>其中 clock_timestamp 是 voatile, now 是 stable。</p><h3 id="测试插入语句"><a href="#测试插入语句" class="headerlink" title="测试插入语句"></a>测试插入语句</h3><p>创建一个测试表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ddei=# create table test(id int, time1 timestamp, time2 timestamp);</span><br><span class="line">CREATE TABLE</span><br><span class="line">ddei=# insert into test select generate_series(1,1000),clock_timestamp(), now();</span><br><span class="line">INSERT 0 1000</span><br></pre></td></tr></table></figure><p>插入语句，对于 stable 函数 <code>now()</code> 应该只执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ddei=# select count(*),count(distinct time1),count(distinct time2) from test;</span><br><span class="line"> count | count | count </span><br><span class="line">-------+-------+-------</span><br><span class="line">  1000 |  1000 |     1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><h3 id="测试对索引的影响"><a href="#测试对索引的影响" class="headerlink" title="测试对索引的影响"></a>测试对索引的影响</h3><p>在测试表上创建索引，并查看执行计划：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ddei=# create index test_idx on test(time1);</span><br><span class="line">CREATE INDEX</span><br><span class="line">ddei=# </span><br><span class="line">ddei=# explain select * from test where time1&gt;now();</span><br><span class="line">                              QUERY PLAN                              </span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> Index Scan using test_idx on test  (cost=0.00..4.27 rows=1 width=20)</span><br><span class="line">   Index Cond: (time1 &gt; now())</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">ddei=# explain select * from test where time1&gt;clock_timestamp();</span><br><span class="line">                       QUERY PLAN                       </span><br><span class="line">--------------------------------------------------------</span><br><span class="line"> Seq Scan on test  (cost=0.00..22.00 rows=333 width=20)</span><br><span class="line">   Filter: (time1 &gt; clock_timestamp())</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><p>对于 volatile 的函数 clock_timestamp 在 where 条件中，不走索引。而 stable 函数 now 在 where 条件中，会走索引。</p><h2 id="修改函数稳定性"><a href="#修改函数稳定性" class="headerlink" title="修改函数稳定性"></a>修改函数稳定性</h2><p>使用以下语句可修改函数稳定性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ddei=# alter function clock_timestamp() strict stable;</span><br><span class="line">ALTER FUNCTION</span><br></pre></td></tr></table></figure><p>再次测试 clock_timestamp 的索引情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ddei=# explain select * from test where time1&gt;clock_timestamp();</span><br><span class="line">                              QUERY PLAN                              </span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> Index Scan using test_idx on test  (cost=0.00..4.27 rows=1 width=20)</span><br><span class="line">   Index Cond: (time1 &gt; clock_timestamp())</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></p><p>这次 clock_timestamp 在 where 条件中走了索引。</p><p>不过不要随意修改系统自带函数的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;PostgreSQL 中函数有三个稳定性状态可选：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;immutable，函数不可以修改数据库的数据,并且在任何情况
      
    
    </summary>
    
      <category term="数据库" scheme="http://www.lyyyuna.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="PostgreSQL" scheme="http://www.lyyyuna.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>atop 简单使用</title>
    <link href="http://www.lyyyuna.com/2018/07/04/perftest-atop/"/>
    <id>http://www.lyyyuna.com/2018/07/04/perftest-atop/</id>
    <published>2018-07-04T08:36:38.000Z</published>
    <updated>2018-07-04T09:40:31.710Z</updated>
    
    <content type="html"><![CDATA[<p>atop 是一个系统性能监控工具，可以在系统级别监控 CPU、内存、硬盘和网络的使用情况。</p><p>atop 不仅可以以交互式的方式运行，还可以一一定的频率，将性能数据写入日志中。所以当服务器出现问题之后，便可分析 atop 日志文件来判断是否有进程异常退出、内存和 CPU 方面的异常。</p><h2 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h2><h4 id="PRC-Process-level-totals"><a href="#PRC-Process-level-totals" class="headerlink" title="PRC - Process level totals"></a>PRC - Process level totals</h4><ol><li>sys, 内核态下运行时间</li><li>user, 用户态下运行时间</li><li>#proc, 当前所有的进程数量</li><li>#trun, 处于 running 状态下线程数量</li><li>#zombie，僵尸进程的数量</li><li>#exit，采样周期内退出的进程数量</li></ol><h4 id="CPU-CPU-utilization"><a href="#CPU-CPU-utilization" class="headerlink" title="CPU - CPU utilization"></a>CPU - CPU utilization</h4><p>展示所有 CPU 的使用情况。在多处理器的系统中，会展示每一个独立内核的使用情况。</p><ol><li>sys、usr, CPU 被用于处理进程时，进程在内核态、用户态所占CPU的时间比例</li><li>irq, CPU 被用于处理中断的时间比例</li><li>idle, CPU 处在完全空闲状态的时间比例</li><li>wait, CPU 处在“进程等待磁盘IO 导致 CPU 空闲”状态的时间比例</li></ol><h4 id="CPL-CPU-load-information"><a href="#CPL-CPU-load-information" class="headerlink" title="CPL - CPU load information"></a>CPL - CPU load information</h4><p>展示 CPU 的负载情况。</p><ol><li>avg1、avg5和avg15：过去1分钟、5分钟和15分钟内运行队列中的平均进程数量</li><li>csw，指示上下文交换次数</li><li>intr，指示中断发生次数</li></ol><h4 id="MEM-Memory-occupation"><a href="#MEM-Memory-occupation" class="headerlink" title="MEM - Memory occupation"></a>MEM - Memory occupation</h4><ol><li>tot，物理内存总量</li><li>free，空闲内存大小</li><li>cache，页缓存的内存大小</li><li>buff，文件系统缓存的内存大小</li><li>slab，系统内核分配的内存大小</li><li>dirty，页缓存中脏内存的大小</li></ol><h4 id="SWP-Swap-occupation-and-overcommit-info"><a href="#SWP-Swap-occupation-and-overcommit-info" class="headerlink" title="SWP - Swap occupation and overcommit info"></a>SWP - Swap occupation and overcommit info</h4><ol><li>tot，交换区总量</li><li>free，示空闲交换空间大小</li></ol><h4 id="PAG-Paging-frequency"><a href="#PAG-Paging-frequency" class="headerlink" title="PAG - Paging frequency"></a>PAG - Paging frequency</h4><ol><li>swin，换入的页内存数目</li><li>swout， 换出的页内存数目</li></ol><h4 id="DSK-LVM-Disk-utilization-Logical-volumn"><a href="#DSK-LVM-Disk-utilization-Logical-volumn" class="headerlink" title="DSK/LVM - Disk utilization/Logical volumn"></a>DSK/LVM - Disk utilization/Logical volumn</h4><ol><li>busy，磁盘忙时比例</li><li>read，读请求数量</li><li>write，写请求数量</li><li>KiB/r，每次读的千字节数</li><li>Kib/w，每次写的千字节数</li><li>MBr/s，每秒读入兆字节带宽</li><li>MBw/s，每秒写入兆字节带宽</li><li>avio，每次传输所需要的毫秒</li></ol><h4 id="NET-Network-utilization-TCP-IP"><a href="#NET-Network-utilization-TCP-IP" class="headerlink" title="NET - Network utilization (TCP/IP)"></a>NET - Network utilization (TCP/IP)</h4><p>第一行是传输层信息，第二行是 IP 层信息，后面几行是各网卡的信息。</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol><li>g, 通用输出</li><li>m, 展示与内存有关的输出</li><li>d, 展示与硬盘使用有关的输出</li><li>c, 展示每个进程是由哪个命令行启动的</li><li>p, 展示进程相关的活动信息</li><li>C, 按照 CPU 使用排序</li><li>M, 按照内存使用排序</li><li>P, 按下后，即可输入正则表达式来搜索对应进程</li><li>t, 向前一个采样间隔，在分析 atop 日志时使用</li><li>T, 向后一个采样间隔，在分析 atop 日志时使用</li><li>v, 输出更详细的进程信息，包括进程的启动时间，进程号，用户和所在组，当前状态。</li></ol><h2 id="atop日志"><a href="#atop日志" class="headerlink" title="atop日志"></a>atop日志</h2><p>每个时间点采样页面组合起来就形成了一个atop日志文件，我们可以使用”atop -r XXX”命令对日志文件进行查看。</p><p>通常日志文件位于 <code>/var/log/</code>，采样间隔为 10min。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;atop 是一个系统性能监控工具，可以在系统级别监控 CPU、内存、硬盘和网络的使用情况。&lt;/p&gt;
&lt;p&gt;atop 不仅可以以交互式的方式运行，还可以一一定的频率，将性能数据写入日志中。所以当服务器出现问题之后，便可分析 atop 日志文件来判断是否有进程异常退出、内存和 
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Python 实现一个 ORM</title>
    <link href="http://www.lyyyuna.com/2018/04/28/python-orm1/"/>
    <id>http://www.lyyyuna.com/2018/04/28/python-orm1/</id>
    <published>2018-04-28T03:33:31.000Z</published>
    <updated>2018-04-28T03:12:50.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文实现一个非常简单的 ORM 初稿：</p><ol><li>完成 Python 类（模型）与数据库表的映射</li><li>完成类实例与表每行记录的映射</li><li>完成实例操作与增删改查的 SQL 语句的映射</li></ol><p>这个初稿不涉及数据库的真正操作，只是在 <code>user.save()</code> 的时候打印类似 <code>insert into user ...</code> 的 SQL 语句。本文所有代码基于 Python2。</p><h2 id="ORM-为什么需要元类"><a href="#ORM-为什么需要元类" class="headerlink" title="ORM 为什么需要元类"></a>ORM 为什么需要元类</h2><p>假设有如下的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line">    student_id = IntegerField(<span class="string">'studentid'</span>, primaryKey=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>回想 Django 的 ORM，每个模型都继承了一个 <code>Model</code> 类，我们也如法炮制。而所谓类与表的映射，就是在 Python 虚拟机启动后，自动寻找类属性，并将 <code>__table__</code> 转化为表名， <code>student_id</code> 转化为列名。这种需求类似于运行时自省，而普通类的 <code>__new__</code> <code>__init__</code> 都是实例化类时被调用，在这两个方法上做文章没有用处。</p><p>这时候就该用元类 <code>metaclass</code> 了。</p><p>在 <a href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/">Python2.7 源码 - 整数对象</a> 中已经有过介绍，元类 <code>metaclass</code> 是类的类。除了整数这种内置类型，用户自定义类型也有元类的概念。</p><ul><li>内置类定义在 C 源码中，故虚拟机运行后，就立即存在。</li><li>而用 <code>class</code> 语法定义的类，则需要根据元类 <code>metaclass</code> 来创建。</li><li>内置类也有元类，最终两者在虚拟机中拥有相同的结构。</li></ul><p>元类 <code>metaclass</code> 实例化的结果就是我们的普通类，由虚拟机启动时自动执行。在元类实例化的过程中，便可以扫描类定义属性，实现类与表的映射。自定义类默认继承自 <code>object</code>，获得的元类为 <code>type</code>。</p><p>Python2.x 中，用以下语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = Meta</span><br></pre></td></tr></table></figure><p>可以将类 <code>C</code> 对应的元类替换为 <code>Meta</code>。这么一看，只要设计自己的元类，并在模型中添加进去就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = Meta</span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line">    student_id = IntegerField(<span class="string">'studentid'</span>, primaryKey=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>但这么做，会在产品业务代码中暴露太多复杂的概念。我们可以设计一个公共的父类，并修改此父类的元类，这样所有继承的子类都能获得新的元类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelType</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = ModelType</span><br><span class="line"></span><br><span class="line"><span class="comment"># Application</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'Teacher_table'</span></span><br></pre></td></tr></table></figure><p>现在当 <code>User</code> <code>Teacher</code> 类在虚拟机中创建时，其行为就由 <code>ModelType</code> 控制。</p><p><code>ModelType</code> 需实现 <code>__new__</code> 函数，接受 <code>name, bases, attrs</code> 三个参数，<code>attrs</code> 是类属性构成的字典。该 <code>__new__</code> 函数最终需返回 <code>type.__new__(cls, name, bases, attrs)</code> 的结果，即类在虚拟机中的表示。</p><p>其中，<code>attrs</code> 字典由 Python 虚拟机创建类时填入。</p><h2 id="扫描表名"><a href="#扫描表名" class="headerlink" title="扫描表名"></a>扫描表名</h2><p>由上可知，可在元类的 <code>__new__</code> 函数中获取 <code>__table__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelType</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        tablename = attrs.get(<span class="string">'__table__'</span>, <span class="keyword">None</span>) <span class="keyword">or</span> name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Get table name'</span>, tablename</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = ModelType</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get table name Model</span><br><span class="line">Get table name User_table</span><br></pre></td></tr></table></figure><p>为什么会输出两行？因为父类 <code>Model</code> 也会被元类 <code>ModelType</code> 扫描，所以应将父类自身排除出扫描：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name==<span class="string">'Model'</span>:</span><br><span class="line">            <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line">        tablename = attrs.get(<span class="string">'__table__'</span>, <span class="keyword">None</span>) <span class="keyword">or</span> name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Get table name'</span>, tablename</span><br></pre></td></tr></table></figure><p>这次输出没有 <code>Model</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get table name User_table</span><br></pre></td></tr></table></figure><h2 id="扫描字段"><a href="#扫描字段" class="headerlink" title="扫描字段"></a>扫描字段</h2><p>字段的扫描是类似的，我们先完成字段类型的定义，让所有字段继承自 <code>Field</code> 类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, sqlType, primaryKey, default)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sqlType = sqlType</span><br><span class="line">        self.primaryKey = primaryKey</span><br><span class="line">        self.default = default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s, %s:%s&gt;'</span> % (self.__class__, self.sqlType, self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, sqlType=<span class="string">'character varying(100)'</span>, primaryKey=False, default=<span class="string">''</span>)</span>:</span></span><br><span class="line">        super(StringField, self).__init__(name, sqlType, primaryKey, default)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerField</span><span class="params">(Field)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None, sqlType=<span class="string">'integer'</span>, primaryKey=False, default=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super(IntegerField, self).__init__(name, sqlType, primaryKey, default)</span><br></pre></td></tr></table></figure><p>由于所有表字段类有一个相同的父类，所以可以通过 <code>isinstance(v, Field)</code> 识别一个类属性是否属于表字段。以下代码在类属性 <code>attrs</code> 中遍历，找出字段并存储在 <code>mappings</code> 字典和 <code>fields</code> 列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mappings = &#123;&#125;</span><br><span class="line">fields = []</span><br><span class="line">primary = <span class="keyword">None</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.iteritems():</span><br><span class="line">    <span class="keyword">if</span> isinstance(v, Field):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Found one field'</span>, k</span><br><span class="line">        mappings[k] = v</span><br><span class="line">        <span class="keyword">if</span> v.primaryKey == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> primary == <span class="keyword">None</span>:</span><br><span class="line">                primary = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">"Duplicate primary key: %s"</span>, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fields.append(k)</span><br><span class="line"><span class="keyword">if</span> primary == <span class="keyword">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">"No primary key given."</span>)</span><br></pre></td></tr></table></figure><p>将上述代码应用于 <code>User</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Model)</span>:</span></span><br><span class="line">    __table__ = <span class="string">'User_table'</span></span><br><span class="line">    student_id = IntegerField(<span class="string">'studentid'</span>, primaryKey=<span class="keyword">True</span>)</span><br><span class="line">    name = StringField(<span class="string">'username'</span>)</span><br><span class="line">    age = IntegerField(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get table name User_table</span><br><span class="line">Found one field age</span><br><span class="line">Found one field name</span><br><span class="line">Found one field student_id</span><br></pre></td></tr></table></figure><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>在类中需要移除所有的字段属性 <code>attrs.pop(k)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</span><br><span class="line">    attrs.pop(k)</span><br></pre></td></tr></table></figure><p>因为业务代码不需要类属性，每个实例需要访问的是实例属性。比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2 = User(student_id=<span class="number">3</span>, name=<span class="string">'blue'</span>, age=<span class="number">123</span>)</span><br><span class="line">print(u2.name)</span><br></pre></td></tr></table></figure><p>这里，让父类 <code>Model</code> 继承 <code>dict</code> 类，并添加 <code>__getattr__</code> 和 <code>__setattr__</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict)</span>:</span></span><br><span class="line">    __metaclass__ = ModelMeta</span><br><span class="line">    __table__ = <span class="string">'Should not show'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        super(Model, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Dict' object has no attribute '%s'"</span> % key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[key] = value</span><br></pre></td></tr></table></figure><p>访问 <code>u2.name</code> 便等价于 <code>u2[name]</code>，而 <code>User</code> 间接继承自字典，<code>User(student_id=3, name=&#39;blue&#39;, age=123)</code>初始化后，便能访问字典元素<code>u2[name]</code>。</p><h2 id="与-SQL-语句的映射"><a href="#与-SQL-语句的映射" class="headerlink" title="与 SQL 语句的映射"></a>与 SQL 语句的映射</h2><p>我们可以在元类 <code>ModelMeta</code> 中预先定义一些 SQL 语句的模板，并存储在类属性 <code>attrs</code> 中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">attrs[<span class="string">'__select__'</span>] = <span class="string">"select '%s', %s from '%s'"</span> % (primary, <span class="string">','</span>.join(escaped_fields), tablename)</span><br><span class="line">attrs[<span class="string">'__insert__'</span>] = <span class="string">"insert into '%s' (%s, '%s') values (%s)"</span> % (tablename, <span class="string">','</span>.join(escaped_fields), primary, create_args_string(len(escaped_fields)+<span class="number">1</span>))</span><br><span class="line">attrs[<span class="string">'__update__'</span>] = <span class="string">"update '%s' set %s where '%s' =?"</span> % (tablename, <span class="string">','</span>.join(map(<span class="keyword">lambda</span> x: <span class="string">"'%s'=?"</span> % (mappings.get(x).name), fields)), primary)</span><br><span class="line">attrs[<span class="string">'__delete__'</span>] = <span class="string">"delete from '%s' where '%s' = ?"</span> % (tablename, primary)</span><br></pre></td></tr></table></figure><p>接着在 <code>Model</code> 中添加 <code>select</code> 和 <code>save</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(cls, id)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s where '%s' = %s;"</span> % (cls.__select__, cls.__primarykey__, id)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getValue</span><span class="params">(self, k)</span>:</span></span><br><span class="line">    value = getattr(self, k, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        field = self.__mappings__[k]</span><br><span class="line">        <span class="keyword">if</span> field.default <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            value = field.default</span><br><span class="line">            setattr(self, k, value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">    args = map(self.getValue, self.__fields__)</span><br><span class="line">    args.append(self.getValue(self.__primarykey__))</span><br><span class="line">    <span class="keyword">print</span> self.__insert__, args</span><br></pre></td></tr></table></figure><p>这两个方法对应于 SQL 中的 <code>SELECT</code> 和 <code>INSERT</code> 语句。逻辑也比较简单，从之前存储在 <code>mappings</code> 和 <code>fields</code> 的字段名，再结合实例属性，拼接出 SQL 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'Test select sql command:'</span></span><br><span class="line">User.select(id=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Test insert sql command:'</span></span><br><span class="line">u2 = User(student_id=<span class="number">3</span>, name=<span class="string">'blue'</span>, age=<span class="number">123</span>)</span><br><span class="line">u2.save()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test <span class="keyword">select</span> <span class="keyword">sql</span> command:</span><br><span class="line"><span class="keyword">select</span> <span class="string">'student_id'</span>, <span class="string">'age'</span>,<span class="string">'name'</span> <span class="keyword">from</span> <span class="string">'User_table'</span> <span class="keyword">where</span> <span class="string">'student_id'</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Test <span class="keyword">insert</span> <span class="keyword">sql</span> command:</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">'User_table'</span> (<span class="string">'age'</span>,<span class="string">'name'</span>, <span class="string">'student_id'</span>) <span class="keyword">values</span> (?, ?, ?) [<span class="number">123</span>, <span class="string">'blue'</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，一个简单的 ORM 原型就完成了。详细代码可见：<a href="https://github.com/lyyyuna/script_collection/tree/master/orm_draft" target="_blank" rel="noopener">https://github.com/lyyyuna/script_collection/tree/master/orm_draft</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文实现一个非常简单的 ORM 初稿：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成 Python 类（模型）与数据库表的映射&lt;/li&gt;
&lt;li&gt;完成类实
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>实现基于 HTTPS 代理的中间人攻击</title>
    <link href="http://www.lyyyuna.com/2018/03/16/http-proxy-https/"/>
    <id>http://www.lyyyuna.com/2018/03/16/http-proxy-https/</id>
    <published>2018-03-16T11:44:50.000Z</published>
    <updated>2018-03-17T04:11:14.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在给产品做 Web 安全测试时，经常会使用代理工具来收集 URL 及相关请求参数。</p><p>在我之前的文章介绍了 <a href="http://www.lyyyuna.com/2016/01/16/http-proxy-get1/">使用 Python 实现一个简单的 HTTP 代理</a>。但这留下一个问题，如何处理 HTTPS 流量？</p><h2 id="HTTP-隧道代理原理"><a href="#HTTP-隧道代理原理" class="headerlink" title="HTTP 隧道代理原理"></a>HTTP 隧道代理原理</h2><p>RFC 为这类代理给出了规范，<a href="https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01" target="_blank" rel="noopener">Tunneling TCP based protocols through Web proxy servers</a>。简单来讲就是通过 Web 代理服务器用隧道方式传输基于 TCP 的协议。HTTP 协议正文部分为客户端发送的原始 TCP 流量，代理发送给远端服务器后，将接收到的 TCP 流量原封不动返回给浏览器。</p><p>下面这张图片来自于《HTTP 权威指南》，展示了 HTTP 隧道代理的原理。<br><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/connect.png" alt="HTTP 隧道"></p><p>浏览器首先发起 CONNECT 请求：</p><pre><code>CONNECT example.com:443 HTTP/1.1</code></pre><p>代理收到这样的请求后，依据 host 地址与服务器建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：</p><pre><code>HTTP/1.1 200 Connection Established</code></pre><p>该报文不需要正文。浏览器一旦收到这个响应报文，就可认为与服务器的 TCP 连接已打通，后续可直接透传。</p><h2 id="HTTPS-流量中间人攻击"><a href="#HTTPS-流量中间人攻击" class="headerlink" title="HTTPS 流量中间人攻击"></a>HTTPS 流量中间人攻击</h2><p>我们很容易想到，HTTPS 代理本质上就是隧道透传，代理服务器只是透传 TCP 流量，与 GET/POST 代理有本质区别。隧道透传是安全的，代理没有私钥来解密 TLS 流量。</p><p>这带来一个问题，现在 HTTPS 越来越普遍，测试时不会特意关掉 TLS，做安全测试也就拿不到 URL 及请求参数。那怎么做呢？</p><p>首先是来看正常的隧道代理示意图：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/tls1.png" alt="TLS 示意图 1"></p><p>在如图红色的透传流量中，插入我们的<strong>中间人</strong>：</p><ol><li>用一个 TLS 服务器伪装成远端的真正的服务器，接下浏览器的 TLS 流量，解析成明文。</li><li>用明文作为原始数据，模拟 TLS 客户端向远端服务器转发。</li></ol><p>示意图如下：</p><p><img src="https://raw.githubusercontent.com/lyyyuna/blog_img/master/blog/201803/tls2.png" alt="TLS 示意图 2"></p><p>由于中间人拿到了明文，也就能够继续收集 URL 及相关请求参数。</p><h3 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h3><p>大家知道，HTTP 是需要证书的。浏览器会验证服务器发来的证书是否合法。证书若是由合法的 CA 签发，则称为合法的证书。现代浏览器在安装时都会附带全世界所有合法的 CA 证书。由 CA 证书可验证远端服务器的证书是否是合法 CA 签发的。</p><p>在 TLS 示意图 2 中，浏览器会验证假 TLS 服务器的证书：</p><ol><li>第一验证是否是合法 CA 签发。</li><li>第二验证该证书 CN 属性是否是所请求的域名。即若浏览器打开 <code>www.example.com</code>，则返回的证书 CN 属性必须是 <code>www.example.com</code>。</li></ol><p>对于第一点，合法 CA 是不可能为我们签证书的，否则就是重大安全事件了。我们只能自制 CA，并将自制 CA 导入浏览器信任链。</p><p>对于第二点，需要自制 CA 实时为域名 <code>www.example.com</code> 签一个假的证书。</p><h2 id="Go-实现"><a href="#Go-实现" class="headerlink" title="Go 实现"></a>Go 实现</h2><p>不同于之前 <a href="http://www.lyyyuna.com/2016/01/16/http-proxy-get1/">Python 实现的 HTTP 代理</a>，这次的 HTTPS 中间人代理用 Go 实现。源码见 <a href="https://github.com/lyyyuna/mitm" target="_blank" rel="noopener">https://github.com/lyyyuna/mitm</a></p><p>首先是启动一个 http server。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mitmproxy.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gomitmproxy</span><span class="params">(conf *config.Cfg, ch <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">tlsConfig := config.NewTLSConfig(<span class="string">"gomitmproxy-ca-pk.pem"</span>, <span class="string">"gomitmproxy-ca-cert.pem"</span>, <span class="string">""</span>, <span class="string">""</span>)</span><br><span class="line">handler := InitConfig(conf, tlsConfig)</span><br><span class="line">server := &amp;http.Server&#123;</span><br><span class="line">Addr:         <span class="string">":"</span> + *conf.Port,</span><br><span class="line">ReadTimeout:  <span class="number">1</span> * time.Hour,</span><br><span class="line">WriteTimeout: <span class="number">1</span> * time.Hour,</span><br><span class="line">Handler:      handler,</span><br><span class="line">    &#125;</span><br><span class="line">............</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handler</code> 是一个实现了 <code>ServeHTTP</code> 接口的 <code>Handler</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *HandlerWrapper)</span> <span class="title">ServeHTTP</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> req.Method == <span class="string">"CONNECT"</span> &#123;</span><br><span class="line">handler.https = <span class="literal">true</span></span><br><span class="line">handler.InterceptHTTPS(resp, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler.https = <span class="literal">false</span></span><br><span class="line">handler.DumpHTTPAndHTTPS(resp, req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据请求不同分为两大类。普通 GET/POST 请求，由于是明文，可直接进行抓包。而 CONNECT 请求，则走 <code>InterceptHTTPS</code>。我们默认走 CONNECT 隧道的都是 HTTPS 流量，其他 TCP 应用层协议则不予考虑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *HandlerWrapper)</span> <span class="title">InterceptHTTPS</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">addr := req.Host</span><br><span class="line">host := strings.Split(addr, <span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 1, 为每个域名签发证书</span></span><br><span class="line">cert, err := handler.FakeCertForName(host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatalln(<span class="string">"Could not get mitm cert for name: %s\nerror: %s"</span>, host, err)</span><br><span class="line">respBadGateway(resp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step 2，拿到原始 TCP 连接</span></span><br><span class="line">connIn, _, err := resp.(http.Hijacker).Hijack()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Fatalln(<span class="string">"Unable to access underlying connection from client: %s"</span>, err)</span><br><span class="line">respBadGateway(resp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tlsConfig := copyTlsConfig(handler.tlsConfig.ServerTLSConfig)</span><br><span class="line">    tlsConfig.Certificates = []tls.Certificate&#123;*cert&#125;</span><br><span class="line">    <span class="comment">// step 3，将 TCP 连接转化为 TLS 连接</span></span><br><span class="line">tlsConnIn := tls.Server(connIn, tlsConfig)</span><br><span class="line">listener := &amp;mitmListener&#123;tlsConnIn&#125;</span><br><span class="line">httpshandler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(resp2 http.ResponseWriter, req2 *http.Request)</span></span> &#123;</span><br><span class="line">req2.URL.Scheme = <span class="string">"https"</span></span><br><span class="line">req2.URL.Host = req2.Host</span><br><span class="line">handler.DumpHTTPAndHTTPS(resp2, req2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// step 4，启动一个伪装的 TLS 服务器</span></span><br><span class="line">err = http.Serve(listener, httpshandler)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">logger.Printf(<span class="string">"Error serving mitm'ed connection: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">connIn.Write([]<span class="keyword">byte</span>(<span class="string">"HTTP/1.1 200 Connection Established\r\n\r\n"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一步通过 <code>FakeCertForName</code> 为浏览器请求的域名签发证书。签发所使用的 CA 为 <code>gomitmproxy-ca-pk.pem</code>, <code>gomitmproxy-ca-cert.pem</code>。</li><li>第二步通过 <code>http.Hijacker</code> 拿到原始的 TCP 连接。</li><li>第三步通过 <code>tlsConnIn := tls.Server(connIn, tlsConfig)</code>，将 TCP 连接转换为 TLS 连接。该 TLS 连接已配置有 CA 签发的证书。所谓的 TLS 连接，即 Go 应用程序可直接在该连接上拿到原始明文。</li><li>第四步通过 <code>http.Serve(listener, httpshandler)</code> 响应这个 TLS 连接。响应的回调函数所看到的都是明文，即可进行 HTTP 抓包。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上述过程即为 Burp Suite, ZAP 和 fiddler 等进行 HTTPS 抓包的原理。</p><p>我自制 HTTPS 中间人代理，主要是想结合 Sqlmap 做一个自动化 SQL 注入系统。由于目前所在 QA 团队并不具备 SQL 注入测试的经验，最大化的自动化所有过程就成了我的目标。目前还有 csrf token 未解决，主要是 csrf 实现千差万别，没有通用解决方法。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在给产品做 Web 安全测试时，经常会使用代理工具来收集 URL 及相关请求参数。&lt;/p&gt;
&lt;p&gt;在我之前的文章介绍了 &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="网络" scheme="http://www.lyyyuna.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http proxy" scheme="http://www.lyyyuna.com/tags/http-proxy/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 简单对象创建的字节码分析</title>
    <link href="http://www.lyyyuna.com/2018/01/13/python-internal6-simple-object-create/"/>
    <id>http://www.lyyyuna.com/2018/01/13/python-internal6-simple-object-create/</id>
    <published>2018-01-13T08:20:02.000Z</published>
    <updated>2018-01-13T14:19:05.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 源码编译后，有常量表，符号表。一个作用域运行时会对应一个运行时栈。</p><p>大部分字节码就是基于常量表、符号表和运行时栈，运算后得到所需结果。</p><p>本篇就来分析简单对象创建的字节码。以下面这段代码为分析样本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">s = <span class="string">'python'</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line">l = []</span><br></pre></td></tr></table></figure><p>对生成的 pyc 文件解析，可得如下的结构，其中包括字节码反编译的结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">magic 03f30d0a</span><br><span class="line">moddate 836a595a (Sat Jan 13 10:10:11 2018)</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">argcount</span>&gt;</span> 0 <span class="tag">&lt;/<span class="name">argcount</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">nlocals</span>&gt;</span> 0<span class="tag">&lt;/<span class="name">nlocals</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">stacksize</span>&gt;</span> 1<span class="tag">&lt;/<span class="name">stacksize</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">flags</span>&gt;</span> 0040<span class="tag">&lt;/<span class="name">flags</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">codeobject</span>&gt;</span> 6400005a00006401005a01006900005a02006700005a030064020053<span class="tag">&lt;/<span class="name">codeobject</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dis</span>&gt;</span></span><br><span class="line">  1           0 LOAD_CONST               0 (1)</span><br><span class="line">              3 STORE_NAME               0 (i)</span><br><span class="line"></span><br><span class="line">  2           6 LOAD_CONST               1 ('python')</span><br><span class="line">              9 STORE_NAME               1 (s)</span><br><span class="line"></span><br><span class="line">  3          12 BUILD_MAP                0</span><br><span class="line">             15 STORE_NAME               2 (d)</span><br><span class="line"></span><br><span class="line">  4          18 BUILD_LIST               0</span><br><span class="line">             21 STORE_NAME               3 (l)</span><br><span class="line">             24 LOAD_CONST               2 (None)</span><br><span class="line">             27 RETURN_VALUE</span><br><span class="line">   <span class="tag">&lt;/<span class="name">dis</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">names</span>&gt;</span> ('i', 's', 'd', 'l')<span class="tag">&lt;/<span class="name">names</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">varnames</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">varnames</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">freevars</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">freevars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cellvars</span>&gt;</span> ()<span class="tag">&lt;/<span class="name">cellvars</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filename</span>&gt;</span> '.\\test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span> '<span class="tag">&lt;<span class="name">module</span>&gt;</span>'<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">firstlineno</span>&gt;</span> 1<span class="tag">&lt;/<span class="name">firstlineno</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">      1</span><br><span class="line">      'python'</span><br><span class="line">      None</span><br><span class="line">   <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">lnotab</span>&gt;</span> 060106010601<span class="tag">&lt;/<span class="name">lnotab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们清楚的看到 <code>consts</code> 常量表，<code>names</code> 符号表，这些表中的元素都是有明确顺序的。</p><h2 id="整数赋值"><a href="#整数赋值" class="headerlink" title="整数赋值"></a>整数赋值</h2><p>第一条语句 <code>i = 1</code>。对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 LOAD_CONST               0 (1)</span><br><span class="line">3 STORE_NAME               0 (i)</span><br></pre></td></tr></table></figure><p><code>LOAD_CONST</code> 对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TARGET(LOAD_CONST)</span><br><span class="line">&#123;</span><br><span class="line">    x = GETITEM(consts, oparg); <span class="comment">// 从常量表 oparg 位置处取出对象</span></span><br><span class="line">    Py_INCREF(x);</span><br><span class="line">    PUSH(x); <span class="comment">// 压入堆栈</span></span><br><span class="line">    FAST_DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，这里参数为 0。表示从常量表第 0 个位置取出整数，并将该数压入运行时栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+----------+</span><br><span class="line">| stack | f_locals |</span><br><span class="line">+-------+----------+</span><br><span class="line">| 1     |          |</span><br><span class="line">|       |          |</span><br><span class="line">|       |          |</span><br><span class="line">+-------+----------+</span><br></pre></td></tr></table></figure><p>左侧为运行时栈，右侧为当前作用域内的局部变量。</p><p><code>STORE_NAME</code> 所对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TARGET(STORE_NAME)</span><br><span class="line">&#123;</span><br><span class="line">    w = GETITEM(names, oparg); <span class="comment">// 从符号表 oparg 位置处取出符号名</span></span><br><span class="line">    v = POP(); <span class="comment">// 弹出运行时栈的栈顶元素</span></span><br><span class="line">    <span class="keyword">if</span> ((x = f-&gt;f_locals) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyDict_CheckExact(x))</span><br><span class="line">            err = PyDict_SetItem(x, w, v); <span class="comment">// 将符号名作为键，栈顶元素作为值，放入字典中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = PyObject_SetItem(x, w, v);</span><br><span class="line">        Py_DECREF(v);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>) DISPATCH();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = PyObject_Repr(w);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    PyErr_Format(PyExc_SystemError,</span><br><span class="line">                    <span class="string">"no locals found when storing %s"</span>,</span><br><span class="line">                    PyString_AS_STRING(t));</span><br><span class="line">    Py_DECREF(t);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，参数为 0。表示从符号表第 0 个位置处取出符号名，即 <code>i</code>。然后弹出运行时栈的栈顶元素，并将符号名作为键，栈顶元素作为值，放入字典中 <code>f_locals</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+------------+</span><br><span class="line">| stack | f_locals   |</span><br><span class="line">+-------+------------+</span><br><span class="line">|       | i, &lt;int 1&gt; |</span><br><span class="line">|       |            |</span><br><span class="line">|       |            |</span><br><span class="line">+-------+------------+</span><br></pre></td></tr></table></figure><h2 id="字符串赋值"><a href="#字符串赋值" class="headerlink" title="字符串赋值"></a>字符串赋值</h2><p>语句 <code>s = &#39;python&#39;</code> 所对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 LOAD_CONST               1 (&apos;python&apos;)</span><br><span class="line">9 STORE_NAME               1 (s)</span><br></pre></td></tr></table></figure><p>和整数赋值的字节码完全相同，只是参数不同。这里不再做重复分析，赋值后，运行时栈变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       |                   |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="字典赋值"><a href="#字典赋值" class="headerlink" title="字典赋值"></a>字典赋值</h2><p>语句 <code>d = {}</code> 对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12 BUILD_MAP                0</span><br><span class="line">15 STORE_NAME               2 (d)</span><br></pre></td></tr></table></figure><p><code>BUILD_MAP</code> 所对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ceval.c</span></span><br><span class="line">TARGET(BUILD_MAP)</span><br><span class="line">&#123;</span><br><span class="line">    x = _PyDict_NewPresized((Py_ssize_t)oparg);</span><br><span class="line">    PUSH(x);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) DISPATCH();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dictobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyDict_NewPresized(Py_ssize_t minused)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *op = PyDict_New();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minused&gt;<span class="number">5</span> &amp;&amp; op != <span class="literal">NULL</span> &amp;&amp; dictresize((PyDictObject *)op, minused) == <span class="number">-1</span>) &#123;</span><br><span class="line">        Py_DECREF(op);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码带参，参数为 0。而深入 <code>_PyDict_NewPresized</code> 可以看到，若参数小于 5，实际上创建的是默认大小的字典。创建完毕后，会将该字典对象压入运行时栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------+</span><br><span class="line">| stack  | f_locals          |</span><br><span class="line">+--------+-------------------+</span><br><span class="line">| &lt;dict&gt; | i, &lt;int 1&gt;        |</span><br><span class="line">|        | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|        |                   |</span><br><span class="line">+--------+-------------------+</span><br></pre></td></tr></table></figure><p>最后 <code>STORE_NAME</code> 将该对象与符号 <code>d</code> 绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       | d, &lt;dict&gt;         |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="列表赋值"><a href="#列表赋值" class="headerlink" title="列表赋值"></a>列表赋值</h2><p>语句 <code>l = []</code> 对应的字节码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18 BUILD_LIST               0</span><br><span class="line">21 STORE_NAME               3 (l)</span><br></pre></td></tr></table></figure><p><code>BUILD_LIST</code> 对应的 C 语言源码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TARGET(BUILD_LIST)</span><br><span class="line">&#123;</span><br><span class="line">    x =  PyList_New(oparg); <span class="comment">// 创建空列表</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; --oparg &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            w = POP(); <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">            PyList_SET_ITEM(x, oparg, w); <span class="comment">// 将弹出的元素放入列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        PUSH(x); <span class="comment">// 将列表对象放入栈中</span></span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该字节码首先创建一个列表，列表依据参数值预先分配空间。这里不对列表做深入分析，只指出，这里的空间大小不是存放元素所占用的空间，而是 <code>PyObject *</code> 指针。</p><p>列表建完后，便会不停从运行时栈中弹出元素，然后将元素放入列表中。这里是空列表，所以 <code>BUILD_LIST</code> 运行时，栈为空，该字节码的参数也为 0。</p><p>我们换一个非空列表来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1           0 LOAD_CONST               0 (1)</span><br><span class="line">            3 LOAD_CONST               1 (2)</span><br><span class="line">            6 LOAD_CONST               2 (3)</span><br><span class="line">            9 BUILD_LIST               3</span><br><span class="line">           12 STORE_NAME               0 (l)</span><br><span class="line">           15 LOAD_CONST               3 (None)</span><br><span class="line">           18 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>BUILD_LIST</code> 之前会将三个对象压入运行时栈中。</p><p>回到本文最初的 Python 程序，4 条语句运行完后， <code>f_locals</code> 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------+-------------------+</span><br><span class="line">| stack | f_locals          |</span><br><span class="line">+-------+-------------------+</span><br><span class="line">|       | i, &lt;int 1&gt;        |</span><br><span class="line">|       | s, &lt;str &apos;python&apos;&gt; |</span><br><span class="line">|       | d, &lt;dict&gt;         |</span><br><span class="line">|       | l, &lt;list&gt;         |</span><br><span class="line">+-------+-------------------+</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>在最后，我们还看到两行字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24 LOAD_CONST               2 (None)</span><br><span class="line">27 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>它们好像与我们的四条赋值语句没有任何关系。原来，Python 在执行了一段 CodeBlock 后，一定要返回一些值，既然如此，那就随便返回一个 <code>None</code> 好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Python 源码编译后，有常量表，符号表。一个作用域运行时会对应一个运行时栈。&lt;/p&gt;
&lt;p&gt;大部分字节码就是基于常量表、符号表和运行时栈
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - pyc 的结构</title>
    <link href="http://www.lyyyuna.com/2018/01/06/python-internal5-pyc/"/>
    <id>http://www.lyyyuna.com/2018/01/06/python-internal5-pyc/</id>
    <published>2018-01-06T08:20:02.000Z</published>
    <updated>2018-01-06T13:10:46.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Python 是一门解释性语言，源码执行需要经过：编译-字节码-虚拟机的步骤。本文就介绍一下 <code>.py</code> 文件编译后的 <code>.pyc</code> 文件结构。直接运行的代码不会生成 <code>.pyc</code>，而 Python 的 import 机制会触发 <code>.pyc</code> 文件的生成。</p><h2 id="magic-number-和修改时间"><a href="#magic-number-和修改时间" class="headerlink" title="magic number 和修改时间"></a>magic number 和修改时间</h2><p>我们在导入模块的源码中，能找到 <code>.pyc</code> 文件的蛛丝马迹：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Python/import.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">write_compiled_module(PyCodeObject *co, <span class="keyword">char</span> *cpathname, struct stat *srcstat, <span class="keyword">time_t</span> mtime)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    <span class="comment">/* First write a 0 for mtime */</span></span><br><span class="line">    PyMarshal_WriteLongToFile(<span class="number">0L</span>, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>.pyc</code> 文件包含三个主要内容：magic number，修改时间，和一个 <code>PyCodeObject</code> 对象。</p><p>magic number 和 Python 版本有关，magic number 不同能够防止低版本误执行高版本编译后的字节码。修改时间能让编译器决定是否重新编译源文件。</p><p>我们来读取 <code>.pyc</code> 的前八字节来验证一下我们的分析，<code>func0.py</code> 是测试脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## func0.py</span></span><br><span class="line">    f = open(fname, <span class="string">'rb'</span>)</span><br><span class="line">    magic = f.read(<span class="number">4</span>)</span><br><span class="line">    moddate = f.read(<span class="number">4</span>)</span><br><span class="line">    modtime = time.asctime(time.localtime(struct.unpack(<span class="string">'I'</span>, moddate)[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'magic number: %s'</span> % (magic.encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'moddate %s (%s)'</span> % (moddate.encode(<span class="string">'hex'</span>), modtime)</span><br></pre></td></tr></table></figure><p>被测试源文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a)</span>:</span></span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><p>使用以下强制编译成 <code>.pyc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m py_compile test.py</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python func0.py test.pyc</span><br><span class="line">magic number: 03f30d0a</span><br><span class="line">moddate 5e9a4b5a (Tue Jan  2 22:42:38 2018)</span><br></pre></td></tr></table></figure><h2 id="PyCodeObject-对象"><a href="#PyCodeObject-对象" class="headerlink" title="PyCodeObject 对象"></a>PyCodeObject 对象</h2><p><code>PyCodeObject</code> 是一段代码块编译的直接结果。换句话说，一个作用域，对应一个代码，最终对应一个编译后的 <code>PyCodeObject</code>。<br>首先看一下 <code>PyCodeObject</code> 的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">int</span> co_argcount;<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="keyword">int</span> co_nlocals;<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="keyword">int</span> co_stacksize;<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="keyword">int</span> co_flags;<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    PyObject *co_code;<span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;<span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars;<span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">    <span class="comment">/* The rest doesn't count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;<span class="comment">/* string (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;<span class="comment">/* string (name, for reference) */</span></span><br><span class="line">    <span class="keyword">int</span> co_firstlineno;<span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_lnotab;<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span></span><br><span class="line"><span class="comment">   Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure><p>一段程序不可能只有一个作用域，嵌套的子作用域存在于 <code>co_consts</code> 之中。</p><p>我们写个简单的脚本，展现这种嵌套的结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># func0.py</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_code</span><span class="params">(code, indent=<span class="string">''</span>)</span>:</span></span><br><span class="line">    old_indent = indent  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;code&gt;"</span> % indent  </span><br><span class="line">    indent += <span class="string">'   '</span>  </span><br><span class="line">    show_hex(<span class="string">"bytecode"</span>, code.co_code, indent=indent)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;filename&gt; %r&lt;/filename&gt;"</span> % (indent, code.co_filename)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;consts&gt;"</span> % indent  </span><br><span class="line">    <span class="keyword">for</span> const <span class="keyword">in</span> code.co_consts:  </span><br><span class="line">        <span class="keyword">if</span> type(const) == types.CodeType:  </span><br><span class="line">            show_code(const, indent+<span class="string">'   '</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">print</span> <span class="string">"   %s%r"</span> % (indent, const)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;/consts&gt;"</span> % indent  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s&lt;/code&gt;"</span> % old_indent</span><br></pre></td></tr></table></figure><p>被测试的源文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a)</span>:</span></span><br><span class="line">    a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure></p><p>测试步骤：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exs $ python func0.py test.pyc</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bytecode</span>&gt;</span> 6400008400005a000064010053<span class="tag">&lt;/<span class="name">bytecode</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filename</span>&gt;</span> 'test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">bytecode</span>&gt;</span> 6401007d00007c0000474864000053<span class="tag">&lt;/<span class="name">bytecode</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">filename</span>&gt;</span> 'test.py'<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">consts</span>&gt;</span></span><br><span class="line">            None</span><br><span class="line">         <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line">      None</span><br><span class="line">   <span class="tag">&lt;/<span class="name">consts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，函数 <code>add</code> 作为全局作用域的中一个子作用域，在编译结果中，是以常量形式存在于全局作用域的 <code>PyCodeObject</code> 中。</p><h2 id="查看字节码"><a href="#查看字节码" class="headerlink" title="查看字节码"></a>查看字节码</h2><p>Python 提供了 <code>dis</code> 模块，其中的 <code>disassemble()</code> 函数可以反编译 <code>PyCodeObject</code> 对象，以可读的形式展现出来。<br>我们修改 <code>func0.py</code>，将字节码对应的指令打印出来，增加下述代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">show_hex(<span class="string">"bytecode"</span>, code.co_code, indent=indent)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s&lt;dis&gt;"</span> % indent  </span><br><span class="line">dis.disassemble(code)  </span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s&lt;/dis&gt;"</span> % indent  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ python func0.py test.pyc</span><br><span class="line">&lt;code&gt;</span><br><span class="line">   &lt;bytecode&gt; 6400008400005a000064010053&lt;/bytecode&gt;</span><br><span class="line">   &lt;dis&gt;</span><br><span class="line">  3           0 LOAD_CONST               0 (&lt;code object add at 0x109aa1c30, file &quot;test.py&quot;, line 3&gt;)</span><br><span class="line">              3 MAKE_FUNCTION            0</span><br><span class="line">              6 STORE_NAME               0 (add)</span><br><span class="line">              9 LOAD_CONST               1 (None)</span><br><span class="line">             12 RETURN_VALUE</span><br><span class="line">   &lt;/dis&gt;</span><br><span class="line">   &lt;filename&gt; &apos;test.py&apos;&lt;/filename&gt;</span><br><span class="line">   &lt;consts&gt;</span><br><span class="line">      &lt;code&gt;</span><br><span class="line">         &lt;bytecode&gt; 6401007d00007c0000474864000053&lt;/bytecode&gt;</span><br><span class="line">         &lt;dis&gt;</span><br><span class="line">  4           0 LOAD_CONST               1 (1)</span><br><span class="line">              3 STORE_FAST               0 (a)</span><br><span class="line"></span><br><span class="line">  5           6 LOAD_FAST                0 (a)</span><br><span class="line">              9 PRINT_ITEM</span><br><span class="line">             10 PRINT_NEWLINE</span><br><span class="line">             11 LOAD_CONST               0 (None)</span><br><span class="line">             14 RETURN_VALUE</span><br><span class="line">         &lt;/dis&gt;</span><br><span class="line">         &lt;filename&gt; &apos;test.py&apos;&lt;/filename&gt;</span><br><span class="line">         &lt;consts&gt;</span><br><span class="line">            None</span><br><span class="line">            1</span><br><span class="line">         &lt;/consts&gt;</span><br><span class="line">      &lt;/code&gt;</span><br><span class="line">      None</span><br><span class="line">   &lt;/consts&gt;</span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Python 是一门解释性语言，源码执行需要经过：编译-字节码-虚拟机的步骤。本文就介绍一下 &lt;code&gt;.py&lt;/code&gt; 文件编译后的
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.x 源码 - 编译调试之旅</title>
    <link href="http://www.lyyyuna.com/2018/01/01/python-internal4-lldb/"/>
    <id>http://www.lyyyuna.com/2018/01/01/python-internal4-lldb/</id>
    <published>2018-01-01T08:20:02.000Z</published>
    <updated>2018-01-01T08:03:23.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h2><ol><li>从 GitHub 上下载源码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/python/cpython</span><br><span class="line">$ cd cpython</span><br></pre></td></tr></table></figure><ol><li>编译之前打开 <code>--with-pydebug</code> 选项</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --with-pydebug</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>编译完成之后，会在当前目录看到一个二进制文件 <code>python</code>。如果你使用的是 macOS，文件名为 <code>python.exe</code>，此文后续在命令行中请用 <code>python.exe</code> 代替 <code>python</code>。</p><h2 id="用-GDB-调试"><a href="#用-GDB-调试" class="headerlink" title="用 GDB 调试"></a>用 GDB 调试</h2><p>我们将使用 <code>gdb</code> 来追踪 <code>python</code> 的行为。</p><p>本小结也是一个 <code>gdb</code> 入门教程。</p><h3 id="GDB-快捷键"><a href="#GDB-快捷键" class="headerlink" title="GDB 快捷键"></a>GDB 快捷键</h3><ul><li>r (run)，运行程序</li><li>b (break)，设置断点</li><li>s (step)，单步运行</li><li>c (continue)，继续运行程序，在断点处会停止运行</li><li>l (list)，列出当前程序的源代码</li><li>ctrl+x，打开 tui 模式</li><li>ctrl+p，往上</li><li>ctrl+n，往下</li></ul><h3 id="GDB-介绍"><a href="#GDB-介绍" class="headerlink" title="GDB 介绍"></a>GDB 介绍</h3><p>在编译目录敲入命令 <code>gdb python</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">GNU gdb (GDB) 7.12</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-pc-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from python...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>在最后一行我们看到 <code>Reading symbols from python...done.</code>，说明现在我们可以通过 <code>gdb</code> 来调试 python 了。</p><p>现在程序还没有运行，调试器在程序最前端停止下来。</p><p>每一个 C 程序都从 <code>main()</code> 函数开始运行，所以我们在 <code>main()</code> 上打一个断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p><code>gdb</code> 会在 <code>Programs/python.c, line 20</code> 处打上断点。从这条信息可以看出，<code>Python</code> 的入口点为 <code>Programs/python.c:20</code>。另外，如果你事先已知晓源码，可以直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b Programs/python.c:20</span><br><span class="line">Breakpoint 3 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>运行 <code>python</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>我们停在了之前设置的断点处，使用 <code>list</code> 列出源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">15&#125;</span><br><span class="line">16#else</span><br><span class="line">17</span><br><span class="line">18int</span><br><span class="line">19main(int argc, char **argv)</span><br><span class="line">20&#123;</span><br><span class="line">21    wchar_t **argv_copy;</span><br><span class="line">22    /* We need a second copy, as Python might modify the first one. */</span><br><span class="line">23    wchar_t **argv_copy2;</span><br><span class="line">24    int i, res;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>或者使用 <code>ctrl+x</code> 调出 <code>tui</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   ┌──./Programs/python.c─────────────────────────────────────────────────────────┐</span><br><span class="line">   │15      &#125;                                                                     │</span><br><span class="line">   │16      #else                                                                 │</span><br><span class="line">   │17                                                                            │</span><br><span class="line">   │18      int                                                                   │</span><br><span class="line">   │19      main(int argc, char **argv)                                           │</span><br><span class="line">B+&gt;│20      &#123;                                                                     │</span><br><span class="line">   │21          wchar_t **argv_copy;                                              │</span><br><span class="line">   │22          /* We need a second copy, as Python might modify the first one. */│</span><br><span class="line">   │23          wchar_t **argv_copy2;                                             │</span><br><span class="line">   │24          int i, res;                                                       │</span><br><span class="line">   │25          char *oldloc;                                                     │</span><br><span class="line">   │26                                                                            │</span><br><span class="line">   └──────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">multi-thre Thread 0x7ffff7f9de In: main                         L20   PC: 0x41d1d6 </span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>在 <code>tui</code> 模式，也可以看到我们停在了源代码的第 20 行。</p><p>继续运行 <code>continue</code>，将进入 <code>python</code> 的交互式解释器环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">   │29                                                                                                                                                                                                                                      │</span><br><span class="line">   │30          argv_copy = (wchar_t **)PyMem_RawMalloc(sizeof(wchar_t*) * (argc+1));                                                                                                                                                       │</span><br><span class="line">   │31          argv_copy2 = (wchar_t **)PyMem_RawMalloc(sizeof(wchar_t*) * (argc+1));                                                                                                                                                      │</span><br><span class="line">   │32          if (!argv_copy || !argv_copy2) &#123;                                                                                                                                                                                            │</span><br><span class="line">   └────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">multi-thre Thread 0x7ffff7f9de In: main                                                                                                                                                                                   L20   PC: 0x41d1d6 </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Python 3.7.0a0 (default, Feb 22 2017, 22:10:22) </span><br><span class="line">[GCC 6.3.1 20170109] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="调试语法分析器"><a href="#调试语法分析器" class="headerlink" title="调试语法分析器"></a>调试语法分析器</h2><h3 id="调试语法分析器-1"><a href="#调试语法分析器-1" class="headerlink" title="调试语法分析器"></a>调试语法分析器</h3><p>创建一个简单的 python 脚本 <code>test.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>打开 gdb，设置参数，运行 python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) set args test.py</span><br><span class="line">// 或者</span><br><span class="line">$ gdb --args python test.py</span><br></pre></td></tr></table></figure><p>并在 <code>main</code> 函数上打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x41d1d6: file ./Programs/python.c, line 20.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;Starting program: /home/grd/Python/cpython/python </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdff8) at ./Programs/python.c:20</span><br><span class="line">20&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h4 id="Program-python-c"><a href="#Program-python-c" class="headerlink" title="Program/python.c"></a>Program/python.c</h4><p>如果你仔细查看 <code>Program/python.c</code> 的源码，会发现 <code>main()</code> 做了很多事情，核心是调用 <code>Py_Main(argc, argv_copy)</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">argv_copy2[argc] = argv_copy[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">setlocale(LC_ALL, oldloc);</span><br><span class="line">PyMem_RawFree(oldloc);</span><br><span class="line"></span><br><span class="line">res = Py_Main(argc, argv_copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Force again malloc() allocator to release memory blocks allocated</span></span><br><span class="line"><span class="comment">   before Py_Main() */</span></span><br><span class="line">(<span class="keyword">void</span>)_PyMem_SetupAllocators(<span class="string">"malloc"</span>);</span><br></pre></td></tr></table></figure><h4 id="Modules-main-c"><a href="#Modules-main-c" class="headerlink" title="Modules/main.c"></a>Modules/main.c</h4><p>简单来说，<code>Py_Main</code> 会做如下：</p><ol><li>初始化哈希随机：391</li><li>重置 Warning 选项：394，395</li><li>通过 <code>_PyOS_GetOpt()</code> 解析命令行选项：397</li><li>通过 <code>Py_Initialize()</code> 初始化 python：693</li><li>导入 <code>readline</code> 模块：723</li><li>依次执行：<ol><li><code>run_command()</code></li><li><code>RunModule()</code></li><li><code>RunInteractiveHook()</code></li><li><code>RunMainFromImporter()</code></li><li><code>run_file()</code></li><li><code>PyRun_AnyFileFlags()</code></li></ol></li></ol><p>将断点打在 <code>run_file</code>，第 793 行，可以用 <code>p filename</code> 查看当前文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b Modules/main.c:793</span><br><span class="line">(gdb) c</span><br><span class="line">(gdb) p filename</span><br><span class="line">$1 = 0x931050 L&quot;test.py</span><br><span class="line">(gdb) s</span><br></pre></td></tr></table></figure><p><code>run_file</code> 只是一个装饰器，该装饰器会调用 <code>Python/pythonrun.c</code> 中的 <code>PyRun_InteractiveLoopFlags()</code> 或 <code>PyRun_PyRun_SimpleFileExFlags</code>。从名字上就可以看出一个会进入交互式环境，另一个就是带参数的 python 调用。这里，我们带上了参数 <code>test.py</code>，所以会运行 <code>PyRun_PyRun_SimpleFileExFlags</code>。</p><h4 id="Python-pythonrun-c"><a href="#Python-pythonrun-c" class="headerlink" title="Python/pythonrun.c"></a>Python/pythonrun.c</h4><p><code>PyRun_SimpleFileExFlags()</code> 首先会用 <code>maybe_pyc_file()</code> 检查所传文件是否是 <code>.pyc</code> 格式。</p><p>在我们的例子中，由于是 <code>.py</code> 文件，所以接着会调用 <code>PyRun_FileExFlags()</code>。最后调用 <code>PyParser_ASTFromFileObject()</code> 来建立抽象语法树（AST）。</p><p>抽象语法树需调用 <code>Parser/parsetok.c</code> 中的 <code>PyParser_ParseFileObject()</code> 创建节点，再用 <code>PyAST_FromNodeObject()</code> 函数从节点构建 AST 树。</p><h4 id="Parser-parsetok-c"><a href="#Parser-parsetok-c" class="headerlink" title="Parser/parsetok.c"></a>Parser/parsetok.c</h4><p><code>PyParser_ParseFileObject()</code> 会从 <code>PyTokenizer_FromFile()</code> 中获取所有的 toekn，将这些 token 传入 <code>parsetok()</code> 创建节点。</p><p>最有趣的部分是其中包含一个无限循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = PyTokenizer_Get(tok, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure><p>该函数是 <code>tok_get()</code> 的装饰器，它会返回预定义于 <code>token.h</code> 中的 token 类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/token.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDMARKER0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDENT5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEDENT6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPAR7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RPAR8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LSQB9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RARROW          51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELLIPSIS        52</span></span><br><span class="line"><span class="comment">/* Don't forget to update the table _PyParser_TokenNames in tokenizer.c! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AWAIT54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASYNC55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERRORTOKEN56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TOKENS57</span></span><br></pre></td></tr></table></figure><p>在 for 循环的第一轮，我们在 gdb 中打印上述代码中的 <code>type</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p type</span><br><span class="line">$1 = 1</span><br></pre></td></tr></table></figure><p>根据头文件中的宏，值 1 对应 <code>NAME</code>，说明该 token 为一个变量名。</p><p>在第 236 行，<code>str[lbbben] = &#39;\0&#39;</code> 会储存 token 所对应的字符串，即 <code>a</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p str</span><br><span class="line">$2 = 0x7ffff6eb5a18 &quot;a&quot;</span><br></pre></td></tr></table></figure><p>看起来很有道理，因为我们的源码为 <code>a = 100</code>，第一个 token 字符串应对应于 <code>a</code>，类型为 <code>NAME</code>。</p><p>解析器接下来会调用 <code>PyParser_AddToken()</code>，这会将 token 加入语法树中。</p><h3 id="语法生成"><a href="#语法生成" class="headerlink" title="语法生成"></a>语法生成</h3><p>语法的文本表示在 <code>Grammar/Grammar</code> 中，这是用 <code>yacc</code> 写的，我建议直接忽略。而语法的数字表示在 <code>Python/graminit.c</code> 中，其中包含了 DFA 数组。</p><p>修改 <code>test.py</code> 的内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>打开 gdb，在 <code>PyParser_AddToken()</code> 上打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) b PyParser_AddToken</span><br><span class="line">(gdb) r test.py</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/usr/lib/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, PyParser_AddToken (ps=ps@entry=0x9cf4f0, type=type@entry=1, str=str@entry=0x7ffff6eb5a18 &quot;class&quot;, lineno=1, col_offset=0, expected_ret=expected_ret@entry=0x7fffffffdc34) at Parser/parser.c:229</span><br><span class="line">229&#123;</span><br></pre></td></tr></table></figure><p>为了看到 DFA 的状态变化，在 <code>dfa *d = ps-&gt;p_stack.s_top-&gt;s_dfa</code> 下一行打上断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 244</span><br><span class="line">Breakpoint 2 at 0x5b5933: file Parser/parser.c, line 244.</span><br><span class="line">(gdb) c</span><br><span class="line">Breakpoint 2, PyParser_AddToken (ps=ps@entry=0x9cf4f0, type=type@entry=1, str=str@entry=0x7ffff6eb5a18 &quot;class&quot;, lineno=1, col_offset=0, expected_ret=expected_ret@entry=0x7fffffffdc34) at Parser/parser.c:244</span><br><span class="line">244        state *s = &amp;d-&gt;d_state[ps-&gt;p_stack.s_top-&gt;s_state];</span><br></pre></td></tr></table></figure><p>然后打印出 <code>d</code> 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *d</span><br><span class="line">$6 = &#123;d_type = 269, d_name = 0x606340 &quot;stmt&quot;, d_initial = 0, d_nstates = 2, d_state = 0x8a6a40 &lt;states_13&gt;, d_first = 0x60658c &quot;&quot;&#125;</span><br><span class="line">(gdb) set print pretty</span><br><span class="line">(gdb) p *d</span><br><span class="line">$8 = &#123;</span><br><span class="line">  d_type = 269,</span><br><span class="line">  d_name = 0x606340 &quot;stmt&quot;,</span><br><span class="line">  d_initial = 0,</span><br><span class="line">  d_nstates = 2,</span><br><span class="line">  d_state = 0x8a6a40 &lt;states_13&gt;,</span><br><span class="line">  d_first = 0x60658c &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">(gdb) p d-&gt;d_name</span><br><span class="line">&apos;file_input&apos;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>对比 <code>d_name</code> 的值，发现它出现在 <code>Grammar/Grammar</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Grammar for Python</span><br><span class="line"></span><br><span class="line">single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE</span><br><span class="line">file_input: (NEWLINE | stmt)* ENDMARKER</span><br><span class="line">eval_input: testlist NEWLINE* ENDMARKER</span><br></pre></td></tr></table></figure><p>运行多次，我们会发现 <code>d_name</code> 按如下的顺序变化：<code>file_input</code>, <code>stmt</code>, <code>compound_stmt</code>, <code>classdef</code>, <code>classdef</code>, <code>classdef</code>, <code>classdef</code>, <code>suite</code>, <code>suite</code>, <code>suite</code>, <code>stmt</code>, <code>simple_stmt</code>, <code>small_stmt</code>, <code>pass_stmt</code>, <code>simple_stmt</code>, <code>suite</code>, <code>file_input</code>, <code>file_input</code>。</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>查看一下到目前为止的调用栈：</p><ul><li><code>main()</code></li><li><code>Py_Main()</code></li><li><code>run_file()</code></li><li><code>PyRun_AnyFileExFlags()</code></li><li><code>PyRun_SimpleFileExFlags()</code></li><li><code>PyRun_FileExFlags()</code></li><li><code>PyParser_ASTFromFileObject()</code><ul><li><code>PyParser_ParseFileObject()</code><ul><li><code>parsetok()</code></li><li><code>PyParser_AddToken()</code></li></ul></li><li><code>PyAST_FromNodeObject()</code></li></ul></li></ul><h2 id="调试抽象语法树（AST）生成器"><a href="#调试抽象语法树（AST）生成器" class="headerlink" title="调试抽象语法树（AST）生成器"></a>调试抽象语法树（AST）生成器</h2><p>我们从 <code>PyParser_ParseFileObject()</code> 构建了语法树，下一步是生成 AST。</p><p>在此之前，需要介绍一些宏。这些宏定义于 <code>Include/node.h</code> 中，用于从节点结构中查询数据：</p><ul><li><code>CHILD(node *, int)</code>，返回第 n 个节点（从 0 开始）</li><li><code>RCHILD(node *, int)</code>，从右往左返回第 n 个节点，使用负数</li><li><code>NCH(node *)</code>，返回节点总数</li><li><code>STR(node *)</code>，返回节点的字符串表示，比如冒号 token，会返回 <code>:</code></li><li><code>TYPE(node *)</code>，返回节点的类型，类型定义于 <code>Include/graminit.h</code></li><li><code>REQ(node *, TYPE)</code>，判断节点类型是否是 <code>TYPE</code></li><li><code>LINENO(node *)</code>，获取解析规则源码所在的行数，规则定义在 <code>Python/ast.c</code></li></ul><p>在 <code>Python/ast.c</code> 中的 <code>PyAST_FromNodeObject()</code> 将语法树转换为 AST。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NCH(n) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ch = CHILD(n, i);</span><br><span class="line">    <span class="keyword">if</span> (TYPE(ch) == NEWLINE)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    REQ(ch, stmt);</span><br><span class="line">    num = num_stmts(ch);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">        s = ast_for_stmt(&amp;c, ch);</span><br><span class="line">        <span class="keyword">if</span> (!s)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        asdl_seq_SET(stmts, k++, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ch = CHILD(ch, <span class="number">0</span>);</span><br><span class="line">        REQ(ch, simple_stmt);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">            s = ast_for_stmt(&amp;c, CHILD(ch, j * <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (!s)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            asdl_seq_SET(stmts, k++, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res = Module(stmts, arena);</span><br></pre></td></tr></table></figure><p><code>ast_for_stmt()</code> 是 <code>ast_for_xx</code> 的装饰器，其中 <code>xx</code> 是对应函数处理的语法规则。</p><h2 id="调试符号表生成器"><a href="#调试符号表生成器" class="headerlink" title="调试符号表生成器"></a>调试符号表生成器</h2><p>回到 <code>Python/pythonrun.c</code> 中的 <code>PyRun_FileExFlags()</code>。它会接着将结果 <code>mod</code> 传入 <code>run_mod()</code> 函数中。它完成了重要的两步：第一，生成代码对象（<code>PyAST_CompileObject()</code>），第二，进入解析循环（<code>PyEval_EvalCode()</code>）。</p><p><code>PyAST_CompileObject()</code> 位于 <code>Python/compile.c</code>。它有两个重要的函数：</p><ol><li><code>PySumtable_BuildObject()</code></li><li><code>compiler_mod()</code></li></ol><p><code>Python/symtable.c</code> 中的 <code>PySumtable_BuildObject()</code> 用于生成符号表。</p><p>符号表的结构定义在 <code>Include/symtble.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtable</span> &#123;</span></span><br><span class="line">    PyObject *st_filename;          <span class="comment">/* name of file being compiled,</span></span><br><span class="line"><span class="comment">                                       decoded from the filesystem encoding */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> *<span class="title">st_cur</span>;</span> <span class="comment">/* current symbol table entry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> *<span class="title">st_top</span>;</span> <span class="comment">/* symbol table entry for module */</span></span><br><span class="line">    PyObject *st_blocks;            <span class="comment">/* dict: map AST node addresses</span></span><br><span class="line"><span class="comment">                                     *       to symbol table entries */</span></span><br><span class="line">    PyObject *st_stack;             <span class="comment">/* list: stack of namespace info */</span></span><br><span class="line">    PyObject *st_global;            <span class="comment">/* borrowed ref to st_top-&gt;ste_symbols */</span></span><br><span class="line">    <span class="keyword">int</span> st_nblocks;                 <span class="comment">/* number of blocks used. kept for</span></span><br><span class="line"><span class="comment">                                       consistency with the corresponding</span></span><br><span class="line"><span class="comment">                                       compiler structure */</span></span><br><span class="line">    PyObject *st_private;           <span class="comment">/* name of current class or NULL */</span></span><br><span class="line">    PyFutureFeatures *st_future;    <span class="comment">/* module's future features that affect</span></span><br><span class="line"><span class="comment">                                       the symbol table */</span></span><br><span class="line">    <span class="keyword">int</span> recursion_depth;            <span class="comment">/* current recursion depth */</span></span><br><span class="line">    <span class="keyword">int</span> recursion_limit;            <span class="comment">/* recursion limit */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">symtable_entry</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *ste_id;        <span class="comment">/* int: key in ste_table-&gt;st_blocks */</span></span><br><span class="line">    PyObject *ste_symbols;   <span class="comment">/* dict: variable names to flags */</span></span><br><span class="line">    PyObject *ste_name;      <span class="comment">/* string: name of current block */</span></span><br><span class="line">    PyObject *ste_varnames;  <span class="comment">/* list of function parameters */</span></span><br><span class="line">    PyObject *ste_children;  <span class="comment">/* list of child blocks */</span></span><br><span class="line">    PyObject *ste_directives;<span class="comment">/* locations of global and nonlocal statements */</span></span><br><span class="line">    _Py_block_ty ste_type;   <span class="comment">/* module, class, or function */</span></span><br><span class="line">    <span class="keyword">int</span> ste_nested;      <span class="comment">/* true if block is nested */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_free : <span class="number">1</span>;        <span class="comment">/* true if block has free variables */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_child_free : <span class="number">1</span>;  <span class="comment">/* true if a child block has free vars,</span></span><br><span class="line"><span class="comment">                                     including free refs to globals */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_generator : <span class="number">1</span>;   <span class="comment">/* true if namespace is a generator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_coroutine : <span class="number">1</span>;   <span class="comment">/* true if namespace is a coroutine */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_varargs : <span class="number">1</span>;     <span class="comment">/* true if block has varargs */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_varkeywords : <span class="number">1</span>; <span class="comment">/* true if block has varkeywords */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_returns_value : <span class="number">1</span>;  <span class="comment">/* true if namespace uses return with</span></span><br><span class="line"><span class="comment">                                        an argument */</span></span><br><span class="line">    <span class="keyword">unsigned</span> ste_needs_class_closure : <span class="number">1</span>; <span class="comment">/* for class scopes, true if a</span></span><br><span class="line"><span class="comment">                                            closure over __class__</span></span><br><span class="line"><span class="comment">                                             should be created */</span></span><br><span class="line">    <span class="keyword">int</span> ste_lineno;          <span class="comment">/* first line of block */</span></span><br><span class="line">    <span class="keyword">int</span> ste_col_offset;      <span class="comment">/* offset of first line of block */</span></span><br><span class="line">    <span class="keyword">int</span> ste_opt_lineno;      <span class="comment">/* lineno of last exec or import * */</span></span><br><span class="line">    <span class="keyword">int</span> ste_opt_col_offset;  <span class="comment">/* offset of last exec or import * */</span></span><br><span class="line">    <span class="keyword">int</span> ste_tmpname;         <span class="comment">/* counter for listcomp temp vars */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">symtable</span> *<span class="title">ste_table</span>;</span></span><br><span class="line">&#125; PySTEntryObject;</span><br></pre></td></tr></table></figure><p>可以看出，符号表其实是一个字典结构，每一项是一个符号对应关系。</p><p>在第 281 行的 for 循环打上断点（<code>for (i = 0; i &lt; asdl_seq_LEN(seq); i++)</code>），会来到 <code>symtable_visit_stmt()</code> 函数，该函数生成符号表的每一项。接着打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b symtable_visit_stmt</span><br></pre></td></tr></table></figure><p>就能观察到类似 <code>xx_kind</code> 的表达式，例如 <code>Name_kind</code> 会调用 <code>symtable_add_def()</code> 将一个符号定义加入到符号表中。</p><h2 id="调试编译器和字节码生成器"><a href="#调试编译器和字节码生成器" class="headerlink" title="调试编译器和字节码生成器"></a>调试编译器和字节码生成器</h2><p>回到函数 <code>PyAST_CompileObject()</code> 中，下一步是 <code>compiler_mod()</code>，将抽象语法树转换为上下文无关语法。</p><p>在此处打断点（<code>b compiler_mod</code>）。swtich 分支会把我们带进 <code>Module_kind</code>，里面会调用 <code>compiler_body()</code> 函数，接着单步调试，就会发现一个 for 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &lt; asdl_seq_LEN(stmts); i++)</span><br><span class="line">    VISIT(c, stmt, (stmt)ty)asdl_seq_GET(stmts, i));</span><br></pre></td></tr></table></figure><p>这里，我们在抽象语义描述语言（ASDL）中遍历，调用宏 <code>VISIT</code>，接着调用 <code>compiler_visit_expr(c, nodeZ)</code>。</p><p>以下宏会产生字节码：</p><ul><li><code>ADDOP()</code>，增加一个指定的字节码</li><li><code>ADDOP_I()</code>，增加的字节码是带参数的</li><li><code>ADDOP_O(struct compiler *c, int op, PyObject * type, PyObject *obj)</code>，根据指定 <code>PyObject</code> 在序列中的位置，增加一个字节码，但是不考虑 name mangling。常用于全局、常量或参数的变量名寻找，因为这种变量名的作用域是未知的。</li><li><code>ADDOP_NAME()</code>，和 <code>ADDOP_O</code> 类似，但是会考虑 name mangling。用于属性加载和导入。</li><li><code>ADDOP_JABS()</code>，创建一个绝对跳转</li><li><code>ADDOP_JREL()</code>，创建一个相对跳转</li></ul><p>为了验证是否生成了正确的字节码，可以在 <code>test.py</code> 上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python -m dis test.py</span><br><span class="line">  1           0 LOAD_CONST               0 (100)</span><br><span class="line">              2 STORE_NAME               0 (a)</span><br><span class="line">              4 LOAD_CONST               1 (None)</span><br><span class="line">              6 RETURN_VALUE</span><br></pre></td></tr></table></figure><h2 id="调试解析器循环"><a href="#调试解析器循环" class="headerlink" title="调试解析器循环"></a>调试解析器循环</h2><p>一旦字节码生成，下一步是由解析器运行程序。回到 <code>Python/pythonrun.c</code> 文件中，我们接着会调用函数 <code>PyEval_EvalCode()</code>，这是对 <code>PyEval_EvalCodeEx()/_PyEval_EvalCodeWithName()</code> 的装饰器函数。</p><blockquote><p>和 Python2.7 不一样，<code>PyEval_EvalCodeEx</code> 不会建立函数栈，这一步被移入 <code>_PyEval_EvalCodeWithName</code>。</p></blockquote><p>栈对象的结构定义于 <code>Include/frameobject.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>      <span class="comment">/* previous frame, or NULL */</span></span><br><span class="line">    PyCodeObject *f_code;       <span class="comment">/* code segment */</span></span><br><span class="line">    PyObject *f_builtins;       <span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;        <span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;         <span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;    <span class="comment">/* points after the last local */</span></span><br><span class="line">    <span class="comment">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span></span><br><span class="line"><span class="comment">       Frame evaluation usually NULLs it, but a frame that yields sets it</span></span><br><span class="line"><span class="comment">       to the current stack top. */</span></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;          <span class="comment">/* Trace function */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In a generator, we need to be able to swap between the exception</span></span><br><span class="line"><span class="comment">       state inside the generator and the exception state of the calling</span></span><br><span class="line"><span class="comment">       frame (which shouldn't be impacted when the generator "yields"</span></span><br><span class="line"><span class="comment">       from an except handler).</span></span><br><span class="line"><span class="comment">       These three fields exist exactly for that, and are unused for</span></span><br><span class="line"><span class="comment">       non-generator frames. See the save_exc_state and swap_exc_state</span></span><br><span class="line"><span class="comment">       functions in ceval.c for details of their use. */</span></span><br><span class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</span><br><span class="line">    <span class="comment">/* Borrowed reference to a generator, or NULL */</span></span><br><span class="line">    PyObject *f_gen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f_lasti;                <span class="comment">/* Last instruction if called */</span></span><br><span class="line">    <span class="comment">/* Call PyFrame_GetLineNumber() instead of reading this field</span></span><br><span class="line"><span class="comment">       directly.  As of 2.3 f_lineno is only valid when tracing is</span></span><br><span class="line"><span class="comment">       active (i.e. when f_trace is set).  At other times we use</span></span><br><span class="line"><span class="comment">       PyCode_Addr2Line to calculate the line from the current</span></span><br><span class="line"><span class="comment">       bytecode index. */</span></span><br><span class="line">    <span class="keyword">int</span> f_lineno;               <span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="keyword">int</span> f_iblock;               <span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    <span class="keyword">char</span> f_executing;           <span class="comment">/* whether the frame is still executing */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];  <span class="comment">/* locals+stack, dynamically sized */</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure><p>在 <code>_PyEval_EvalCodeWithName()</code> 中，会用 <code>_PyFrame_New_NoTrack()</code> 创建一个栈对象，这个栈是对 C 程序函数栈的模拟，在最后，会调用 <code>PyEval_EvalFrameEx()</code>。</p><p><code>PyEval_EvalFrameEx()</code> 然后会在 <code>PyThreadState</code> 上调用 <code>eval_frame()/_PyEval_EvalFrameDefault()</code> 函数。这个函数也会被 Python 虚拟机调用。</p><p>跟踪进入 <code>_PyEval_EvalFrameDefault()</code>，我们可以观察到第 1054 行有一个无限循环，在不断产生字节码。</p><h2 id="调试-Python-对象"><a href="#调试-Python-对象" class="headerlink" title="调试 Python 对象"></a>调试 Python 对象</h2><p><code>PyObject</code> 是通用 Python 对象，定义于 <code>Include/object.h</code> 中。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每一种 <code>PyObject</code> 都有着相似的跟踪步骤：</p><ul><li>用 gdb 打开 python</li><li>在对象创建函数上打断点</li><li>用交互式命令环境，创建我们想要的对象</li><li>在断点处，开始一步步跟踪代码</li></ul><p>例如，我们想单步调试 <code>PyBoolObject</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb python</span><br><span class="line">(gdb) b bool_newbb</span><br><span class="line">Breakpoint 1 at 0x44812f: file Objects/boolobject.c, line 44.</span><br><span class="line">(gdb) r</span><br><span class="line">[GCC 6.3.1 20170109] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; a = bool(1)</span><br><span class="line"></span><br><span class="line">Breakpoint 1, bool_new (type=0x87a700 &lt;PyBool_Type&gt;, args=(1,), kwds=0x0) at Objects/boolobject.c:44</span><br><span class="line">44&#123;</span><br></pre></td></tr></table></figure><h3 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h3><p>通用 Python 对象定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObjecdt;</span><br></pre></td></tr></table></figure><p>在预处理器展开宏 <code>_PyObject_HEAD_EXTRA</code> 后，它会变成一个双向列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObjecdt;</span><br></pre></td></tr></table></figure><p>该对象包含两个重要元素：引用计数和类型对象。</p><h3 id="PyVarObject"><a href="#PyVarObject" class="headerlink" title="PyVarObject"></a>PyVarObject</h3><p>Python 也有变长对象，定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>几乎和 <code>PyObject</code> 一样，但多了一项用于表示对象的长度信息。</p><h3 id="PyTypeObject"><a href="#PyTypeObject" class="headerlink" title="PyTypeObject"></a>PyTypeObject</h3><p><code>PyTypeObject</code> 是 Python 对象的类型表示。在 Python 中可以如下表达式获取任何对象的类型信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = type(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(t)</span><br><span class="line">[<span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__bool__'</span>, <span class="string">'__ceil__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__divmod__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__float__'</span>, <span class="string">'__floor__'</span>, <span class="string">'__floordiv__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__index__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__int__'</span>, <span class="string">'__invert__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lshift__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__neg__'</span>, <span class="string">'__new__'</span>, <span class="string">'__or__'</span>, <span class="string">'__pos__'</span>, <span class="string">'__pow__'</span>, <span class="string">'__radd__'</span>, <span class="string">'__rand__'</span>, <span class="string">'__rdivmod__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rfloordiv__'</span>, <span class="string">'__rlshift__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__ror__'</span>, <span class="string">'__round__'</span>, <span class="string">'__rpow__'</span>, <span class="string">'__rrshift__'</span>, <span class="string">'__rshift__'</span>, <span class="string">'__rsub__'</span>, <span class="string">'__rtruediv__'</span>, <span class="string">'__rxor__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__sub__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__truediv__'</span>, <span class="string">'__trunc__'</span>, <span class="string">'__xor__'</span>, <span class="string">'bit_length'</span>, <span class="string">'conjugate'</span>, <span class="string">'denominator'</span>, <span class="string">'from_bytes'</span>, <span class="string">'imag'</span>, <span class="string">'numerator'</span>, <span class="string">'real'</span>, <span class="string">'to_bytes'</span>]</span><br></pre></td></tr></table></figure><p>这些方法都定义在 <code>PyTypeObject</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_LIMITED_API</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> <span class="title">PyTypeObject</span>;</span> <span class="comment">/* opaque */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; <span class="comment">/* formerly known as tp_compare (Python 2)</span></span><br><span class="line"><span class="comment">                                    or tp_reserved (Python 3) */</span></span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.0 */</span></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.1 */</span></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line">    destructor tp_finalize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="comment">/* these must be last and never explicitly initialized */</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>所有的整数对象现在都在 <code>Objects/longobject.c</code> 中实现，定义为 <code>PyLong_Type</code> 类型。<code>PyLong_Type</code> 就是一个 <code>PyTypeObject</code> 对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyLong_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,                                      <span class="comment">/* tp_name */</span></span><br><span class="line">    offsetof(PyLongObject, ob_digit),           <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(digit),                              <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    long_dealloc,                               <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;long_as_number,                            <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)long_hash,                        <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    long_to_decimal_string,                     <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |</span><br><span class="line">        Py_TPFLAGS_LONG_SUBCLASS,               <span class="comment">/* tp_flags */</span></span><br><span class="line">    long_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    long_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    long_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    long_getset,                                <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    long_new,                                   <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="PyLongObject"><a href="#PyLongObject" class="headerlink" title="PyLongObject"></a>PyLongObject</h3><p>定义于 <code>Include/longobject.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br></pre></td></tr></table></figure><h3 id="PyBoolObject"><a href="#PyBoolObject" class="headerlink" title="PyBoolObject"></a>PyBoolObject</h3><p><code>PyBoolObject</code> 在 Python 中存储布尔类型，定义于 <code>Include/boolobject.h</code> 中。</p><h3 id="PyFloatObject"><a href="#PyFloatObject" class="headerlink" title="PyFloatObject"></a>PyFloatObject</h3><p>在 <code>Include/floatobject.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">double</span> ob_fval;</span><br><span class="line">&#125; PyFloatObject;</span><br></pre></td></tr></table></figure><h3 id="PyListObject"><a href="#PyListObject" class="headerlink" title="PyListObject"></a>PyListObject</h3><p>在 <code>Include/listobject.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="comment">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span></span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ob_item contains space for 'allocated' elements.  The number</span></span><br><span class="line"><span class="comment">     * currently in use is ob_size.</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *     0 &lt;= ob_size &lt;= allocated</span></span><br><span class="line"><span class="comment">     *     len(list) == ob_size</span></span><br><span class="line"><span class="comment">     *     ob_item == NULL implies ob_size == allocated == 0</span></span><br><span class="line"><span class="comment">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Items must normally not be NULL, except during construction when</span></span><br><span class="line"><span class="comment">     * the list is not yet visible outside the function that builds it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;建立环境&quot;&gt;&lt;a href=&quot;#建立环境&quot; class=&quot;headerlink&quot; title=&quot;建立环境&quot;&gt;&lt;/a&gt;建立环境&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从 GitHub 上下载源码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python3.x源码" scheme="http://www.lyyyuna.com/tags/Python3-x%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 字符串对象</title>
    <link href="http://www.lyyyuna.com/2017/12/28/python-internal3-string-object/"/>
    <id>http://www.lyyyuna.com/2017/12/28/python-internal3-string-object/</id>
    <published>2017-12-28T08:20:02.000Z</published>
    <updated>2017-12-29T01:34:37.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-的字符串类型和对象"><a href="#Python-的字符串类型和对象" class="headerlink" title="Python 的字符串类型和对象"></a>Python 的字符串类型和对象</h2><p>有了之前<a href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/">整数对象</a>的铺垫，研究字符串类型及其对象，当然是先看其对应的类型结构体和对象结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyTypeObject PyString_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"str"</span>,</span><br><span class="line">    PyStringObject_SIZE,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">char</span>),</span><br><span class="line">    string_dealloc,                             <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    (printfunc)string_print,                    <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    &amp;PyBaseString_Type,                         <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    string_new,                                 <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_Del,                               <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_shash;</span><br><span class="line">    <span class="keyword">int</span> ob_sstate;</span><br><span class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];</span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure><p><code>ob_shash</code> 是该字符串的哈希值，由于 Python 的字典实现大量使用了哈希值，且字典的健多为 <code>PyStringObject</code>，预先计算哈希值并保存下来，可以加速字典的运算。</p><p><code>ob_sstate</code> 和字符串对象的 intern 机制有关。</p><p><code>ob_sval</code> 为什么是长度为 1 的数组？这种定义方法其实符合 C99 标准。<a href="https://en.wikipedia.org/wiki/Flexible_array_member" target="_blank" rel="noopener">Flexible array member</a>规定，若要支持柔性数组，可在结构体末尾放置一个不指定长度的数组。而大多数编译器都支持长度为 1 的定义方法，所以就写成 1 了。如果你单独定义 <code>char buf[]</code>，那必然是会报错的。</p><h2 id="创建一个-PyStringObject"><a href="#创建一个-PyStringObject" class="headerlink" title="创建一个 PyStringObject"></a>创建一个 PyStringObject</h2><p>最底层的生成字符串的函数为 <code>PyString_FromString</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size = <span class="built_in">strlen</span>(str);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">    op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    (<span class="keyword">void</span>)PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">    op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</span><br><span class="line">    Py_MEMCPY(op-&gt;ob_sval, str, size+<span class="number">1</span>);  <span class="comment">// 将原始C字串的值搬运过来</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是根据原始的 C 语言字符串生成对应的 <code>PyStringObject</code>。原始字符串被复制到 <code>ob_sval</code> 中。</p><h2 id="intern-机制"><a href="#intern-机制" class="headerlink" title="intern 机制"></a>intern 机制</h2><p>和整数对象一样，<code>PyStringObject</code> 需要优化才堪实用，于是 Python 的设计者便开发了 intern 机制。</p><p>所谓 intern，即如果两个字符串对象的原始字符串相同，那么其 <code>ob_sval</code> 共享同一份内存。若程序中出现了 100 次 <code>hello, world</code>，那么在内存中只会保存一份。</p><p>intern 机制的核心在于字典 <code>interned</code>。该字典为 Python 的内建数据结构，可以简单等价于 C++ 的 <code>map&lt;T,R&gt;</code>。该字典的健值都为字符串本身 <code>pystring:pystring</code>，所有需 intern 的字符串会缓存到该 <code>interned</code> 字典中，当在程序中再遇到相同的字符串 <code>pystring</code>，便可通过字典在 <code>O(1)</code> 时间内检索出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* share short strings */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        PyObject *t = (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op = (PyStringObject *)t;</span><br><span class="line">        nullstring = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        PyObject *t = (PyObject *)op;</span><br><span class="line">        PyString_InternInPlace(&amp;t);</span><br><span class="line">        op = (PyStringObject *)t;</span><br><span class="line">        characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>PyString_FromString</code> 函数最后，会强制将长度为 0 和 1 的字符串 intern，而这一操作的核心为 <code>PyString_InterInPlace</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringobject.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PyString_InternInPlace(PyObject **p)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        interned = PyDict_New();</span><br><span class="line">        <span class="keyword">if</span> (interned == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Clear(); <span class="comment">/* Don't leave an exception */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t = PyDict_GetItem(interned, (PyObject *)s);</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        Py_INCREF(t);</span><br><span class="line">        Py_SETREF(*p, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Py_REFCNT(s) -= <span class="number">2</span>;</span><br><span class="line">    PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_SETREF(op, op2)                      \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                        \</span><br><span class="line">        PyObject *_py_tmp = (PyObject *)(op);   \</span><br><span class="line">        (op) = (op2);                           \</span><br><span class="line">        Py_DECREF(_py_tmp);                     \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>函数的开始会尝试新建 <code>interned</code> 字典。然后是尝试在 <code>interned</code> 字典中找该字符串 <code>PyDict_GetItem</code>。</p><ul><li>若找到，就需要增加该健值对上的引用计数，并减去 <code>PyStringObject</code> 对象的引用计数。<code>PyStringObject</code> 对象减为 0 后会被回收内存。为啥原对象要被回收？因为后续程序只会通过 <code>interned</code> 字典引用字符串，原对象留着没啥用处了。</li><li>若没找到，会尝试在字典中新建健值对 <code>PyDict_SetItem</code>。新建的健值对需要减去 2 个引用计数。我们的 <code>interned</code> 字典健值都是原字符串，该 <code>PyStringObject</code> 无论如何都至少会有两个引用。健值仅仅是作为 Python 虚拟机内部使用，不应影响所运行程序的内存回收，故需减 2。</li></ul><h2 id="单字符字符串的进一步优化"><a href="#单字符字符串的进一步优化" class="headerlink" title="单字符字符串的进一步优化"></a>单字符字符串的进一步优化</h2><p>在 <code>PyString_FromString</code> 函数中，还看到了 <code>characters</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">    PyObject *t = (PyObject *)op;</span><br><span class="line">    PyString_InternInPlace(&amp;t);</span><br><span class="line">    op = (PyStringObject *)t;</span><br><span class="line">    characters[*str &amp; UCHAR_MAX] = op;</span><br><span class="line">    Py_INCREF(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单字节的字符串被缓存到了 <code>characters</code> 数组中。在创建字符串函数时，直接从数组中取出单字节字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyString_FromString(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span> &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">        one_strings++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        Py_INCREF(op);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>数组比哈希字典效率更高。</p><h2 id="字符串拼接所做的优化"><a href="#字符串拼接所做的优化" class="headerlink" title="字符串拼接所做的优化"></a>字符串拼接所做的优化</h2><p>字符串虽然是变长对象，但并不是可变对象，创建之后，<code>ob_sval</code> 数组的长度无法再改变。在拼接两个字符串 s1, s2 时，必须重新生成一个 <code>PyStringObject</code> 对象来放置 <code>s1-&gt;ob_sval + s2-&gt;sval</code>。如果要连接 N 个 <code>PyStringObject</code> 对象，那么就必须进行 N-1 次的内存申请及内存搬运的工作。毫无疑问，这将严重影响 Python 的执行效率。</p><p>所以官方推荐的做法是使用 <code>join</code> 函数，该函数一次性分配好所有内存，然后统一搬运。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"-"</span></span><br><span class="line">seq = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">print</span> s.join( seq )</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>何种字符串会 intern？不同的 Python 版本似乎采取了不同的策略，以我 Mac 上 Python 2.7.10 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'foo'</span> <span class="keyword">is</span> <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'foo!'</span> <span class="keyword">is</span> <span class="string">'foo!'</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>*<span class="number">20</span> <span class="keyword">is</span> <span class="string">'a'</span>*<span class="number">20</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>*<span class="number">21</span> <span class="keyword">is</span> <span class="string">'a'</span>*<span class="number">21</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-的字符串类型和对象&quot;&gt;&lt;a href=&quot;#Python-的字符串类型和对象&quot; class=&quot;headerlink&quot; title=&quot;Python 的字符串类型和对象&quot;&gt;&lt;/a&gt;Python 的字符串类型和对象&lt;/h2&gt;&lt;p&gt;有了之前&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 整数对象</title>
    <link href="http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/"/>
    <id>http://www.lyyyuna.com/2017/12/24/python-internal2-integer-object/</id>
    <published>2017-12-24T08:20:02.000Z</published>
    <updated>2017-12-24T13:23:21.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-的面向对象"><a href="#Python-的面向对象" class="headerlink" title="Python 的面向对象"></a>Python 的面向对象</h2><p>面向对象编程中，对象是数据以及基于这些数据的操作的集合，实际上在计算机中这只是一堆内存逻辑上的集合，无论这段内存是连续的还是分开的。</p><p>Python 是由 C 语言写成，描述一段逻辑上结合的内存，直接用结构体 <code>struct</code> 就可以了。但是 <code>struct</code> 并不是面向对象中类型的概念，对象还需要成员函数。所以还需要另外一个结构体 <code>struct</code> 来描述成员函数的集合。</p><p>上述特点就导致了在 Python 中，实际的类型也是一个对象，这个类型对象的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    cmpfunc tp_compare;</span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="keyword">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.0 */</span></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.1 */</span></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Added in release 2.2 */</span></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;</span><br><span class="line">    iternextfunc tp_iternext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="comment">/* these must be last and never explicitly initialized */</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><p>所以在源码中，Python 最基础的对象表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>每一个对象都有一个指针指向自己所属的类型对象，而类型对象则有关于这个对象支持的所有操作的信息。</p><p>仔细看 <code>PyTypeObject</code> 的头部，<code>PyObject_VAR_HEAD</code> 即含有 <code>ob_type</code>，难道还有类型的类型这个概念？是的，这个终极的类型就是元类，即 <code>metaclass</code>。做个简单的实验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br></pre></td></tr></table></figure><p>在 Python 中类型是对象，所以类型对象也有类型，而元类的类型就是自己。</p><h2 id="Python-的整数类型"><a href="#Python-的整数类型" class="headerlink" title="Python 的整数类型"></a>Python 的整数类型</h2><p>整数类型没啥可说的，按照 <code>PyTypeObject</code> 结构去填充信息即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyInt_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"int"</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyIntObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)int_dealloc,                    <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    (printfunc)int_print,                       <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    (cmpfunc)int_compare,                       <span class="comment">/* tp_compare */</span></span><br><span class="line">    (reprfunc)int_to_decimal_string,            <span class="comment">/* tp_repr */</span></span><br><span class="line">    &amp;int_as_number,                             <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)int_hash,                         <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    (reprfunc)int_to_decimal_string,            <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |</span><br><span class="line">        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          <span class="comment">/* tp_flags */</span></span><br><span class="line">    int_doc,                                    <span class="comment">/* tp_doc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    int_methods,                                <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    int_getset,                                 <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    int_new,                                    <span class="comment">/* tp_new */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="整数对象的内存"><a href="#整数对象的内存" class="headerlink" title="整数对象的内存"></a>整数对象的内存</h2><p>再看一眼 PyObject 对象，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>我们看到了 <code>ob_refcnt</code> 引用计数对象，可以很容易地联想到 Python 虚拟机是以引用计数为基础构建垃圾回收机制。既然如此，那还有没有必要专门讨论整数对象的内存使用,而直接抽象成引用计数归零后释放内存？</p><p>事实上，为了提高虚拟机的性能，整数对象使用了多种技术。</p><h3 id="大整数创建"><a href="#大整数创建" class="headerlink" title="大整数创建"></a>大整数创建</h3><p>在 intobject.c 中定义有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> *<span class="title">next</span>;</span></span><br><span class="line">    PyIntObject objects[N_INTOBJECTS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">intblock</span> <span class="title">PyIntBlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntBlock *block_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> PyIntObject *free_list = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><code>block_list</code> 是由一个个 <code>PyIntBlock</code> 串起来的链表，每一个 <code>PyIntBlock</code> 是一个整数数组。<code>free_list</code> 是由空闲的 <code>PyIntObject</code> 组成的链表，空闲是指这块内存虽然被划分为一个 <code>PyIntObject</code>，但并没有被用于表示一个真正的整数，即其所存储的信息是无用的。</p><p>整数创建时，<code>PyObject * PyInt_FromLong(long ival)</code> 会被调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyInt_FromLong(<span class="keyword">long</span> ival)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> PyIntObject *v;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (free_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((free_list = fill_free_list()) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Inline PyObject_New */</span></span><br><span class="line">    v = free_list;</span><br><span class="line">    free_list = (PyIntObject *)Py_TYPE(v);</span><br><span class="line">    (<span class="keyword">void</span>)PyObject_INIT(v, &amp;PyInt_Type);</span><br><span class="line">    v-&gt;ob_ival = ival;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyIntObject *</span><br><span class="line">fill_free_list(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    PyIntObject *p, *q;</span><br><span class="line">    <span class="comment">/* Python's object allocator isn't appropriate for large blocks. */</span></span><br><span class="line">    p = (PyIntObject *) PyMem_MALLOC(<span class="keyword">sizeof</span>(PyIntBlock));</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> (PyIntObject *) PyErr_NoMemory();</span><br><span class="line">    ((PyIntBlock *)p)-&gt;next = block_list;</span><br><span class="line">    block_list = (PyIntBlock *)p;</span><br><span class="line">    <span class="comment">/* Link the int objects together, from rear to front, then return</span></span><br><span class="line"><span class="comment">       the address of the last int object in the block. */</span></span><br><span class="line">    p = &amp;((PyIntBlock *)p)-&gt;objects[<span class="number">0</span>];</span><br><span class="line">    q = p + N_INTOBJECTS;</span><br><span class="line">    <span class="keyword">while</span> (--q &gt; p)</span><br><span class="line">        Py_TYPE(q) = (struct _typeobject *)(q<span class="number">-1</span>);</span><br><span class="line">    Py_TYPE(q) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p + N_INTOBJECTS - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建整数的时候，会先尝试从 <code>free_list</code> 中取，如果没有空闲的，就会尝试 <code>fill_free_list</code>。这个新的 <code>PyIntBlock</code> 中，每一个 <code>PyIntObject</code> 都借用 <code>ob_type</code> 来连接成链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_TYPE(ob) (((PyObject*)(ob))-&gt;ob_type)</span></span><br></pre></td></tr></table></figure><p>这里只是借用，初看源码的朋友不要被这里搞混了。因为此时这块内存并没有存放整数，它的成员自然可以借来他用。<code>free_list</code> 指向数组的末尾，从后往前链接到数组首部。</p><h3 id="大整数销毁"><a href="#大整数销毁" class="headerlink" title="大整数销毁"></a>大整数销毁</h3><p>当一个整数销毁时，便会进入 <code>int_dealloc</code> 函数内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">int_dealloc(PyIntObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PyInt_CheckExact(v)) &#123;</span><br><span class="line">        Py_TYPE(v) = (struct _typeobject *)free_list;</span><br><span class="line">        free_list = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Py_TYPE(v)-&gt;tp_free((PyObject *)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在正常情况下不会走到 <code>else</code> 分支，意味着所谓的销毁，只是把这个整数的 <code>PyIntObject</code> 重新放回 <code>free_list</code> 链表中，并不会释放这块内存。这岂不会造成内存泄漏？只能说，理论上会。整数对象所占用的内存空间，只和这个程序同时拥有的最多的整数数量有关。</p><p>上述做法也是为了优化性能，虚拟机不再需要频繁的 <code>malloc</code> 和 <code>free</code>。</p><h3 id="小整数"><a href="#小整数" class="headerlink" title="小整数"></a>小整数</h3><p>除了普通的整数外，Python 中还存在着一种小整数对象。在之前的 <code>PyInt_FromLong</code> 函数中，我们略了一部分，现在我们从另一个角度看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyInt_FromLong(<span class="keyword">long</span> ival)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> PyIntObject *v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123;</span><br><span class="line">        v = small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当想创建的整数在 <code>-NSMALLNEGINTS ~ NSMALLPOSINTS</code> 之间时，就会从 <code>small_ints</code> 数组中直接取出。这范围内的整数即为小整数。小整数使用广泛，循环的初始值，终结值，步进值等等，都是数值很小的整数。小整数从 Python 虚拟机运行之初就存在，使用它们既不需要 <code>malloc</code> 和 <code>free</code>，甚至连指针操作 <code>free_list</code> 也不要。效率比大整数更高。</p><p>而小整数的范围可在编译 Python 时指定，默认为 <code>-5 ~ 257</code>。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>改造一下整数打印函数，反映出内存的变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> values[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> refcounts[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/* ARGSUSED */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">int_print(PyIntObject *v, FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">     <span class="comment">/* flags -- not used but required by interface */</span></span><br><span class="line">&#123;</span><br><span class="line">    PyIntObject * intObjectPtr;</span><br><span class="line">    PyIntBlock * p = block_list;</span><br><span class="line">    PyIntBlock * last = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> int_val = v-&gt;ob_ival;</span><br><span class="line">    Py_BEGIN_ALLOW_THREADS</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%ld"</span>, int_val);</span><br><span class="line">    Py_END_ALLOW_THREADS</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        last = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    intObjectPtr = last-&gt;objects;</span><br><span class="line">    intObjectPtr += N_INTOBJECTS<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nvalue's address is @%p\n"</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++, --intObjectPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        values[i] = intObjectPtr-&gt;ob_ival;</span><br><span class="line">        refcounts[i] = intObjectPtr-&gt;ob_refcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  value : "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  refcnt : "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, refcounts[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" block_list count : %d\n"</span>, count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" free_list address : %p\n"</span>, free_list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行重新编译后的 python 虚拟机。</p><h3 id="大整数实验"><a href="#大整数实验" class="headerlink" title="大整数实验"></a>大整数实验</h3><p>首先是连续创建两个大整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1111</span></span><br><span class="line">value<span class="string">'s address is @0x100303888</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     587     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038a0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b=2222</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; b</span></span><br><span class="line"><span class="string">2222</span></span><br><span class="line"><span class="string">value'</span>s address <span class="keyword">is</span> @<span class="number">0x1003038a0</span></span><br><span class="line">  value : <span class="number">-5</span>    <span class="number">-4</span>      <span class="number">-3</span>      <span class="number">-2</span>      <span class="number">-1</span>      <span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">  refcnt : <span class="number">1</span>    <span class="number">1</span>       <span class="number">1</span>       <span class="number">1</span>       <span class="number">54</span>      <span class="number">389</span>     <span class="number">587</span>     <span class="number">84</span></span><br><span class="line"> block_list count : <span class="number">9</span></span><br><span class="line"> free_list address : <span class="number">0x1003038b8</span></span><br></pre></td></tr></table></figure><p>第一次的 <code>free_list</code>，正好是第二次整数的地址。可以看到小整数都至少有一个引用，有些多于一次是因为 python 虚拟机内部使用的缘故。</p><p>当尝试创建一个相同的大整数时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="number">2222</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">2222</span></span><br><span class="line">value<span class="string">'s address is @0x1003038b8</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     587     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038d0</span></span><br></pre></td></tr></table></figure><p>可以看出，虽然值相同，但并不是同一个内存块。</p><h3 id="小整数实验"><a href="#小整数实验" class="headerlink" title="小整数实验"></a>小整数实验</h3><p>创建两个相同的小整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="number">1</span></span><br><span class="line">value<span class="string">'s address is @0x100604ce8</span></span><br><span class="line"><span class="string">  value : -5    -4      -3      -2      -1      0       1       2</span></span><br><span class="line"><span class="string">  refcnt : 1    1       1       1       54      389     591     84</span></span><br><span class="line"><span class="string"> block_list count : 9</span></span><br><span class="line"><span class="string"> free_list address : 0x1003038d0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; c=1</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; c</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">value'</span>s address <span class="keyword">is</span> @<span class="number">0x100604ce8</span></span><br><span class="line">  value : <span class="number">-5</span>    <span class="number">-4</span>      <span class="number">-3</span>      <span class="number">-2</span>      <span class="number">-1</span>      <span class="number">0</span>       <span class="number">1</span>       <span class="number">2</span></span><br><span class="line">  refcnt : <span class="number">1</span>    <span class="number">1</span>       <span class="number">1</span>       <span class="number">1</span>       <span class="number">54</span>      <span class="number">389</span>     <span class="number">592</span>     <span class="number">84</span></span><br><span class="line"> block_list count : <span class="number">9</span></span><br><span class="line"> free_list address : <span class="number">0x100303828</span></span><br></pre></td></tr></table></figure><p>可以看出，整数 1 只是增加了引用计数，内存块是同一个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-的面向对象&quot;&gt;&lt;a href=&quot;#Python-的面向对象&quot; class=&quot;headerlink&quot; title=&quot;Python 的面向对象&quot;&gt;&lt;/a&gt;Python 的面向对象&lt;/h2&gt;&lt;p&gt;面向对象编程中，对象是数据以及基于这些数据的操作的集合，实际
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 2.7 源码 - 开始</title>
    <link href="http://www.lyyyuna.com/2017/12/19/python-internal1-begin/"/>
    <id>http://www.lyyyuna.com/2017/12/19/python-internal1-begin/</id>
    <published>2017-12-19T08:20:02.000Z</published>
    <updated>2017-12-19T09:03:27.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p>Python 官网可以下载到<a href="https://www.python.org/downloads/source/" target="_blank" rel="noopener">源码</a>。</p><p>Linux 上编译需要先安装额外模块，例如 Ubuntu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get build-dep python</span><br><span class="line">sudo apt-get install libreadline-dev libsqlite3-dev libbz2-dev libssl-dev libreadline6-dev libsqlite3-dev liblzma-dev libbz2-dev tk8.5-dev blt-dev libgdbm-dev libssl-dev libncurses5-dev zlib1g-dev libncurses5-dev</span><br></pre></td></tr></table></figure><p>Windows 上只需打开 PC/VS9.0/pcbuild.sln，选择最少的模块 python, pythoncore 编译，如果这两个模块编译时报错，只需按照错误提示，钩上所需模块即可。</p><p>Mac 上只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>本系列文章在 Mac 上完成，但环境本身只影响编译，并不影响分析过程，读者选择方便阅读源码的环境即可。</p><h2 id="第一个实验"><a href="#第一个实验" class="headerlink" title="第一个实验"></a>第一个实验</h2><p>Mac 上编译完会生成一个 <code>python.exe</code> 的可执行文件。</p><p>让我们尝试在 Python 源码中修改整数输出的部分，在每一个 int 打印时，输出 <code>hello, world</code>。</p><p>修改 /Objects/intobject.c，添加 <code>fprintf(fp, &quot;hello, world\n&quot;);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">int_print(PyIntObject *v, FILE *fp, <span class="keyword">int</span> flags)</span><br><span class="line">     <span class="comment">/* flags -- not used but required by interface */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> int_val = v-&gt;ob_ival;</span><br><span class="line">    Py_BEGIN_ALLOW_THREADS</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%ld"</span>, int_val);</span><br><span class="line">    Py_END_ALLOW_THREADS</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是实验结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">hello, world</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(1)</span><br><span class="line">hello, world</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(&apos;eee&apos;)</span><br><span class="line">eee</span><br></pre></td></tr></table></figure><p>改动只影响了整数打印的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码编译&quot;&gt;&lt;a href=&quot;#源码编译&quot; class=&quot;headerlink&quot; title=&quot;源码编译&quot;&gt;&lt;/a&gt;源码编译&lt;/h2&gt;&lt;p&gt;Python 官网可以下载到&lt;a href=&quot;https://www.python.org/downloads/source
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python2.7源码" scheme="http://www.lyyyuna.com/tags/Python2-7%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的 descriptor</title>
    <link href="http://www.lyyyuna.com/2017/09/14/python-descriptor/"/>
    <id>http://www.lyyyuna.com/2017/09/14/python-descriptor/</id>
    <published>2017-09-14T08:20:02.000Z</published>
    <updated>2017-11-29T00:19:00.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>通常，一个 descriptor 是具有“绑定行为”的对象属性。所绑定行为可通过 descriptor 协议被自定义的 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 方法重写。如果一个对象的上述三个方法任意一个被重写，则就可被称为 descriptor。</p><p>属性的默认操作是从对象字典中获取、设置和删除一个属性。例如，a.x 有一个查找链，先 <code>a.__dict__[&#39;x&#39;]</code>，若没有则 <code>type(a).__dict__[&#39;x&#39;]</code>，若没有增往上查找父类直到元类。如果查找链中，对象被定义了 descriptor 方法，Python 就会覆盖默认行为。</p><p>Descriptor 是一个强大的工具，虽然开发者不常接触到它，但它其实就是类、属性、函数、方法、静态方法、类方法以及 <code>super()</code> 背后的运行机制。</p><h2 id="Descriptor-协议"><a href="#Descriptor-协议" class="headerlink" title="Descriptor 协议"></a>Descriptor 协议</h2><p>三个方法原型如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">descr.__get__(self, obj, type=None) --&gt; value</span><br><span class="line"></span><br><span class="line">descr.__set__(self, obj, value) --&gt; None</span><br><span class="line"></span><br><span class="line">descr.__delete__(self, obj) --&gt; None</span><br></pre></td></tr></table></figure><p>数据 descriptor 是同时具有 <code>__get__()</code> 和 <code>__set__()</code> 方法的对象，若只有 <code>__get__()</code> 方法，则为非数据 descriptor。如果实例字典中有和数据 descriptor 同名的入口，则数据 descriptor 优先级更高。相反，非数据 descriptor 优先级低。</p><p>让 <code>__set__()</code> 方法抛出异常，就能创建一个只读数据 descriptor。</p><h2 id="调用-descriptor"><a href="#调用-descriptor" class="headerlink" title="调用 descriptor"></a>调用 descriptor</h2><p>descriptor 可以直接通过方法名调用。例如，<code>d.__get__(obj)</code>。</p><p>而通过访问对象属性，自动调用 descriptor 才是更通用的做法。例如，如果 <code>d</code> 定义了方法 <code>__get__()</code>，则 <code>obj.d</code> 会调用 <code>d.__get__(obj)</code>。</p><p>对于对象，<code>b.x</code> 会被转换成 <code>type(b).__dict__[&#39;x&#39;].__get__(b, type(b))</code>。而对于类（是的，类也可以调用），<code>B.x</code> 会被转换成 <code>B.__dict__[&#39;x&#39;].__get__(None, B)</code>。</p><h2 id="Descriptor-例子"><a href="#Descriptor-例子" class="headerlink" title="Descriptor 例子"></a>Descriptor 例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RevealAccess</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""A data descriptor that sets and returns values</span></span><br><span class="line"><span class="string">       normally and prints a message logging their access.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initval=None, name=<span class="string">'var'</span>)</span>:</span></span><br><span class="line">        self.val = initval</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype)</span>:</span></span><br><span class="line">        print(<span class="string">'Retrieving'</span>, self.name)</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, val)</span>:</span></span><br><span class="line">        print(<span class="string">'Updating'</span>, self.name)</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    x = RevealAccess(<span class="number">10</span>, <span class="string">'var "x"'</span>)</span><br><span class="line"><span class="meta">... </span>    y = <span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x = <span class="number">20</span></span><br><span class="line">Updating var <span class="string">"x"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.x</span><br><span class="line">Retrieving var <span class="string">"x"</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.y</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;通常，一个 descriptor 是具有“绑定行为”的对象属性。所绑定行为可通过 descriptor 协议被自定义的 &lt;code&gt;__ge
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Writing Your Own Windows Debugger - Debug Event</title>
    <link href="http://www.lyyyuna.com/2017/05/01/write-a-windows-debugger-02-debug-event/"/>
    <id>http://www.lyyyuna.com/2017/05/01/write-a-windows-debugger-02-debug-event/</id>
    <published>2017-05-01T13:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<p>We have introduced the debug loop last time, in this post, I will talk about various debug events.</p><h3 id="RIP-EVENT"><a href="#RIP-EVENT" class="headerlink" title="RIP_EVENT"></a>RIP_EVENT</h3><p>I find very few documents about this event, only mentioned with words like <em>system error</em> or <em>internal error</em>. So I decide to print a error message and skip it. As my project is not fully tested, I have never<br>encountered such a situation.</p><h3 id="OUTPUT-DEBUG-STRING-EVENT"><a href="#OUTPUT-DEBUG-STRING-EVENT" class="headerlink" title="OUTPUT_DEBUG_STRING_EVENT"></a>OUTPUT_DEBUG_STRING_EVENT</h3><p>When the debuggee calls the <em>OutpuDebugString</em> function, it will raise this debug event. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OUTPUT_DEBUG_STRING_INFO</span> &#123;</span></span><br><span class="line">  LPSTR lpDebugStringData;</span><br><span class="line">  WORD  fUnicode;</span><br><span class="line">  WORD  nDebugStringLength;</span><br><span class="line">&#125; OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;</span><br></pre></td></tr></table></figure><ul><li>lpDebugStringData, The debugging string in the calling process’s address space.</li><li>fUnicode, The format of the debugging string. If this member is zero, the debugging string is ANSI; if it is nonzero, the string is Unicode.</li><li>nDebugStringLength, The size of the debugging string, in characters. The length includes the string’s terminating null character.</li></ul><p>With ReadProcessMemory function, the debugger can obtain the value of the string:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnOutputDebugString</span><span class="params">(<span class="keyword">const</span> OUTPUT_DEBUG_STRING_INFO* pInfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE* pBuffer = (BYTE*)<span class="built_in">malloc</span>(pInfo-&gt;nDebugStringLength);</span><br><span class="line"></span><br><span class="line">    SIZE_T bytesRead;</span><br><span class="line"></span><br><span class="line">    ReadProcessMemory(</span><br><span class="line">        g_hProcess,</span><br><span class="line">        pInfo-&gt;lpDebugStringData,</span><br><span class="line">        pBuffer, </span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        &amp;bytesRead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> requireLen = MultiByteToWideChar(</span><br><span class="line">        CP_ACP,</span><br><span class="line">        MB_PRECOMPOSED,</span><br><span class="line">        (LPCSTR)pBuffer,</span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    TCHAR* pWideStr = (TCHAR*)<span class="built_in">malloc</span>(requireLen * <span class="keyword">sizeof</span>(TCHAR));</span><br><span class="line"></span><br><span class="line">    MultiByteToWideChar(</span><br><span class="line">        CP_ACP,</span><br><span class="line">        MB_PRECOMPOSED,</span><br><span class="line">        (LPCSTR)pBuffer,</span><br><span class="line">        pInfo-&gt;nDebugStringLength,</span><br><span class="line">        pWideStr,</span><br><span class="line">        requireLen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; TEXT(<span class="string">"Debuggee debug string: "</span>) &lt;&lt; pWideStr &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pWideStr);</span><br><span class="line">    <span class="built_in">free</span>(pBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LOAD-DLL-DEBUG-EVENT"><a href="#LOAD-DLL-DEBUG-EVENT" class="headerlink" title="LOAD_DLL_DEBUG_EVENT"></a>LOAD_DLL_DEBUG_EVENT</h3><p>After the debuggee loads a dll, this debug event will be triggered. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LOAD_DLL_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  HANDLE hFile;</span><br><span class="line">  LPVOID lpBaseOfDll;</span><br><span class="line">  DWORD  dwDebugInfoFileOffset;</span><br><span class="line">  DWORD  nDebugInfoSize;</span><br><span class="line">  LPVOID lpImageName;</span><br><span class="line">  WORD   fUnicode;</span><br><span class="line">&#125; LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>You may want to use the member <em>lpImageName</em> to retrieve the dll file name, however, it doesn’t work. According the explaination on MSDN, this member is pointer to the file name of the associated <em>hFile</em>, it  may, in turn, either be NULL or point to the actual filename. Even it is not NULL, ReadProcessMemory may also return a NULL. As a result, this membor is not reliable.</p><p>It seems that there is no direct Windows API to get the filename from the file handle. Someone has tried <a href="http://blog.csdn.net/bodybo/archive/2006/08/28/1131346.aspx" target="_blank" rel="noopener">this way</a>.</p><h3 id="UNLOAD-DLL-DEBUG-EVENT"><a href="#UNLOAD-DLL-DEBUG-EVENT" class="headerlink" title="UNLOAD_DLL_DEBUG_EVENT"></a>UNLOAD_DLL_DEBUG_EVENT</h3><p>When a dll module is unloaded, this event will be triggered, nothing needs handled, just skip it.</p><h3 id="CREATE-PROCESS-DEBUG-EVENT"><a href="#CREATE-PROCESS-DEBUG-EVENT" class="headerlink" title="CREATE_PROCESS_DEBUG_EVENT"></a>CREATE_PROCESS_DEBUG_EVENT</h3><p>After the process is created, this is the first debug event. The following structure describes the detail of this event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CREATE_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  HANDLE                 hFile;</span><br><span class="line">  HANDLE                 hProcess;</span><br><span class="line">  HANDLE                 hThread;</span><br><span class="line">  LPVOID                 lpBaseOfImage;</span><br><span class="line">  DWORD                  dwDebugInfoFileOffset;</span><br><span class="line">  DWORD                  nDebugInfoSize;</span><br><span class="line">  LPVOID                 lpThreadLocalBase;</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress;</span><br><span class="line">  LPVOID                 lpImageName;</span><br><span class="line">  WORD                   fUnicode;</span><br><span class="line">&#125; CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>We can use this structure to get the symbols of the debuggee program.</p><h3 id="EXIT-PROCESS-DEBUG-EVENT"><a href="#EXIT-PROCESS-DEBUG-EVENT" class="headerlink" title="EXIT_PROCESS_DEBUG_EVENT"></a>EXIT_PROCESS_DEBUG_EVENT</h3><p>When debuggee process exits, this event will be triggered. The following structure describe the detail of the event:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXIT_PROCESS_DEBUG_INFO</span> &#123;</span></span><br><span class="line">  DWORD dwExitCode;</span><br><span class="line">&#125; EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;</span><br></pre></td></tr></table></figure><p>What we can do is to print the exit code.</p><h3 id="CREATE-THREAD-DEBUG-EVENT"><a href="#CREATE-THREAD-DEBUG-EVENT" class="headerlink" title="CREATE_THREAD_DEBUG_EVENT"></a>CREATE_THREAD_DEBUG_EVENT</h3><p>It is similar to the process create debug event.</p><h3 id="EXIT-THREAD-DEBUG-EVENT"><a href="#EXIT-THREAD-DEBUG-EVENT" class="headerlink" title="EXIT_THREAD_DEBUG_EVENT"></a>EXIT_THREAD_DEBUG_EVENT</h3><p>It is similar to the process exit debug event.</p><h3 id="EXCEPTION-DEBUG-EVENT"><a href="#EXCEPTION-DEBUG-EVENT" class="headerlink" title="EXCEPTION_DEBUG_EVENT"></a>EXCEPTION_DEBUG_EVENT</h3><p>It is the most important event of our debugger, I will cover it in the next post.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have introduced the debug loop last time, in this post, I will talk about various debug events.&lt;/p&gt;
&lt;h3 id=&quot;RIP-EVENT&quot;&gt;&lt;a href=&quot;#RIP-E
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Windows Debugger" scheme="http://www.lyyyuna.com/tags/Windows-Debugger/"/>
    
  </entry>
  
  <entry>
    <title>Writing Your Own Windows Debugger - Overview</title>
    <link href="http://www.lyyyuna.com/2017/04/27/write-a-windows-debugger-01-overview/"/>
    <id>http://www.lyyyuna.com/2017/04/27/write-a-windows-debugger-01-overview/</id>
    <published>2017-04-27T09:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Debuggers are the apple of the hacker’s eye. We benefit a lot from the debugger, but few of us know the principle of it.</p><p>In the book <em>Gray Hat Python</em> , the author has constructed a simple debugger. However, it is too simple, it is only a machine language level debugger, and can only set basic breakpoints and show CPU register information. We also want to know how to </p><ul><li>Show source code </li><li>Set breakpoint based on lines, not memory address</li><li>Set Step In, Step Out, Step Over</li><li>Show stack trace</li><li>Show global and local variables</li></ul><p>In this Chinese blog <a href="http://www.cnblogs.com/zplutor/archive/2011/03/04/1971279.html" target="_blank" rel="noopener">Zplutor’s</a>, I find a excellent series which has covered most above topics. I decide to write a English blog about it, and I will turn his code into a C++ version.</p><p>Before getting started, let’s make some limitations:</p><ul><li>It is only a user mode debugger.</li><li>It is only a Windows debugger. Although the principle is quite same, but Windows has offered lots of convenient APIs. The implementation will be different on Linux.</li><li>It is only a terminal-based debugger.</li><li>Different from <em>Gray Hat Python</em> , the debugger will be implemented by C++.</li><li>The debuggee program is single thread.</li></ul><p>The modified debugger can be found <a href="https://github.com/lyyyuna/anotherDebugger" target="_blank" rel="noopener">here</a>. It is only tested under Windows 10 + Visual Studio 2013.</p><h2 id="To-Start-the-Debuggee-Program"><a href="#To-Start-the-Debuggee-Program" class="headerlink" title="To Start the Debuggee Program"></a>To Start the Debuggee Program</h2><p>The so-called user mode debugger is to debug the program in user mode. Windows has provided a series of open API for debugging, and they can be devided into three categories:</p><ul><li>API for starting the debuggee program</li><li>API for handling debug event during debug loop</li><li>API for inspecing and modifying debuggee program</li></ul><p>The first thing to do before debugging a program is to start it. On Windows, we use <em>CreateProcess</em> to start to program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO startupinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">startupinfo.cb = <span class="keyword">sizeof</span>(startupinfo);</span><br><span class="line">PROCESS_INFORMATION processinfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> creationflags = DEBUG_ONLY_THIS_PROCESS | CREATE_NEW_CONSOLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CreateProcess(</span><br><span class="line">    <span class="string">"L:\\git_up\\anotherDebugger\\anotherDebugger\\Debug\\test.exe"</span>,</span><br><span class="line">    <span class="comment">//path,</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    FALSE,</span><br><span class="line">    creationflags,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;startupinfo,</span><br><span class="line">    &amp;processinfo) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CreateProcess failed: "</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DEBUG_ONLY_THIS_PROCESS means the subprocess of the debuggee will not be debugged. If you need subprocess, use DEBUG_PROCESS.</li><li>CREATE_NEW_CONSOLE means the debuggee’s and debugger’s output will be separated in two consoles.</li><li>If the debugger process exits, the debuggee will also exit.</li></ul><h2 id="Debugger-loop"><a href="#Debugger-loop" class="headerlink" title="Debugger loop"></a>Debugger loop</h2><p>The debugger loop is a bit like Windows GUI message loop, some operations and exceptions will stop the debuggee and send event to the debugger. We always use </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG_EVENT debugEvent;</span><br><span class="line">WaitForDebugEvent(&amp;debugEvent, INFINITE)</span><br></pre></td></tr></table></figure><p>to capture the debug event.</p><p>There are 9 debug event in total:</p><ul><li>CREATE_PROCESS_DEBUG_EVENT. Reports a create-process debugging event. </li><li>CREATE_THREAD_DEBUG_EVENT. Reports a create-thread debugging event.</li><li>EXCEPTION_DEBUG_EVENT. Reports an exception debugging event.</li><li>EXIT_PROCESS_DEBUG_EVENT. Reports an exit-process debugging event.</li><li>EXIT_THREAD_DEBUG_EVENT. Reports an exit-thread debugging event.</li><li>LOAD_DLL_DEBUG_EVENT. Reports a load-dynamic-link-library (DLL) debugging event.</li><li>OUTPUT_DEBUG_STRING_EVENT. Reports an output-debugging-string debugging event.</li><li>RIP_EVENT. Reports a RIP-debugging event (system debugging error).</li><li>UNLOAD_DLL_DEBUG_EVENT. Reports an unload-DLL debugging event. </li></ul><p>If the debug event has been handled correctly, then</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContinueDebugEvent(debuggeeprocessID, debuggeethreadID, DBG_CONTINUE);</span><br></pre></td></tr></table></figure><p>to continue the debuggee process. Let’s combine the above to construct the debug loop:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (WaitForDebugEvent(&amp;debugEvent, INFINITE) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">    debuggeeprocessID = debugEvent.dwProcessId;</span><br><span class="line">    debuggeethreadID = debugEvent.dwThreadId;</span><br><span class="line">    <span class="keyword">if</span> (dispatchDebugEvent(debugEvent) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        ContinueDebugEvent(debuggeeprocessID, debuggeethreadID, FLAG.continueStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dispatchDebugEvent</span><span class="params">(<span class="keyword">const</span> DEBUG_EVENT &amp; debugEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (debugEvent.dwDebugEventCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> CREATE_PROCESS_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CREATE_THREAD_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXCEPTION_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXIT_PROCESS_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EXIT_THREAD_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> LOAD_DLL_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> UNLOAD_DLL_DEBUG_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OUTPUT_DEBUG_STRING_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RIP_EVENT:</span><br><span class="line">        <span class="comment">// TBD</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unknown debug event."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the next part of the series, I intend to give a brief introduction about the 9 debug events.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Debuggers are the apple of the
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Windows Debugger" scheme="http://www.lyyyuna.com/tags/Windows-Debugger/"/>
    
  </entry>
  
  <entry>
    <title>分布式 B 站用户信息爬虫</title>
    <link href="http://www.lyyyuna.com/2017/04/24/bilibili-users-spider/"/>
    <id>http://www.lyyyuna.com/2017/04/24/bilibili-users-spider/</id>
    <published>2017-04-24T13:20:36.000Z</published>
    <updated>2017-11-29T00:19:00.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周末写了一个 B 站用户信息爬虫，怎么爬网页实在是没什么好讲的，所以这篇描述一下简单的分布式爬虫。</p><p>知乎和 B 站用户爬虫极其类似。它们都有两种爬取策略：</p><ul><li>从一个用户开始，爬取关注者和被关注者，将新找到的用户存储下来，然后再从其关注网络中遍历爬取新的用户。这种爬取策略类似广度优先搜素，根据著名的<a href="http://baike.baidu.com/link?url=w0Tr_YMnE4BHSLk8MN9QBaAlbAUS18BJrlq85ZuhNDYHcN4pQKXg9KIxJ6fMIcW-rr7pQbT3Ya02hlHfiFZVijScjomLbTfhvwwavVAN3XD4GQCjRACiVhza_tndVf0KUjhj1iYrBgvZ6mTe8UCGw_" target="_blank" rel="noopener">六度人脉理论</a>，我们可以将大部分用户都找出来。不过该方法会增加程序的复杂度，你得维护好已搜索用户和未搜索用户的列表，快速去重等。</li><li>大部分网站在建立用户时会使用自增字段，或者有一个字段其值会在特定的数字范围内。对于 B 站，每个人的主页就是很好的例子，<a href="http://space.bilibili.com/8222478/#!/" target="_blank" rel="noopener">http://space.bilibili.com/8222478/#!/</a>。而对于知乎，这个值藏的比较隐秘。后来我发现，当一个用户关注你之后，便会邮件一个关注者链接给你，例如 <a href="http://www.zhihu.com/l/G4gQn" target="_blank" rel="noopener">http://www.zhihu.com/l/G4gQn</a>，最后是一个 16 进制的五位数，大部分用户都是 G，E 等开头的数字。这种链接在知乎正式页面没有发现过，猜测是历史原因保留了这种形式。</li></ul><p>自增数字的方式程序更容易实现。</p><h2 id="换代理的痛点"><a href="#换代理的痛点" class="headerlink" title="换代理的痛点"></a>换代理的痛点</h2><p>剩下的问题就是反爬虫，简单的换 header 头部就不说了，因为 B 站和知乎都是根据 IP 来反爬，那么我能想到的就只有：</p><ul><li>换代理</li><li>分布式爬虫</li></ul><p>从实现方式看，代理也能看作是一个分布式爬虫。根据 HTTP 返回的状态码，可以判断：</p><ul><li>代理是否正常工作（比如连接 timeout），</li><li>对方服务器是否判定我们访问过于频繁（比如返回 403）。</li></ul><p>基于上述判断，可以实现一些复杂的代理切换策略：</p><ul><li>定时去免费代理网站下载新的代理节点，</li><li>负载均衡，将请求平均分配到每一个节点，保证不会访问过于频繁，</li><li>代理探活，将不活跃的代理清除。</li></ul><p>不幸的是，免费好用的代理非常难找，使用 scrapy 配上<a href="https://github.com/lyyyuna/bilibili_papapa/commit/632a8827c187aa051186089d715616db8ae7fd86" target="_blank" rel="noopener">我写的几百行的代理中间件</a>，也很难维持一个正常的下载速率。<br>用 Python 来爬虫几乎是网上教程的标配了 -_-，导致即使找到一个可用代理，其 IP 也早被列入服务器的黑名单。</p><h2 id="分布式爬虫"><a href="#分布式爬虫" class="headerlink" title="分布式爬虫"></a>分布式爬虫</h2><h3 id="基于-HTTP-服务器实现分布式"><a href="#基于-HTTP-服务器实现分布式" class="headerlink" title="基于 HTTP 服务器实现分布式"></a>基于 HTTP 服务器实现分布式</h3><p><img src="https://github.com/lyyyuna/blog_img/raw/master/blog/201704/http_structure.png" alt="基于 HTTP 服务器的分布式爬虫"></p><ul><li>主从之间通信借助现有的 HTTP 协议。</li><li>主控 HTTP 服务器生成用户 id，每当有一个新的 GET 请求，自增 id，并返回给客户端。</li><li>每一个爬虫在这个结构中是一个客户端，当获取到新的 id 后，便去爬取解析网页，将结果以 POST 请求的方式返回给 HTTP 服务器。</li></ul><p>优点是：</p><ul><li>HTTP 协议简单，用 Flask 框架 5 分钟即能快速搭建。</li><li>客户端数量扩展极其方便，且不需要公网 IP。</li><li>爬虫下载速率可由每个客户端各自控制。</li></ul><p>缺点是：</p><ul><li>由于 HTTP 是无状态协议，服务器端不能跟踪一个发布的 id 是否已被正确处理。有可能一个客户端只 GET 而不 POST。需要维护另外的队列来存放未完成的任务。</li><li>HTTP 服务器发布任务是被动的。</li></ul><p>这个链接<a href="https://github.com/lyyyuna/zhihu_user_papapa" target="_blank" rel="noopener">https://github.com/lyyyuna/zhihu_user_papapa</a>里是用这种思路实现的 B 站用户爬虫。</p><h3 id="基于消息队列实现分布式"><a href="#基于消息队列实现分布式" class="headerlink" title="基于消息队列实现分布式"></a>基于消息队列实现分布式</h3><p><img src="https://github.com/lyyyuna/blog_img/raw/master/blog/201704/messagequeue_structure.png" alt="基于消息队列实现分布式爬虫"></p><p>采用消息队列后，Producer 主控侧不再是被动地发布任务，而是主动推送任务。上一小节有的优点消息队列同样拥有，同时</p><ul><li>Producer 也能控制任务发布的速率。</li><li>利用消息队列的持久化能力，可以在意外退出的情况下，记录未能成功发布的任务和未能成功接收的结果。</li></ul><p>这种结构的分布式爬虫，同样需要显示地维护一来一回蓝色红色的数据流，还是稍显复杂。</p><h3 id="基于-Celery-任务队列实现分布式"><a href="#基于-Celery-任务队列实现分布式" class="headerlink" title="基于 Celery 任务队列实现分布式"></a>基于 Celery 任务队列实现分布式</h3><p><img src="https://github.com/lyyyuna/blog_img/raw/master/blog/201704/celery_structure.png" alt="基于 Celery 实现分布式爬虫"></p><p>初看上去，这个结构和上一节没有区别，但是，上图的红色数据流是不需要显示维护的！</p><p>举一个简单例子。假设在机器 A，有如下的 worker</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=<span class="string">'pyamqp://guest@localhost//'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>那么在另一台机器 B，只要运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> add</span><br><span class="line">result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>就能得到结果。同时</p><ul><li>这个被 @app.task 修饰过的方法是异步的。机器 A 可以通过 result.ready() 来来获知任务是否被执行完。通过 result.get() 得到执行的结果。</li></ul><p>基于这个思想，我完成了这个分布式爬虫<a href="https://github.com/lyyyuna/bilibili_papapa" target="_blank" rel="noopener">https://github.com/lyyyuna/bilibili_papapa</a>。只需要 Celery 的 broker 具有公网 IP，然后把程序扔给朋友让他们帮我跑就行。唯一的不便是 Celery worker 在个人电脑上部署不便，而基于 HTTP 的分布式爬虫，我只要 C# 写个 HTTP 客户端生成 exe 就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上周末写了一个 B 站用户信息爬虫，怎么爬网页实在是没什么好讲的，所以这篇描述一下简单的分布式爬虫。&lt;/p&gt;
&lt;p&gt;知乎和 B 站用户爬虫极
      
    
    </summary>
    
      <category term="网络" scheme="http://www.lyyyuna.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Celery" scheme="http://www.lyyyuna.com/tags/Celery/"/>
    
      <category term="爬虫" scheme="http://www.lyyyuna.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用 Supervisor 管理进程</title>
    <link href="http://www.lyyyuna.com/2017/04/08/supervisor01/"/>
    <id>http://www.lyyyuna.com/2017/04/08/supervisor01/</id>
    <published>2017-04-08T09:36:25.000Z</published>
    <updated>2017-11-29T00:19:00.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果需要让某一个进程长期运行，该怎么做？</p><ul><li>开一个终端，SSH 连上之后不关机。</li><li>Shell 命令加一个 &amp;，把进程扔到后台。</li><li>写一个 daemon 进程。</li><li>..</li></ul><p>当终端关闭，终端下所有的进程也会被相应的杀死，即使是被扔到后台执行的 job。然而，要把自己的应用程序专门写成 daemon，会增加开发的负担。这时候，一种万能的、对原应用侵入最小的方法，Supervisor，便走进了我们的视线。</p><p>Supervisor 可不光具有后台长期执行程序的功能。先举两个实际的例子。</p><ul><li>我所在组的产品是一个邮件网关，内含七八个扫描引擎，每种引擎都会起数个进程。为了监控和管理这些进程，我们写了很多 Shell 脚本，并用一个看门狗进程来监控进程对应的 pid 文件，一旦进程意外死亡，会被看门狗拉起来。</li><li>上周末为了写一个 Django + celery + redis 的例子，开了四五个终端，由于是在 virtualenv 下开发的，每次开终端都是一堆重复的 activate 过程。</li></ul><p>这些都可以通过 Supervisor，以类似 rc.d 脚本的方式，一劳永逸的解决。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Supervisor 是由 Python 写的，安装十分简单。</p><pre><code>pip install supervisor</code></pre><p>目前只支持 Python2 (&gt;2.4)。</p><p>不过我建议使用包管理器来安装，例如 ubuntu，</p><pre><code>apt install supervisor</code></pre><p>这样安装完以后会有一个默认的配置文件生成在</p><pre><code>/etc/supervisor/supervisord.conf</code></pre><h2 id="配置一个后台进程"><a href="#配置一个后台进程" class="headerlink" title="配置一个后台进程"></a>配置一个后台进程</h2><p>Supervisor 会按以下顺序搜索配置文件，</p><ul><li>$CWD/supervisord.conf</li><li>$CWD/etc/supervisord.conf</li><li>/etc/supervisord.conf</li><li>/etc/supervisor/supervisord.conf (since Supervisor 3.3.0)</li><li>../etc/supervisord.conf (Relative to the executable)</li><li>../supervisord.conf (Relative to the executable)</li></ul><p>配置文件是 Windows 的 INI 格式，我们撇开其他节，直奔主题 [program:x] </p><p>假设有一个循环打印 hello 的程序，使用 virtualenv 中的 Python 环境运行，现在需要其在后台常驻运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /root/test/hello.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Hello, world.'</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们添加一个 [program:x] 小节为</p><pre><code>[program:hellotest]command = /root/test/venv/bin/python -u hello.pydirectory = /root/testuser = rootstdout_logfile = /root/test/hello.logredirect_stderr = trueautostart = falseautorestart = true</code></pre><p>注意要添加 -u 启动参数，不然 stdout 上的输出会被一直缓存。首先启动 Supervisor 进程本身，安装的时候其本身已经被添加为 Linux 系统的一个 service</p><pre><code># service supervisor start</code></pre><p>然后使用 supervisorctl 工具来启动我们的 hellotest</p><pre><code># supervisorctl start hellotesthellotest: started</code></pre><p>查询 hellotest 的运行状态</p><pre><code># supervisorctl status hellotesthellotest                        RUNNING   pid 898, uptime 0:02:01</code></pre><p>查看 stdout 上的输出</p><pre><code># tailf test/hello.log Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.Hello, world.</code></pre><p>如果我们的参数配置错误，还可以查看 Supervisor 自身的 log</p><pre><code>/var/log/supervisor/supervisor.log</code></pre><h2 id="配置一组后台进程"><a href="#配置一组后台进程" class="headerlink" title="配置一组后台进程"></a>配置一组后台进程</h2><p>配置一组后台进程与之类似，首先我们需要多个 [program:x] 小节</p><pre><code>[program:hellotest]command = /root/test/venv/bin/python -u hello.pydirectory = /root/testuser = rootstdout_logfile = /root/test/hello.logredirect_stderr = trueautorestart = trueautostart = false[program:hellotest2]command = /root/test/venv/bin/python -u hello2.pydirectory = /root/testuser = rootstdout_logfile = /root/test/hello.logredirect_stderr = trueautorestart = trueautostart = false[group:hellogroup]programs = hellotest, hellotest2</code></pre><p>启动一组中所有进程时，命令有些不同</p><pre><code>supervisorctl start hellogroup:*</code></pre><p>一旦一个 program 被加入组中，你就不能再用原先的命令启动</p><pre><code># supervisorctl start hellotesthellotest: ERROR (no such process)# supervisorctl start hellogroup:hellotest</code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>我们可以看一下进程的 pid 号来验证我们的 hello 进程确实是 Supervisor 的子进程</p><pre><code># ps -ef | grep 1182root      1182     1  0 16:07 ?        00:00:00 /usr/bin/python /usr/bin/supervisord -n -c /etc/supervisor/supervisord.confroot      1226  1182  0 16:12 ?        00:00:00 /root/test/venv/bin/python -u hello2.pyroot      1227  1182  0 16:12 ?        00:00:00 /root/test/venv/bin/python -u hello.py</code></pre><p>再用 kill 命令验证 Supervisor 具有看门狗功能</p><pre><code># kill -9 1226# ps -ef | grep 1182root      1182     1  0 16:07 ?        00:00:00 /usr/bin/python /usr/bin/supervisord -n -c /etc/supervisor/supervisord.confroot      1227  1182  0 16:12 ?        00:00:00 /root/test/venv/bin/python -u hello.pyroot      1255  1182  0 16:18 ?        00:00:00 /root/test/venv/bin/python -u hello2.py</code></pre><p>hello2.py 已经是新的 pid 号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果需要让某一个进程长期运行，该怎么做？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开一个终端，SSH 连上之后不关机。&lt;/li&gt;
&lt;li&gt;Shell 命令
      
    
    </summary>
    
      <category term="系统" scheme="http://www.lyyyuna.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>c++ 函数重载是如何实现的</title>
    <link href="http://www.lyyyuna.com/2016/12/22/insidecppmodel2/"/>
    <id>http://www.lyyyuna.com/2016/12/22/insidecppmodel2/</id>
    <published>2016-12-22T12:35:53.000Z</published>
    <updated>2017-11-29T02:08:03.768Z</updated>
    
    <content type="html"><![CDATA[<p>函数重载是 c++ 的编译时多态的一部分，也就是说，该行为在编译完成后即是确定的。事实上，这是编译器和链接器之间玩的小花招。链接器通过符号（symbol）定位各个函数，所谓符号可以简单理解为一个字符串。</p><p>编译器会给每个函数名一个符号，在 c 语言中，符号名只和函数名有关。</p><p>来一个 c 语言程序的例子，使用 Visual Studio 编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 Visual Studio 自带的工具 dumpbin 查看 .obj 文件的符号表</p><pre><code>017 00000000 SECT4  notype ()    External     | _add</code></pre><p>我们换一个函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用 dumpbin 查看 .obj 文件的符号表</p><pre><code>017 00000000 SECT4  notype ()    External     | _add</code></pre><p>还是同样的符号。所以， c 语言编译器不支持函数重载，函数名相同的话，链接器永远只能看到一个名字。</p><p>那么，c++ 呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">add(<span class="built_in">string</span>(<span class="string">"1"</span>), <span class="built_in">string</span>(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用 dumpbin 查看 .obj 文件的符号表</p><pre><code>2F3 00000000 SECT87 notype ()    External     | ?add@@YAXHH@Z (void __cdecl add(int,int))2F4 00000000 SECT89 notype ()    External     | ?add@@YAXNN@Z (void __cdecl add(double,double))2F5 00000000 SECT8B notype ()    External     | ?add@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z (void __cdecl add(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;))</code></pre><p>可以看到，每个符号都不一样啦。这时候的函数声明不仅和函数名有关，也和参数类型有关，但和返回类型无关。符号能唯一确定，编译器自然也能顺利实现重载。</p><p>顺便可以发现，同一个函数声明在 c 和 c++ 中是完全不一样的。这也是为什么 c 和 c++ 之间动静态库不能直接互相调用的原因。为此 cpp 使用了 extern “C” 语法，强制使用 c++ 编译器使用 c 语言的符号命名方法。</p><p>我们实验一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">add(<span class="built_in">string</span>(<span class="string">"1"</span>), <span class="built_in">string</span>(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 .obj 文件的符号表</p><pre><code>2F3 00000000 SECTD3 notype ()    External     | _add2F4 00000000 SECT87 notype ()    External     | ?add@@YAXNN@Z (void __cdecl add(double,double))2F5 00000000 SECT89 notype ()    External     | ?add@@YAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z (void __cdecl add(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;))</code></pre><p>可以看到，第一个函数的符号和 c 语言一致了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数重载是 c++ 的编译时多态的一部分，也就是说，该行为在编译完成后即是确定的。事实上，这是编译器和链接器之间玩的小花招。链接器通过符号（symbol）定位各个函数，所谓符号可以简单理解为一个字符串。&lt;/p&gt;
&lt;p&gt;编译器会给每个函数名一个符号，在 c 语言中，符号名只和
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="cpp" scheme="http://www.lyyyuna.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>c++ 虚函数是如何实现的</title>
    <link href="http://www.lyyyuna.com/2016/12/21/insidecppmodel1/"/>
    <id>http://www.lyyyuna.com/2016/12/21/insidecppmodel1/</id>
    <published>2016-12-21T12:35:53.000Z</published>
    <updated>2017-11-29T00:19:00.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>探索 c++ 对象内部的实现是一件非常有趣的事情。c++ 分为编译时多态和运行时多态。运行时多态依赖于虚函数，大部分人或许听说过虚函数是由虚函数表+虚函数指针实现的，但，真的是这样吗？虽然 c++ 规范有着复杂的语言细节，但底层实现机制却任由编译器厂商想象。（没准某种特殊的处理器电路结构原生支持虚函数，没准这个处理器压根不是冯纽曼型，或者将来厂商发明了比虚函数表更有效率的数据结构。）</p><p>本篇文章就来实际检验一下 Visual Studio 2013 编译器在无优化条件下，虚函数的实现。</p><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>封装把实例的数据和操作结合在了一起，但实例本身只有数据，没有函数，同一个类的函数是共享的。我们通过一个例子来间接证明这一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"heel"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base1 b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b1) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>打印</p><pre><code>4</code></pre><p>如果类中有虚函数，则会在对象中加入一个虚函数指针，该指针指向一个虚函数表，表中是各个虚函数的地址。</p><pre><code>+--------+       +---------+| pvtbl  |------&gt;| vfunc1  |+--------+       +---------+| data1  |       | vfunc2  |+--------+       +---------+| ...    |       | ...     |</code></pre><p>当子类继承父类时，会依次覆盖虚函数表中的各个项，如果子类没有重写某项，那该项就保留。当实例化对象后，虚函数指针就作为一个隐藏数据存在于实例中。如果通过父类指针调用普通成员函数，由于普通函数和类型绑定在一起，所以仍会调用父类成员函数；如果通过父类指针调用虚函数，则会通过对象的虚指针找到虚函数表（即子类的虚函数表），定位虚函数项，实现多态。</p><p>原理是不是很简单？c++ 就是通过这种看似原始的方式实现高级抽象。以上是编译器的通用做法，我手上的 Visual Studio 2013 编译器就是这么做的，为了提高性能，VS 保证虚函数指针存在于对象实例中最前面位置（历史上也有编译器不这么做，好像是 Borland 的？）。</p><h2 id="Visual-Studio-2013-中的实现"><a href="#Visual-Studio-2013-中的实现" class="headerlink" title="Visual Studio 2013 中的实现"></a>Visual Studio 2013 中的实现</h2><p>来一个例子（能这么写是因为我已知了 Visual Studio 2013 编译后对象的内存布局）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func2"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::func3"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::func1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::func3"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b, b1;</span><br><span class="line"><span class="keyword">int</span>** pvirtualtable1 = (<span class="keyword">int</span>**)&amp;b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base object vtbl address: "</span> &lt;&lt; pvirtualtable1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span>** pvirtualtable11 = (<span class="keyword">int</span>**)&amp;b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"another Base object vtbl address: "</span> &lt;&lt; pvirtualtable11[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"function in virtual table"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (Base::func)pvirtualtable1[<span class="number">0</span>][i] != <span class="literal">NULL</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> p = (Base::func)pvirtualtable1[<span class="number">0</span>][i];</span><br><span class="line">p();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span>** pvirtualtable2 = (<span class="keyword">int</span>**)&amp;d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived object vtbl address: "</span> &lt;&lt; pvirtualtable2[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"function in virtual table"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (Base::func)pvirtualtable2[<span class="number">0</span>][i] != <span class="literal">NULL</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> p = (Base::func)pvirtualtable2[<span class="number">0</span>][i];</span><br><span class="line">p();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印</p><pre><code>Base object pvtbl address: 0029DA58another Base object pvtbl address: 0029DA58function address in virtual tableBase::func1Base::func2Base::func3Derived object pvtbl address: 0029DB20function address in virtual tableDerived::func1Base::func2Derived::func3</code></pre><p>可以看到，同一类型不同实例的虚函数表是相同的，继承之后，子类有了自己的虚函数表，表也有相应的更新(Derived::func1, Derived::func3)，表中未重写的项还保留为原值(Base::func2)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;探索 c++ 对象内部的实现是一件非常有趣的事情。c++ 分为编译时多态和运行时多态。运行时多态依赖于虚函数，大部分人或许听说过虚函数是由虚
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="cpp" scheme="http://www.lyyyuna.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Python 访问外围作用域中的变量</title>
    <link href="http://www.lyyyuna.com/2016/09/10/python-nonlocal-variable/"/>
    <id>http://www.lyyyuna.com/2016/09/10/python-nonlocal-variable/</id>
    <published>2016-09-10T13:33:31.000Z</published>
    <updated>2017-11-29T00:19:00.165Z</updated>
    
    <content type="html"><![CDATA[<p>在表达式中引用变量时，Python 会按照如下的顺序遍历各个作用域，寻找该变量：</p><ol><li>当前函数作用域</li><li>任何外围作用域（比如包含当前函数的其他函数）</li><li>global 作用域，即代码所在的模块的作用域</li></ol><p>如果上述作用域内都找不到变量，就会报 NameError 异常。</p><p>但是对变量赋值时，规则会有所不同。</p><ol><li>如果当前作用域变量已存在，那么其值会被替换。</li><li>如果不存在，则会视为在当前作用域定义新变量，而不是向外围作用域中寻找。</li></ol><p>如下函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">    helper()</span><br><span class="line">    <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">function()</span><br></pre></td></tr></table></figure><p>由于 helper 中变量是赋值，这里 flag 输出仍为 True。习惯了 c 语言之类静态类型语言，这种设计起初会感到困惑，但其可以有效地防止局部变量污染函数外的环境。</p><p>需求总是多样的，一定有程序员想在赋值时访问外围作用域。如果是 Python2，他可以这么做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    flag = [<span class="keyword">True</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        flag[<span class="number">0</span>] = <span class="keyword">False</span></span><br><span class="line">    helper()</span><br><span class="line">    <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">function()</span><br></pre></td></tr></table></figure><p>先用 flag[0] 是读操作，产生一次变量引用，寻找到外围作用域中 flag，这时候再赋值 flag[0] = False 便不会新定义变量了。</p><p>如果是 Python3，则可以使用 nonlocal 关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> flag</span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">    helper()</span><br><span class="line">    <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line">function()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在表达式中引用变量时，Python 会按照如下的顺序遍历各个作用域，寻找该变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前函数作用域&lt;/li&gt;
&lt;li&gt;任何外围作用域（比如包含当前函数的其他函数）&lt;/li&gt;
&lt;li&gt;global 作用域，即代码所在的模块的作用域&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
      <category term="语言" scheme="http://www.lyyyuna.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://www.lyyyuna.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Robot Framework 模板与数据驱动测试</title>
    <link href="http://www.lyyyuna.com/2016/07/29/robotframework-template-and-data-driven/"/>
    <id>http://www.lyyyuna.com/2016/07/29/robotframework-template-and-data-driven/</id>
    <published>2016-07-29T11:59:52.000Z</published>
    <updated>2017-11-29T00:19:00.166Z</updated>
    
    <content type="html"><![CDATA[<p>Robot Framework 是关键字驱动的测试框架，虽然关键字驱动高度抽象了底层实现，减少维护成本，降低了对测试人员编程水平的需求，但在某些类型的测试中，数据驱动导向的测试用例比重多，比如常见的用户输入框就有海量的输入可能性。Robot Framework 提供了测试模板，可以将其转换为数据驱动的测试。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>如果有一个接受参数的关键字，那么它就可以被用作模板。下面的例子展示了这一点。</p><pre><code>*** Settings ***Test Setup        PrepareTest Template     Compare Two Number ${one} ${three}*** Test Cases ***Template test case    1    2    1    1    2    3    2    2*** Keywords ***Compare Two Number ${one} ${three}    Should Be Equal    ${one}    ${three}</code></pre><p>这里展示了比较两个数是否相等的例子，可以看到只需填入输入数据即可。你也可以用 [Template] 为每个 Test Case 单独指定模板。</p><h2 id="与循环执行的区别"><a href="#与循环执行的区别" class="headerlink" title="与循环执行的区别"></a>与循环执行的区别</h2><p>有人会问，能否运用循环语句来模拟上述行为呢？</p><p>首先，由于 Robot Framework 是个测试框架，编程能力被弱化不少，模板语法显得简洁 ^_^，然后，在用例中混入过多的执行控制流也不是推荐的行为（或者绝对地说，用例中就不应该有循环、判断语句）。</p><p>其次，模板是处于 continue on failure 模式中，某一项输入 Fail，还会继续执行其他输入。普通 Case 一旦有个语句 Fail，该 Case 就会 tear down。比如上面给的例子，第一行和第二行就会 Fail，实际执行结果如下：</p><pre><code># logStarting test: Testcases.UI Test.Template test case20160729 12:08:56.652 :  FAIL : 1 != 220160729 12:08:56.668 :  FAIL : 2 != 3Ending test:   Testcases.UI Test.Template test case# report========================================================Testcases                                                                                                                                                                ========================================================Testcases.UI Test                                                                                                                                                        ========================================================Template test case                                                                                                                                               | FAIL |Several failures occurred:1) 1 != 22) 2 != 3--------------------------------------------------------Testcases.UI Test                                                                                                                                                | FAIL |1 critical test, 0 passed, 1 failed1 test total, 0 passed, 1 failed========================================================Testcases                                                                                                                                                        | FAIL |1 critical test, 0 passed, 1 failed1 test total, 0 passed, 1 failed========================================================</code></pre><p>单个输入中的 Fail 不会中断执行流。</p><h2 id="一些不足"><a href="#一些不足" class="headerlink" title="一些不足"></a>一些不足</h2><p>这些不足是我自己感受，可能并不准确。</p><p>我自己在自动化测试中使用数据驱动测试方法，只是希望减轻手工编写的工作量，对于执行流上的步骤不想简化。我希望每个输入都能完整地走完一遍 Test Setup | Test Execuation | Test Teardown 过程，遗憾的是好像 Robot Framework 做不到。下面是例子，这里增加了一个 Test Setup。</p><pre><code>*** Settings ***Test Setup        PrepareTest Template     Compare Two Number ${one} ${three}*** Test Cases ***Template test case    1    2    1    1    2    3    2    2*** Keywords ***Compare Two Number ${one} ${three}    Should Be Equal    ${one}    ${three}Prepare    Log    hello, world</code></pre><p>可以看到 hello, world 只打印了一次。</p><pre><code>Starting test: Testcases.UI Test.Template test case20160729 12:08:56.652 :  INFO : hello, world20160729 12:08:56.652 :  FAIL : 1 != 220160729 12:08:56.668 :  FAIL : 2 != 3Ending test:   Testcases.UI Test.Template test case</code></pre><p>这就使得框架对测试输入有要求：输入数据不能对后续输入有影响。一旦在执行过程中有 Fail 发生，就无法用 Test Teardown 恢复测试环境（Run Keyword And Continue On Failure 关键字可能可以解决该问题，但这样写逻辑上并不清晰）。</p><p>使用 Library 导入的标准库和外部库也有问题，测试框架会为每个 Case 生成一个库的实例（即 Python, Java 类的实例），模板中每一行输入都共享一个实例，若是类中有全局变量，便会在各个输入之间产生干扰。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Robot Framework 是关键字驱动的测试框架，虽然关键字驱动高度抽象了底层实现，减少维护成本，降低了对测试人员编程水平的需求，但在某些类型的测试中，数据驱动导向的测试用例比重多，比如常见的用户输入框就有海量的输入可能性。Robot Framework 提供了测试模
      
    
    </summary>
    
      <category term="自动化测试" scheme="http://www.lyyyuna.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="robot framework" scheme="http://www.lyyyuna.com/tags/robot-framework/"/>
    
  </entry>
  
</feed>
