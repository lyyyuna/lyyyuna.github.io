
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>SCons 用户指南第六章 - 依赖 | lyyyuna 的小花园</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="lyyyuna">
    

    
    <meta name="description" content="目前为止，我们看到的都是 SCons 一次性编译的例子。但编译工具一个最主要的功能是只重新编译源码改变的部分，换句话说，SCons 不应该浪费时间重新编译不该编译的内容。比如之前的 hello 例子，你可以调用 SCons 两次看结果的不同： % scons -Q cc -o hello.o -c hello.c cc">
<meta name="keywords" content="scons">
<meta property="og:type" content="article">
<meta property="og:title" content="SCons 用户指南第六章 - 依赖">
<meta property="og:url" content="http://www.lyyyuna.com/2016/01/31/scons6-dependencies/index.html">
<meta property="og:site_name" content="lyyyuna 的小花园">
<meta property="og:description" content="目前为止，我们看到的都是 SCons 一次性编译的例子。但编译工具一个最主要的功能是只重新编译源码改变的部分，换句话说，SCons 不应该浪费时间重新编译不该编译的内容。比如之前的 hello 例子，你可以调用 SCons 两次看结果的不同： % scons -Q cc -o hello.o -c hello.c cc -o hello hello.o % scons -Q scons: `.&amp;a">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-11-29T00:19:00.168Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SCons 用户指南第六章 - 依赖">
<meta name="twitter:description" content="目前为止，我们看到的都是 SCons 一次性编译的例子。但编译工具一个最主要的功能是只重新编译源码改变的部分，换句话说，SCons 不应该浪费时间重新编译不该编译的内容。比如之前的 hello 例子，你可以调用 SCons 两次看结果的不同： % scons -Q cc -o hello.o -c hello.c cc -o hello hello.o % scons -Q scons: `.&amp;a">

    
    <link rel="alternative" href="/atom.xml" title="lyyyuna 的小花园" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="lyyyuna 的小花园" title="lyyyuna 的小花园"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="lyyyuna 的小花园">lyyyuna 的小花园</a></h1>
				<h2 class="blog-motto">动静中之动</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
						<li><a href="/categories">Categories</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/31/scons6-dependencies/" title="SCons 用户指南第六章 - 依赖" itemprop="url">SCons 用户指南第六章 - 依赖</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="lyyyuna" target="_blank" itemprop="author">lyyyuna</a>
		
  <p class="article-time">
    <time datetime="2016-01-31T07:08:54.000Z" itemprop="datePublished"> 发表于 2016-01-31</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#判断输入文件何时改变：Decider-函数"><span class="toc-number">1.</span> <span class="toc-text">判断输入文件何时改变：Decider 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-MD5-签名来决定文件是否改变"><span class="toc-number">1.1.</span> <span class="toc-text">使用 MD5 签名来决定文件是否改变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-MD5-签名的好处"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用 MD5 签名的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用时间戳来判断文件是否改变"><span class="toc-number">1.2.</span> <span class="toc-text">使用时间戳来判断文件是否改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同时使用-MD-签名和时间戳来判断文件是否改变"><span class="toc-number">1.3.</span> <span class="toc-text">同时使用 MD 签名和时间戳来判断文件是否改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写一个自定义的-Decider-方法"><span class="toc-number">1.4.</span> <span class="toc-text">写一个自定义的 Decider 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合使用不同方法来判断一个文件是否改变"><span class="toc-number">1.5.</span> <span class="toc-text">混合使用不同方法来判断一个文件是否改变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#决策函数的历史版本"><span class="toc-number">2.</span> <span class="toc-text">决策函数的历史版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SourceSignature-方法"><span class="toc-number">2.1.</span> <span class="toc-text">SourceSignature 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TargetSignatures-方法"><span class="toc-number">2.2.</span> <span class="toc-text">TargetSignatures 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐式依赖：-CPPPATH-配置变量"><span class="toc-number">3.</span> <span class="toc-text">隐式依赖：$CPPPATH 配置变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存隐式依赖"><span class="toc-number">4.</span> <span class="toc-text">缓存隐式依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#–implicit-deps-changed-选项"><span class="toc-number">4.1.</span> <span class="toc-text">–implicit-deps-changed 选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#–implicit-deps-unchanged-选项"><span class="toc-number">4.2.</span> <span class="toc-text">–implicit-deps-unchanged 选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#显式依赖：Depends-方法"><span class="toc-number">5.</span> <span class="toc-text">显式依赖：Depends 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#来自外部文件的依赖：ParseDepends-方法"><span class="toc-number">6.</span> <span class="toc-text">来自外部文件的依赖：ParseDepends 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忽略依赖：Ignore-函数"><span class="toc-number">7.</span> <span class="toc-text">忽略依赖：Ignore 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按序依赖：Requires-方法"><span class="toc-number">8.</span> <span class="toc-text">按序依赖：Requires 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AlwaysBuild-方法"><span class="toc-number">9.</span> <span class="toc-text">AlwaysBuild 方法</span></a></li></ol>
		
		</div>
		
		<p>目前为止，我们看到的都是 SCons 一次性编译的例子。但编译工具一个最主要的功能是只重新编译源码改变的部分，换句话说，SCons 不应该浪费时间重新编译不该编译的内容。比如之前的 hello 例子，你可以调用 SCons 两次看结果的不同：</p>
<pre><code>% scons -Q
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q
scons: `.&apos; is up to date.
</code></pre><p>第二次执行时，SCons 意识到 hello 程序对于源码来说已经是最新的了，它会拒绝重新编译。你可以通过命令行显式指定程序名来看的更清楚些：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
</code></pre><p>请注意，SCons 报告的 “…is up to date” 是为了避免混淆输出，且只是针对命令行中显式指定的文件名。</p>
<h2 id="判断输入文件何时改变：Decider-函数"><a href="#判断输入文件何时改变：Decider-函数" class="headerlink" title="判断输入文件何时改变：Decider 函数"></a>判断输入文件何时改变：Decider 函数</h2><p>编译工具的一个重要方面是在输入文件改变时能发现并重新编译，从而保证软件实时更新。SCons 默认使用 MD5 签名或校验和来跟踪文件内容，也可以使用修改时间戳来跟踪。你甚至可以指定 Python 函数来决定文件是否改变。</p>
<h3 id="使用-MD5-签名来决定文件是否改变"><a href="#使用-MD5-签名来决定文件是否改变" class="headerlink" title="使用 MD5 签名来决定文件是否改变"></a>使用 MD5 签名来决定文件是否改变</h3><p>SCons 默认使用 MD5 签名而不是文件的修改时间来跟踪文件的内容。这意味着，如果你习惯基于文件修改时间来重编译，你会有点不习惯。我们用 touch 命令做个例子：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
% touch hello.c
% scons -Q hello
scons: `hello&apos; is up to date.
</code></pre><p>可以看到，即使改过时间，SCons 仍然能够判断出文件内容并没有改变，也就避免了 hello 的再次编译。又比如有人修改了文件，但文件内容没改变，这时候也不会重新编译。但当文件内容真的改变了，SCons 就能够检查到并重新编译：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
%     [CHANGE THE CONTENTS OF hello.c]
% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
</code></pre><p>请注意，如果你愿意，你可以用 Decider 方法来显式地指定默认的行为（比如 MD5 签名）：</p>
<pre><code>Program(&apos;hello.c&apos;)
Decider(&apos;MD5&apos;)
</code></pre><p>你也可以用 ‘MD5’ 的同义词 ‘content’。</p>
<h4 id="使用-MD5-签名的好处"><a href="#使用-MD5-签名的好处" class="headerlink" title="使用 MD5 签名的好处"></a>使用 MD5 签名的好处</h4><p>用 MD5 签名来判定内容是否改变带来一个很大的好处：那就是如果一个源文件重新编译后的二进制文件没有改变，则其下游依赖于此的目标文件就不需要重编译。</p>
<p>举例来说，用户如果只是更改了源文件的一个注释，那么重新编译的 hello.o 文件会和之前的完全一致（假设编译器没有做手脚）。SCons 这时候就不会重新编译 hello.o：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
%   [CHANGE A COMMENT IN hello.c]
% scons -Q hello
cc -o hello.o -c hello.c
scons: `hello&apos; is up to date.
</code></pre><p>本质上，当 SCons 意识到文件没有改变时，会对其他依赖于此的编译行为作“短路”处理。虽然分析目标文件（hello.o）内容会花费一些时间，但相比于漫长的编译时间无疑有很高的性价比。</p>
<h3 id="使用时间戳来判断文件是否改变"><a href="#使用时间戳来判断文件是否改变" class="headerlink" title="使用时间戳来判断文件是否改变"></a>使用时间戳来判断文件是否改变</h3><p>你也可以使用时间戳，而不是文件内容来决定是否重编译。SCons 有两种使用时间戳的方法来判断输入文件是否改变。</p>
<p>最常用的时间戳判断法和 Make 类似：那就是，如果源文件的修改时间比目标文件更新，就重编译。参照如下的调用 Decider 方法：</p>
<pre><code>Object(&apos;hello.c&apos;)
Decider(&apos;timestamp-newer&apos;)
</code></pre><p>这种模式下，SCons 有点像 Make，可以用 touch 命令来验证这一点：</p>
<pre><code>% scons -Q hello.o
cc -o hello.o -c hello.c
% touch hello.c
% scons -Q hello.o
cc -o hello.o -c hello.c
</code></pre><p>实际上正因为其行为和 Make 类似，你也可以用 ‘make’ 字符串来代替 ‘timestamp-newer’：</p>
<pre><code>Object(&apos;hello.c&apos;)
Decider(&apos;make&apos;)
</code></pre><p>类似于 Make 的时间戳方法有一个缺点，那就是如果一个输入文件的修改时间比目标文件早，那么目标文件不会重编译。比如你从备份库中恢复源文件就会触发这种行为。恢复的源文件其内容很有可能发生改变，但由于修改时间早于目标文件，也就自然不会重编译。</p>
<p>不过 SCons 能够在每次编译的时候记录源文件的时间戳，只要时间戳不同就会出发重编译。这样即使新的源文件比目标文件还要早，也能轻松应对。你可以使用 ‘timestamp-match’ 参数让 SCons 使用这种模式：</p>
<pre><code>Object(&apos;hello.c&apos;)
Decider(&apos;timestamp-match&apos;)
</code></pre><p>在这种模式下，只要源文件时间戳改变，就会重编译。所以即使我们用 touch -t 选项来将源文件改成一个老的时间（1989.1.1），SCons 仍然会充编译：</p>
<pre><code>% scons -Q hello.o
cc -o hello.o -c hello.c
% touch -t 198901010000 hello.c
% scons -Q hello.o
cc -o hello.o -c hello.c
</code></pre><p>通常，用 timestamp-newer 的唯一理由是，你可能有一些特殊需求：改动会来自老文件。</p>
<h3 id="同时使用-MD-签名和时间戳来判断文件是否改变"><a href="#同时使用-MD-签名和时间戳来判断文件是否改变" class="headerlink" title="同时使用 MD 签名和时间戳来判断文件是否改变"></a>同时使用 MD 签名和时间戳来判断文件是否改变</h3><p>处于性能的原因，SCons 提供了折中的方法：只对时间戳改变的文件作 MD5 校验。向 Decider 方法传递 ‘MD5-timestamp’ 参数：</p>
<pre><code>Program(&apos;hello.c&apos;)
Decider(&apos;MD5-timestamp&apos;)
</code></pre><p>这样配置之后，其行为会类似于 ‘MD5’ 参数：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
% touch hello.c
% scons -Q hello
scons: `hello&apos; is up to date.
% edit hello.c
    [CHANGE THE CONTENTS OF hello.c]
% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
</code></pre><p>不过，可以看到，第二个 SCons 调用仅会查看 hello.c 文件的修改时间，而不需要打开文件并计算 MD5 校验和。这种行为能够显著地加速编译。</p>
<p>不过缺点是，如果文件在一秒钟之内完成修改，那么 SCons 就不会去重编译它。当然实际开发编程时，基本不会有人这么快完成源文件的修改动作。不过一些编译脚本或者持续集成工具会自动修改文件，这种行为会非常快，这时候 Decider(‘MD5-timestamp’) 就不合适了。</p>
<h3 id="写一个自定义的-Decider-方法"><a href="#写一个自定义的-Decider-方法" class="headerlink" title="写一个自定义的 Decider 方法"></a>写一个自定义的 Decider 方法</h3><p>传递给 Decider 方法的不同字符串，会让 SCons 采用各种内置函数来分析目标文件的依赖（通常是源文件）。当然啦，你也可以自己写一个函数来分析依赖有没有发生变化。</p>
<p>比如，假设我们有很多特定格式的数据在同一个文件中，用来生成不同的目标文件，但每一个目标文件只是依赖于某几个数据。我们想建立这种特定的依赖行为。然而，由于数据太多，我们只想在时间戳改变的时候才去分析输入文件。这时候我们就可以写一个自定义的 Decider 方法：</p>
<pre><code>Program(&apos;hello.c&apos;)
def decide_if_changed(dependency, target, prev_ni):
    if self.get_timestamp() != prev_ni.timestamp:
        dep = str(dependency)
        tgt = str(target)
        if specific_part_of_file_has_changed(dep, tgt):
            return True
    return False
Decider(decide_if_changed)
</code></pre><p>请注意在函数定义中，dependency 是第一个参数，然后是 target。这两个参数都是 SCons 的 Node 节点，紧接会用 str() 函数将其转为字符串。</p>
<p>第三个参数 prev_ni 是上次目标文件编译时依赖的签名或时间戳信息。实际上 prev_ni 可以按需求包含各种不同信息。对于普通文件，prev_ni 对象有着以下的属性：</p>
<ul>
<li>.csig 是目标文件上次编译时其依赖的内容签名，或称之为 MD5 签名。</li>
<li>.size 依赖文件的二进制字节数。</li>
<li>.timestamp 依赖文件上次的修改时间。</li>
</ul>
<p>请注意，在 Decider 方法中忽略一些参数是常见的做法，且不会影响编译行为。</p>
<p>另一事需要注意，在第一次运行 SCons 前，三个属性并不都是初始化过的。比如 .sconsign DB 文件在没有目标文件之前不会存在。所以，你必须每次都检查一下 prev_ni 属性的可用性。</p>
<p>最终我们得到一个基于 csig 的决策函数的例子。请注意每次调用，依赖文件的签名信息必须通过 get_csig 函数来初始化（这是手动的！）。</p>
<pre><code>env = Environment()

def config_file_decider(dependency, target, prev_ni):
    import os.path

    # We always have to init the .csig value...
    dep_csig = dependency.get_csig()
    # .csig may not exist, because no target was built yet...
    if &apos;csig&apos; not in dir(prev_ni):
        return True
    # Target file may not exist yet
    if not os.path.exists(str(target.abspath)):
        return True
    if dep_csig != prev_ni.csig:
        # Some change on source file =&gt; update installed one
        return True
    return False

def update_file():
    f = open(&quot;test.txt&quot;,&quot;a&quot;)
    f.write(&quot;some line\n&quot;)
    f.close()

update_file()

# Activate our own decider function
env.Decider(config_file_decider)

env.Install(&quot;install&quot;,&quot;test.txt&quot;)
</code></pre><h3 id="混合使用不同方法来判断一个文件是否改变"><a href="#混合使用不同方法来判断一个文件是否改变" class="headerlink" title="混合使用不同方法来判断一个文件是否改变"></a>混合使用不同方法来判断一个文件是否改变</h3><p>上一个例子展现了如何使用全局 Decider 方法来解决依赖问题。有时候你会希望对不同目标文件应用不同的决策方法。这时候你可以使用 env.Decider 方法，这样就只会对特定的编译环境产生影响。</p>
<p>举例来说，我们希望在一次编译中使用 MD5 校验，并在另一次编译中对相同的源文件使用时间戳，那么你就可以这样：</p>
<pre><code>env1 = Environment(CPPPATH = [&apos;.&apos;])
env2 = env1.Clone()
env2.Decider(&apos;timestamp-match&apos;)
env1.Program(&apos;prog-MD5&apos;, &apos;program1.c&apos;)
env2.Program(&apos;prog-timestamp&apos;, &apos;program2.c&apos;)
</code></pre><p>假设两次编译都包含了 inc.h 文件，那么更新 inc.h 的修改时间（用 touch 命令）就会触发不同的重编译行为：</p>
<pre><code>% scons -Q
cc -o program1.o -c -I. program1.c
cc -o prog-MD5 program1.o
cc -o program2.o -c -I. program2.c
cc -o prog-timestamp program2.o
% touch inc.h
% scons -Q
cc -o program2.o -c -I. program2.c
cc -o prog-timestamp program2.o
</code></pre><h2 id="决策函数的历史版本"><a href="#决策函数的历史版本" class="headerlink" title="决策函数的历史版本"></a>决策函数的历史版本</h2><p>现在的 SCons 版本仍然支持两个曾经主要的决策函数。它们被官方加入 2.0 版本，但现在已经不鼓励使用，因为它们在源文件和目标文件之间建立了一种令人费解的决策行为。现在你只可能在维护旧版本的 SConscript 文件中才会碰到它们。</p>
<h3 id="SourceSignature-方法"><a href="#SourceSignature-方法" class="headerlink" title="SourceSignature 方法"></a>SourceSignature 方法</h3><p>SourceSignature 方法非常直接，支持两种决策方法，第一个就是 MD5 签名法：</p>
<pre><code>Program(&apos;hello.c&apos;)
SourceSignatures(&apos;MD5&apos;)
</code></pre><p>另一个是时间戳：</p>
<pre><code>Program(&apos;hello.c&apos;)
SourceSignatures(&apos;timestamp&apos;)
</code></pre><p>它们分别和 Decider(‘MD5’) 和 Decider(‘timestamp-match’) 很像，但是在这种行为之下，SCons 只能依赖于源文件的变化，即那些不是从其他文件生成的文件。</p>
<h3 id="TargetSignatures-方法"><a href="#TargetSignatures-方法" class="headerlink" title="TargetSignatures 方法"></a>TargetSignatures 方法</h3><p>当一个目标文件本身被作为其它目标的文件的依赖时，可以用 TargetSignature 方法来决定 SCons 的行为。也就是说，TargetSignature 方法可以配置那些最终目标依赖的临时二进制文件。</p>
<p>TargetSignature 方法同样支持 ‘MD5’ 和 ‘timestamp’ 两个参数，其意义和上节所述是一致的。这个例子中：</p>
<pre><code>Program(&apos;hello.c&apos;)
TargetSignatures(&apos;MD5&apos;)
</code></pre><p>hello.o 的 MD5 签名将决定最终程序 hello 是否被重编译。在下面的例子中：</p>
<pre><code>Program(&apos;hello.c&apos;)
TargetSignatures(&apos;timestamp&apos;)
</code></pre><p>hello.o 的时间戳将决定最终程序 hello 是否被重编译。     </p>
<p>TargetSignatures 方法还支持 ‘source’ 和 ‘build’ 两个额外的参数。’source’ 参数指定了目标文件和源文件使用同样的决策行为（即和 SourceSignature 一样）。所以在这个例子中：</p>
<pre><code>Program(&apos;hello.c&apos;)
TargetSignatures(&apos;source&apos;)
SourceSignatures(&apos;timestamp&apos;)
</code></pre><p>所有目标和源文件都将使用修改时间戳来判断是否改变。</p>
<p>最后，’build’ 参数指定了 SCons 必须检察目标文件的编译状态，如果一个目标文件被重编译了，在不检查其内容或时间戳的情况下，所有依赖于此的下游目标文件也应该重编译。如果没有重编译，则使用 SourceSignature 重复上节的行为。</p>
<p>这其实是模仿了更早 SCons 版本的 build signatures 行为。build signatures 会合并所有输入文件的签名，这样就不需要计算目标文件的 MD5 签名。虽然在某些配置下能提高性能，但远不如 Decider(‘MD5-timestamp’) 高效。</p>
<h2 id="隐式依赖：-CPPPATH-配置变量"><a href="#隐式依赖：-CPPPATH-配置变量" class="headerlink" title="隐式依赖：$CPPPATH 配置变量"></a>隐式依赖：$CPPPATH 配置变量</h2><p>假设我们的 “Hello, World!” 程序用 #include 包含了 hello.h 头文件：</p>
<pre><code>#include &lt;hello.h&gt;
int
main()
{
    printf(&quot;Hello, %s!\n&quot;, string);
}
</code></pre><p>hello.h 中内容为：</p>
<pre><code>#define string    &quot;world&quot;
</code></pre><p>在这个例子中，我们希望 SCons 在发现 hello.h 内容改变时，能重编译。为此，我们需要修改 SConstruct 文件：</p>
<pre><code>Program(&apos;hello.c&apos;, CPPPATH = &apos;.&apos;)
</code></pre><p>$CPPPATH 告诉 SCons 去当前目录寻找源程序包含的头文件。这时候：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c -I. hello.c
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
%     [CHANGE THE CONTENTS OF hello.h]
% scons -Q hello
cc -o hello.o -c -I. hello.c
cc -o hello hello.o
</code></pre><p>首先可以注意到，SCons 添加了 $CPPPATH 变量所指定的 -I. 参数，这样编译时能够在本地目录的 hello.h 文件。</p>
<p>然后，SCons 会扫描 hello.c 包含的 hello.h 内容来决定是否重编译。SCons 会将这标记为目标文件的隐式依赖，所有依赖于 hello.c 和 hello.h 的文件都会被重编译。</p>
<p>像 $LIBPATH 变量那样，$CPPPATH 变量可以是一些目录路径的列表，或者是目录路径分割的字符串（在 POSIX/Linux 上是 ‘:’，在 Windows 上是 ‘;’）。这两个方法都能使 SCons 产生正确的编译选项：</p>
<pre><code>Program(&apos;hello.c&apos;, CPPPATH = [&apos;include&apos;, &apos;/home/project/inc&apos;])
</code></pre><p>在 POSIX 或 Linux 系统上：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c -Iinclude -I/home/project/inc hello.c
cc -o hello hello.o
</code></pre><p>在 Windows 上：</p>
<pre><code>C:\&gt;scons -Q hello.exe
cl /Fohello.obj /c hello.c /nologo /Iinclude /I\home\project\inc
link /nologo /OUT:hello.exe hello.obj
embedManifestExeCheck(target, source, env)
</code></pre><h2 id="缓存隐式依赖"><a href="#缓存隐式依赖" class="headerlink" title="缓存隐式依赖"></a>缓存隐式依赖</h2><p>扫描每个 #include 文件会耗费额外的时间。当构建大型系统时，扫描时间只占了一小部分的编译时间。但重编译部分组件时，扫描占据的时间就非常可观，在真正编译前，SCons 会花费大量的时间判断所有依赖是否是最新的。</p>
<p>实际中，错误的依赖中会浪费 SCons 扫描时间只是一个小问题。然而，等待时间通常让开发人员不能忍。因此，SCons 允许你缓存依赖关系，下次编译可以直接使用。你只需要在命令行中指定 –implicit-cache 选项：</p>
<pre><code>% scons -Q --implicit-cache hello
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
</code></pre><p>如果你不想每次在命令行指定 –implicit-cache 选项，你可以在 SConscript 文件中设置 implicit_cache ，使其成为默认行为：</p>
<pre><code>SetOption(&apos;implicit_cache&apos;, 1)
</code></pre><p>SCons 默认不缓存隐式依赖，因为当依赖发生改变后，SCons 不能及时发现变化。具体来说，在以下情况，–implicit-cache 选项会导致重编译失败：</p>
<ul>
<li>当使用 –implicit-cache 选项，SCons 会忽略如 $CPPPATH 或 $LIBPATH 路径中的任何变化，比如不同目录的同名文件。</li>
<li>当使用 –implicit-cache 选项，如果一个和之前同名的文件被加入到路径中，SCons 就无法检测到变化。</li>
</ul>
<h3 id="–implicit-deps-changed-选项"><a href="#–implicit-deps-changed-选项" class="headerlink" title="–implicit-deps-changed 选项"></a>–implicit-deps-changed 选项</h3><p>在使用隐式依赖关系时，有时你想重新扫描文件以重建缓存。比如说，你项目编译依赖的一个外部库最近有了更新，这时候缓存的隐式依赖就过时了。你可以通过 –implicit-deps-changed 选项来更新缓存：</p>
<pre><code>% scons -Q --implicit-deps-changed hello
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
</code></pre><p>在这个例子中，SCons 会重新扫描隐式依赖并更新缓存。</p>
<h3 id="–implicit-deps-unchanged-选项"><a href="#–implicit-deps-unchanged-选项" class="headerlink" title="–implicit-deps-unchanged 选项"></a>–implicit-deps-unchanged 选项</h3><p>在建立缓存时，SCons 默认会区分那些修改过的文件。然而有时，即使源文件发生变化，你仍然想强制 SCons 使用缓存中的依赖。在 #include 包含的头文件没变化，而只是源文件做了修改的情况下，这可以加速编译过程。在下面这个例子中，你可以使用 –implicit-deps-unchanged 选项：</p>
<pre><code>% scons -Q --implicit-deps-unchanged hello
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
</code></pre><p>这里，SCons 假设缓存是最新的，且不会去重新扫描文件。但实际是，对于持续的微小代码改动，这样虽然减少了编译时间，但有可能却让产品错过了显著的性能提升。</p>
<h2 id="显式依赖：Depends-方法"><a href="#显式依赖：Depends-方法" class="headerlink" title="显式依赖：Depends 方法"></a>显式依赖：Depends 方法</h2><p>有时候，SCons 不能发现文件的依赖。在这种情况下，就需要你显式地定义文件之间的依赖关系，才能在文件改动后触发重编译。这通过 Depends 方法来实现：</p>
<pre><code>hello = Program(&apos;hello.c&apos;)
Depends(hello, &apos;other_file&apos;)

% scons -Q hello
cc -c hello.c -o hello.o
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
% edit other_file
    [CHANGE THE CONTENTS OF other_file]
% scons -Q hello
cc -c hello.c -o hello.o
cc -o hello hello.o
</code></pre><p>请注意，Depends 的依赖（即第二个参数）也可以是节点对象的列表：</p>
<pre><code>hello = Program(&apos;hello.c&apos;)
goodbye = Program(&apos;goodbye.c&apos;)
Depends(hello, goodbye)
</code></pre><p>这样，依赖将先于目标文件生成：</p>
<pre><code>% scons -Q hello
cc -c goodbye.c -o goodbye.o
cc -o goodbye goodbye.o
cc -c hello.c -o hello.o
cc -o hello hello.o
</code></pre><h2 id="来自外部文件的依赖：ParseDepends-方法"><a href="#来自外部文件的依赖：ParseDepends-方法" class="headerlink" title="来自外部文件的依赖：ParseDepends 方法"></a>来自外部文件的依赖：ParseDepends 方法</h2><p>SCons 对不同语言有不同的内置扫描器。但由于扫描器实现的不足，有时候不能提取出特定的隐式依赖关系。</p>
<p>下面是一个扫描 C 语言头文件失败的例子：</p>
<pre><code>#define FOO_HEADER &lt;foo.h&gt;
#include FOO_HEADER

int main() {
    return FOO;
}

% scons -Q
cc -o hello.o -c -I. hello.c
cc -o hello hello.o
%    [CHANGE CONTENTS OF foo.h]
% scons -Q
scons: `.&apos; is up to date.
</code></pre><p>很显然扫描器无法分析头文件的依赖。因为不是一个完整的 C 预处理器，扫描器无法展开宏。</p>
<p>在这些情况下，你也许会求助编译器来提取隐式依赖关系。ParseDepends 方法能够解析编译器的 Make 风格的输出，并显式地建立起所有依赖项。</p>
<p>下面这个例子使用 ParseDepends 来处理编译器产生的依赖文件，而这些依赖文件其实是编译时的副产物：</p>
<pre><code>obj = Object(&apos;hello.c&apos;, CCFLAGS=&apos;-MD -MF hello.d&apos;, CPPPATH=&apos;.&apos;)
SideEffect(&apos;hello.d&apos;, obj)
ParseDepends(&apos;hello.d&apos;)
Program(&apos;hello&apos;, obj)

% scons -Q
cc -o hello.o -c -MD -MF hello.d -I. hello.c
cc -o hello hello.o
%    [CHANGE CONTENTS OF foo.h]
% scons -Q
cc -o hello.o -c -MD -MF hello.d -I. hello.c
</code></pre><p>解析编译器产生的 .d 依赖文件会导致鸡生蛋-蛋生鸡的问题。也就是不必要的重编译问题：</p>
<pre><code>% scons -Q
cc -o hello.o -c -MD -MF hello.d -I. hello.c
cc -o hello hello.o
% scons -Q --debug=explain
scons: rebuilding `hello.o&apos; because `foo.h&apos; is a new dependency
cc -o hello.o -c -MD -MF hello.d -I. hello.c
% scons -Q
scons: `.&apos; is up to date.
</code></pre><p>在第一次运行时，依赖文件随二进制文件一起产生。因为此时 SCons 并不清楚目标文件依赖于 foo.h。在第二次运行的时候，二进制文件被重编译，因为此时 foo.h 被确认为一个新的依赖。</p>
<p>ParseDepends 在启动时立即读入指定的文件，并判断出文件是否存在。而编译过程产生的依赖文件不会再被自动解析。因此，在同一次编译中，编译器提取的依赖关系不会被存入签名数据库中。这个不足导致 ParseDepends 会带来不必要的重编译行为。因此，应只在 SCons 的扫描器不足以应付时使用这个功能。</p>
<h2 id="忽略依赖：Ignore-函数"><a href="#忽略依赖：Ignore-函数" class="headerlink" title="忽略依赖：Ignore 函数"></a>忽略依赖：Ignore 函数</h2><p>有时候即使依赖改变也不想重编译程序，你就需要向 SCons 指定要忽略的文件：</p>
<pre><code>hello_obj=Object(&apos;hello.c&apos;)
hello = Program(hello_obj)
Ignore(hello_obj, &apos;hello.h&apos;)

% scons -Q hello
cc -c -o hello.o hello.c
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
% edit hello.h
[CHANGE THE CONTENTS OF hello.h]
% scons -Q hello
scons: `hello&apos; is up to date.
</code></pre><p>现在，上面的例子有点不自然，因为实际开发中很难想象在 hello.h 改变后，不需要重编译 hello。更现实的例子是，hello 所在的目录被不同系统所共享，但每个系统的 stdio.h 头文件都不相同。如果不作设置，那么在切换系统的时候，SCons 就会误以为头文件改变而触发重编译行为。为了避免此问题，可以作如下改动：</p>
<pre><code>hello = Program(&apos;hello.c&apos;, CPPPATH=[&apos;/usr/include&apos;])
Ignore(hello, &apos;/usr/include/stdio.h&apos;)
</code></pre><p>Ignore 方法还可以避免默认的编译行为。这是因为目录实际上依赖于其内部内容。如果想避免某个文件被默认编译，可以指定目录忽略特定文件。请注意，当用户在命令行指定需要目标文件时，还是会触发编译行为。或者其他依赖于此该文件的文件被要求编译时，也会编译该文件。</p>
<pre><code>hello_obj=Object(&apos;hello.c&apos;)
hello = Program(hello_obj)
Ignore(&apos;.&apos;,[hello,hello_obj])

% scons -Q
scons: `.&apos; is up to date.
% scons -Q hello
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q hello
scons: `hello&apos; is up to date.
</code></pre><h2 id="按序依赖：Requires-方法"><a href="#按序依赖：Requires-方法" class="headerlink" title="按序依赖：Requires 方法"></a>按序依赖：Requires 方法</h2><p>偶尔的，你可能需要修改某些文件和目录，且它们被目标文件所依赖，但这些改变对目标文件来说没有影响，你不希望这些改变触发重编译行为。这种关系称为按序依赖，因为只有目标文件之前的依赖关系发生了改变。这样的依赖关系导致的改变并不一定需要传递到目标文件。</p>
<p>举例来说，你需要在每次编译时产生一个文件来记录编译时长、版本信息等。很显然这个文件的内容每次都不同。如果你的 SCons 配置成普通的依赖决策，那么每次都会导致重编译行为。为了演示该行为，可以用 Python 生成一个 version.c 文件，然后让原程序链接此文件，最后在生成目标文件时打印其中的字符串：</p>
<pre><code>import time

version_c_text = &quot;&quot;&quot;
char *date = &quot;%s&quot;;
&quot;&quot;&quot; % time.ctime(time.time())
open(&apos;version.c&apos;, &apos;w&apos;).write(version_c_text)

hello = Program([&apos;hello.c&apos;, &apos;version.c&apos;])
</code></pre><p>如果 version.c 是一个实际的源文件那么显然每次 version.o 都会重编译，接着会导致 hello 每次也跟着重编译：</p>
<pre><code>% scons -Q hello
cc -o hello.o -c hello.c
cc -o version.o -c version.c
cc -o hello hello.o version.o
% sleep 1
% scons -Q hello
cc -o version.o -c version.c
cc -o hello hello.o version.o
% sleep 1
% scons -Q hello
cc -o version.o -c version.c
cc -o hello hello.o version.o
</code></pre><p>（请注意，需要 sleep 一秒钟来正确使用上述这个例子）</p>
<p>一个解决方法是使用 Requires 方法，指定 version.o 的改变只有在目标程序需要链接时，才会导致重编译行为：</p>
<pre><code>import time

version_c_text = &quot;&quot;&quot;
char *date = &quot;%s&quot;;
&quot;&quot;&quot; % time.ctime(time.time())
open(&apos;version.c&apos;, &apos;w&apos;).write(version_c_text)

version_obj = Object(&apos;version.c&apos;)

hello = Program(&apos;hello.c&apos;,
                LINKFLAGS = str(version_obj[0]))

Requires(hello, version_obj)
</code></pre><p>请注意，虽然我们不再将 version.c 作为源文件之一，我们还是需要提取文件名作为 $LINKFLAGS 变量，才会触发编译器链接行为。</p>
<p>当做出上述改变后，hello 可执行程序只有在 hello.c 改变时才会重编译，而 version.o 的重编译（因为 SConstruct 每次都会改变 version.c 的内容）不会触发最终程序的重编译：</p>
<pre><code>% scons -Q hello
cc -o version.o -c version.c
cc -o hello.o -c hello.c
cc -o hello version.o hello.o
% sleep 1
% scons -Q hello
cc -o version.o -c version.c
scons: `hello&apos; is up to date.
% sleep 1
%     [CHANGE THE CONTENTS OF hello.c]
% scons -Q hello
cc -o version.o -c version.c
cc -o hello.o -c hello.c
cc -o hello version.o hello.o
% sleep 1
% scons -Q hello
cc -o version.o -c version.c
scons: `hello&apos; is up to date.
</code></pre><h2 id="AlwaysBuild-方法"><a href="#AlwaysBuild-方法" class="headerlink" title="AlwaysBuild 方法"></a>AlwaysBuild 方法</h2><p>最后，还可以通过 AlwaysBuild 方法来影响 SCons 处理依赖的行为。当一个文件被传入 AlwaysBuild 方法：</p>
<pre><code>hello = Program(&apos;hello.c&apos;)
AlwaysBuild(hello)
</code></pre><p>每次编译目标文件时，该源文件都会被认为是过时的，所有依赖路径上的文件都会被重编译：</p>
<pre><code>% scons -Q
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q
cc -o hello hello.o
</code></pre><p>AlwaysBuild 这个名字有歧义，因为它并不意味着目标文件每次都会重编译。而是说每次在命令行指定该目标文件时，会触发重编译行为。所以假如在命令行指定其他的目标文件，那么它只有在真正过时时才会被重编译：</p>
<pre><code>% scons -Q
cc -o hello.o -c hello.c
cc -o hello hello.o
% scons -Q hello.o
scons: `hello.o&apos; is up to date.
</code></pre>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/杂/">杂</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/scons/">scons</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://www.lyyyuna.com/2016/01/31/scons6-dependencies/" data-title="SCons 用户指南第六章 - 依赖 | lyyyuna 的小花园" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/02/28/zhihu-lundaiguang/" title="知乎轮带逛 - 定向爬取轮子哥赞过的妹子图">
  <strong>上一篇：</strong><br/>
  <span>
  知乎轮带逛 - 定向爬取轮子哥赞过的妹子图</span>
</a>
</div>


<div class="next">
<a href="/2016/01/16/http-proxy-get1/"  title="使用 Python 实现一个简单的 HTTP 代理 - GET">
 <strong>下一篇：</strong><br/> 
 <span>使用 Python 实现一个简单的 HTTP 代理 - GET
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#判断输入文件何时改变：Decider-函数"><span class="toc-number">1.</span> <span class="toc-text">判断输入文件何时改变：Decider 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-MD5-签名来决定文件是否改变"><span class="toc-number">1.1.</span> <span class="toc-text">使用 MD5 签名来决定文件是否改变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-MD5-签名的好处"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用 MD5 签名的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用时间戳来判断文件是否改变"><span class="toc-number">1.2.</span> <span class="toc-text">使用时间戳来判断文件是否改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同时使用-MD-签名和时间戳来判断文件是否改变"><span class="toc-number">1.3.</span> <span class="toc-text">同时使用 MD 签名和时间戳来判断文件是否改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写一个自定义的-Decider-方法"><span class="toc-number">1.4.</span> <span class="toc-text">写一个自定义的 Decider 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合使用不同方法来判断一个文件是否改变"><span class="toc-number">1.5.</span> <span class="toc-text">混合使用不同方法来判断一个文件是否改变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#决策函数的历史版本"><span class="toc-number">2.</span> <span class="toc-text">决策函数的历史版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SourceSignature-方法"><span class="toc-number">2.1.</span> <span class="toc-text">SourceSignature 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TargetSignatures-方法"><span class="toc-number">2.2.</span> <span class="toc-text">TargetSignatures 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐式依赖：-CPPPATH-配置变量"><span class="toc-number">3.</span> <span class="toc-text">隐式依赖：$CPPPATH 配置变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存隐式依赖"><span class="toc-number">4.</span> <span class="toc-text">缓存隐式依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#–implicit-deps-changed-选项"><span class="toc-number">4.1.</span> <span class="toc-text">–implicit-deps-changed 选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#–implicit-deps-unchanged-选项"><span class="toc-number">4.2.</span> <span class="toc-text">–implicit-deps-unchanged 选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#显式依赖：Depends-方法"><span class="toc-number">5.</span> <span class="toc-text">显式依赖：Depends 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#来自外部文件的依赖：ParseDepends-方法"><span class="toc-number">6.</span> <span class="toc-text">来自外部文件的依赖：ParseDepends 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忽略依赖：Ignore-函数"><span class="toc-number">7.</span> <span class="toc-text">忽略依赖：Ignore 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按序依赖：Requires-方法"><span class="toc-number">8.</span> <span class="toc-text">按序依赖：Requires 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AlwaysBuild-方法"><span class="toc-number">9.</span> <span class="toc-text">AlwaysBuild 方法</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="lyyyuna" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/数学/" title="数学">数学<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂/" title="杂">杂<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/系统/" title="系统">系统<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/网络/" title="网络">网络<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/自动化测试/" title="自动化测试">自动化测试<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/语言/" title="语言">语言<sup>12</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/robot-framework/" title="robot framework">robot framework<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Python-script/" title="Python script">Python script<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/scons/" title="scons">scons<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Python2-7源码/" title="Python2.7源码">Python2.7源码<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/mnist/" title="mnist">mnist<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/neural-network/" title="neural network">neural network<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/asyncio/" title="asyncio">asyncio<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/cpp/" title="cpp">cpp<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/DHT/" title="DHT">DHT<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Windows-Debugger/" title="Windows Debugger">Windows Debugger<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/爬虫/" title="爬虫">爬虫<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Exif/" title="Exif">Exif<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/http-proxy/" title="http proxy">http proxy<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/bilibili/" title="bilibili">bilibili<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/shellcode/" title="shellcode">shellcode<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Celery/" title="Celery">Celery<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/openwrt/" title="openwrt">openwrt<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Python3-x源码/" title="Python3.x源码">Python3.x源码<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.lihulab.net" target="_blank" title="自动化测试">自动化测试</a>
            
          </li>
        
          <li>
            
            	<a href="http://oj.lihulab.net" target="_blank" title="蠡湖实验室 OJ">蠡湖实验室 OJ</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello, I am lyy <br/>
			This is my blog, believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/lyyyuna" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		<a href="https://www.douban.com/people/44114278" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/li-yi-yang-38" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:lyyyuna@outlook.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="lyyyuna">lyyyuna</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'lyyyuna';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-42389939-1', 'www.lyyyuna.com');  
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4ba228e3ecc48b86bafa07900215f733";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
